
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.

    The stub of this file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.


 */


#include <Configuration.hxx> // TODO; should go away, is already in Base class for ages

#include <DIoLMotor.h>
#include <ASIoLMotor.h>
#include <sstream>

extern "C" {
#include <curl/curl.h>
};

#include <chrono>
#include <thread>
#include <functional>
#include <string>
#include <random>
#include <cib_registers.h>
#include <mem_utils.h>
#include <cib_mem.h>
#define DEBUG 1

#define log_msg(s,met,msg) "[" << s << "]::" << met << " : " << msg

#define log_e(m,s) log_msg("ERROR",m,s)
#define log_w(m,s) log_msg("WARN",m,s)
#define log_i(m,s) log_msg("INFO",m,s)

using std::ostringstream;

namespace Device
{
// 1111111111111111111111111111111111111111111111111111111111111111111111111
// 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
// 1     Users don't modify this code!!!!                                  1
// 1     If you modify this code you may start a fire or a flood somewhere,1
// 1     and some human being may possible cease to exist. You don't want  1
// 1     to be charged with that!                                          1
// 1111111111111111111111111111111111111111111111111111111111111111111111111






// 2222222222222222222222222222222222222222222222222222222222222222222222222
// 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
// 2     (code for which only stubs were generated automatically)          2
// 2     You should add the implementation but dont alter the headers      2
// 2     (apart from constructor, in which you should complete initializati2
// 2     on list)                                                          2
// 2222222222222222222222222222222222222222222222222222222222222222222222222

/* sample ctr */
DIoLMotor::DIoLMotor(
    const Configuration::IoLMotor &config,
    Parent_DIoLMotor *parent) : Base_DIoLMotor(config, parent)

                                /* fill up constructor initialization list here */
                                ,
                                m_position_motor(-999999),
                                m_position_setpoint(-999999), 
                                m_is_ready(false), 
                                m_is_moving(false), 
                                m_acceleration(0), 
                                m_deceleration(0), 
                                m_speed_setpoint(200), 
                                m_speed_readout(0), 
                                m_torque(0.0), 
                                m_temperature(0.0)
                                //,m_address("")
                                ,
                                m_refresh_ms(500), 
                                m_refresh_cib_ms(10), 
                                m_stats_monitor(false), 
                                m_position_monitor(false), 
                                m_cib_monitor(false), 
                                m_monitor_status(OpcUa_BadResourceUnavailable),
                                m_server_host(""), 
                                m_server_port(0), 
                                m_range_min(-999999), 
                                m_range_max(-999999), 
                                m_alarm_code_motor(0), 
                                m_coordinate_index(0), 
                                m_id("NONE"), 
                                m_mmap_fd(0), 
                                m_status(sOffline)

{
    /* fill up constructor body here */
    // initialize cURL
    curl_global_init(CURL_GLOBAL_ALL);

    // allocate the memory mapped registers
    (void)init_cib_mem();
    m_status_map.insert({sOffline,"offline"});
    m_status_map.insert({sReady,"ready"});
    m_status_map.insert({sOperating,"moving"});
    m_status_map.insert({sError,"error"});

    m_id = id();
}

/* sample dtr */
DIoLMotor::~DIoLMotor ()
{
    clear_cib_mem();
    curl_global_cleanup();
}

/* delegates for cachevariables */

/* Note: never directly call this function. */

UaStatus DIoLMotor::writeRange_min ( const OpcUa_Int32& v)
{
    return set_range_min(v);
}
/* Note: never directly call this function. */

UaStatus DIoLMotor::writeRange_max ( const OpcUa_Int32& v)
{
    return set_range_max(v);
}
/* Note: never directly call this function. */

UaStatus DIoLMotor::writeRefresh_period_ms ( const OpcUa_UInt16& v)
{
    return set_refresh_period(v);
}
/* Note: never directly call this function. */

UaStatus DIoLMotor::writeAcceleration ( const OpcUa_UInt32& v)
{
    return set_acceleration(v);
}
/* Note: never directly call this function. */

UaStatus DIoLMotor::writeDeceleration ( const OpcUa_UInt32& v)
{
    return set_deceleration(v);
}
/* Note: never directly call this function. */

UaStatus DIoLMotor::writeSpeed ( const OpcUa_UInt32& v)
{
    return set_speed(v);
}


/* delegators for methods */
UaStatus DIoLMotor::callConfig (
    const UaString&  config_json,
    UaString& response
)
{
    LOG(Log::INF) << "Received JSON configuration file ";

    LOG(Log::INF) << "Raw content : " << config_json.toUtf8();

    json resp;
    const std::string lbl = "config";
    bool has_exception = false;
    UaStatus st = OpcUa_Good;
    std::ostringstream msg("");
    try
    {
      // have to be careful about the escapes
      // \n, \". etc. These seem to cause trouble
      //json config(config_json.toUtf8());
      //std::string tmp(reinterpret_cast<char*>(config_json.toOpcUaString()->data),config_json.toOpcUaString()->length);
      json jconf = json::parse(config_json.toUtf8());
      st = config(jconf,resp);
      resp["status"] = "OK";
      msg.clear(); msg.str("");
      msg << log_i("config","Motor configuration updated");
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
      response = UaString(resp.dump().c_str());
    }
    catch(json::exception &e)
    {
      has_exception = true;
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught a JSON parsing exception : ") << e.what();
    }
    catch(std::exception &e)
    {
      has_exception = true;
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught an STL exception : ") << e.what();
    }
    catch(...)
    {
      has_exception = true;
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught an unknown exception");
    }
    if (has_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;

      response = UaString(resp.dump().c_str());
      return OpcUa_Good;
    }

    // force an update after a successful config
    update();
    return OpcUa_Good;
}
UaStatus DIoLMotor::callMove_absolute (
    OpcUa_Int32 destination,
    UaString& response
)
{
    json resp;
    // the returned status is always OpcUa_Good
    // but the real execution status is passed through the json response
    UaStatus st = OpcUa_Good;
    st = move_wrapper(destination,resp);
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLMotor::callMove_relative (
    OpcUa_Int32 num_steps,
    UaString& response
)
{
    json resp;
    // refresh the current position
    update();
    // the returned status is always OpcUa_Good
    // but the real execution status is passed through the json response
    UaStatus st = OpcUa_Good;
    st = move_wrapper(m_position_motor+num_steps,resp);
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLMotor::callStop (
    UaString& response
)
{
    // stopping is a serious business. Should be called immediately
    json resp;
    UaStatus st = OpcUa_Good;
    st = motor_stop(resp);
#ifdef DEBUG
    if (st != OpcUa_Good)
    {
      LOG(Log::ERR) << "Remote command execution failed.";
    }
#endif
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLMotor::callReset (
    UaString& response
)
{
    // a reset is the same as a clear alarm
    //FIXME: Implement it
    return OpcUa_BadNotImplemented;
}
UaStatus DIoLMotor::callClear_alarm (
    UaString& response
)
{
    json resp;
    UaStatus st = OpcUa_Good;
    st = motor_clear_alarm(resp);
#ifdef DEBUG
    if (st != OpcUa_Good)
    {
      LOG(Log::ERR) << "Remote command execution failed.";
    }
#endif
    response = UaString(resp.dump().c_str());

    return OpcUa_Good;
}

// 3333333333333333333333333333333333333333333333333333333333333333333333333
// 3     FULLY CUSTOM CODE STARTS HERE                                     3
// 3     Below you put bodies for custom methods defined for this class.   3
// 3     You can do whatever you want, but please be decent.               3
// 3333333333333333333333333333333333333333333333333333333333333333333333333
  UaStatus DIoLMotor::move_wrapper(int32_t dest, json &resp)
  {
    // this wrapper also checks the validity of the target position
    // while motor_move only executes
    UaStatus st = OpcUa_Good;
    std::ostringstream msg("");
    st = check_motor_ready(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    // -- if we don't have a good monitoring status we cannot be sure of
    // what is the status of the motor downstream.
    // therefore, refuse any movement operation
    st = check_monitor_status(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    // check if the target is within range
    st = check_position_in_range(dest,resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    // all checks passed. Set the position and execute the request
    // set the target position
    st = set_position_setpoint(dest);
    if (st != OpcUa_Good)
    {
      return st;
    }
    // check that position and position_set_point are not the same
    if (m_position_motor == m_position_setpoint)
    {
      resp["status"] = "OK";
      msg.clear(); msg.str("");
      msg << log_w("start_move","Motor is already at destination") << " (" << m_position_motor << " vs " << m_position_setpoint << ")";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
#ifdef DEBUG
      LOG(Log::WRN) << msg.str();
#endif
      return OpcUa_Good;
    }
    //
    // if it reaches this point we can initiate the movement
    st = motor_move(resp);
    //
    return st;
  }
  UaStatus DIoLMotor::motor_move(json &resp)
  {
    // set the moving and direction bits of the respective registers
    // it is not an issue if they are set a bit earlier...the motor should not be moving at this stage
    // make a mask for the relevant bits
    //    std::string reg = "moving";
    //    cib::util::reg_write_mask_offset(m_regs.at(reg).addr,0x1,m_regs.at(reg).mask,m_regs.at(reg).bit_low);
    const std::string lbl = "move_motor";
    uint32_t dir;
    UaStatus st = OpcUa_Good;
    if (m_position_setpoint > m_position_motor)
    {
      dir = 0x1;
    }
    else
    {
      dir = 0x0;
    }
    st = cib_set_direction(dir);
    if (st != OpcUa_Good)
    {
      return st;
    }
    st = cib_set_init_position(m_position_motor);
    if (st != OpcUa_Good)
    {
      return st;
    }
    // and now start the motor moving
    std::string query = "move";
    OpcUa_StatusCode status= OpcUa_Good;
    ostringstream qpars("");
    qpars << "pos=" << m_position_setpoint;
    if (m_speed_setpoint != 0)
    {
      qpars << "&speed=" << m_speed_setpoint;
    }
    if (m_acceleration != 0)
    {
      qpars << "&accel=" << m_acceleration;
    }
    if (m_deceleration != 0)
    {
      qpars << "&decel=" << m_deceleration;
    }
    query += "?";
    query += qpars.str();
    json answer;
    status = query_motor(query,answer,resp);
    if (status != OpcUa_Good)
    {
      return status;
    }
    /**
     * Typical answer: {"status":"OK"}
     */
    if (answer["status"] == string("OK"))
    {
      std::ostringstream msg("");
      status = OpcUa_Good;
      msg << log_i(lbl.c_str(),"Remote command successful");
#ifdef DEBUG
      LOG(Log::INF) << msg.str();
#endif
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    else
    {
      resp["status"] = "ERROR";
      std::ostringstream msg("");
      msg << log_e(lbl.c_str(),"Failed to execute remote command : ") << answer["status"];
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      status =  OpcUa_Bad;
    }
    return status;
  }
  // this is meant to just be called occasionally
  // each method is responsible for updating its own status
  void DIoLMotor::update()
  {
    // method should be periodically poking the motors for their status
    OpcUa_StatusCode status= OpcUa_Good;
    // this should no longer be called
    json resp;
    UaStatus stat_cib = check_cib_mem(resp);

    //	bool msg_printed = false;
    if (m_monitor_status != OpcUa_Good)
    {
      //		if (!msg_printed)
      //		{
      //			LOG(Log::ERR) << "Failed to query device for status. Setting read values to InvalidData";
      //			msg_printed = true;
      //		}
      status = OpcUa_BadResourceUnavailable;
      //	} else
      //	{
      //		// reset the state until connection is lost again
      //		msg_printed = false;
}
    // i.e., form the server to the client
    //position_ = {static_cast<double>(rand()),static_cast<double>(rand()),static_cast<double>(rand())};
    getAddressSpaceLink()->setCurrent_position_motor(m_position_motor,status);
    getAddressSpaceLink()->setCurrent_position_cib(m_position_cib,stat_cib);
    //getAddressSpaceLink()->setSpeed(m_speed, status);
    // -- the speed is obtained from the address space
    //m_speed = getAddressSpaceLink()->getSpeed();
    getAddressSpaceLink()->setTorque(m_torque, status);
    getAddressSpaceLink()->setTemperature_C(m_temperature, status);
    getAddressSpaceLink()->setSpeed_readout(m_speed_readout, status);
    getAddressSpaceLink()->setIs_moving(m_is_moving, status);
    getAddressSpaceLink()->setAlarm_code(m_alarm_code_motor,status);
    //getAddressSpaceLink()->setAcceleration(m_acceleration, OpcUa_Good);
    UaString ss(m_status_map.at(m_status).c_str());
    getAddressSpaceLink()->setState(ss,OpcUa_Good);

    // now the getters -- for now allow all to be updated, but eventually set limitations
    // these getters are for variables with "regular" writing policy. We can change that
    //status |= getAddressSpaceLink()->getSpeed_setpoint(m_speed_setpoint);
    status |= getAddressSpaceLink()->getAcceleration(m_acceleration);
    status |= getAddressSpaceLink()->getDeceleration(m_deceleration);

  }
  bool DIoLMotor::is_ready()
  {
    // actually, this should check a few more things:
    // 1. is moving (not ready)
    // 2. all parameters have reasonable values
    // 2.1. position_set_point
    // 2.2. speed
    // 2.3. acceleration
    //    LOG(Log::INF) << "Checking readiness for motor ID=" << m_id
    //        << " with positionSetPoint = (" << m_position_setpoint << ")";
    // if the server and port are not defined, certainly it is not ready
    if (m_server_host.size() == 0)
    {
      return false;
    }
    if (m_server_port == 0)
    {
      return false;
    }
    // if the motor is moving, do not take new requests
    if (m_is_moving)
    {
      return false;
    }
    return true;
  }
  size_t DIoLMotor::curl_write_function(void* ptr, size_t size, size_t nmemb, std::string* data)
  {
    data->append((char*)ptr, size * nmemb);
    return size * nmemb;
  }
  // monitoring timer
  void DIoLMotor::motor_position_monitor()
  {
    if (m_position_monitor.load())
    {
#ifdef DEBUG
      LOG(Log::WRN) << log_w("motor_monitor","Trying to set a position monitor timer that has already been set up. Skipping.");
#endif
      return;
    }
    m_position_monitor.store(true);
    std::thread([this]()
                {
      json resp;
      // int32_t prev_pos;
      // int32_t prev_prev_pos;
      UaStatus st;
      while (m_position_monitor.load())
      {
        auto x = std::chrono::steady_clock::now() + std::chrono::milliseconds(m_refresh_ms);
        // prev_pos = m_position_motor;
        // prev_prev_pos = prev_pos;
        st = motor_get_position(resp);
        if (st != OpcUa_Good)
        {
#ifdef DEBUG
          LOG(Log::ERR) << log_e("motor_monitor","Failed to query device for position. Setting read values to InvalidData");
#endif

        }
        // use the CIB as the reference for identifying motor movement
        // // check if we are moving based on the comparison with the previous position
        // if (m_position_motor == prev_prev_pos)
        // {
        //   m_is_moving = false;
        //   update_status(sReady);
        // }
        // else
        // {
        //   m_is_moving = true;
        //   update_status(sOperating);
        // }
        // getAddressSpaceLink()->setIs_moving(m_is_moving,OpcUa_Good);
        std::this_thread::sleep_until(x);
      }
                }).detach();
  }

  void DIoLMotor::motor_stats_monitor()
  {
    if (m_stats_monitor.load())
    {
#ifdef DEBUG
      LOG(Log::WRN) << "Trying to set a stats monitor timer that has already been set up. Skipping.";
#endif
      return;
    }
    m_stats_monitor.store(true);
    std::thread([this]()
                {
      UaStatus st = OpcUa_Good;
      while (m_stats_monitor.load())
      {
        auto x = std::chrono::steady_clock::now() + std::chrono::milliseconds(10*m_refresh_ms);
        st = motor_get_info();
        if (st != OpcUa_Good)
        {
          m_monitor_status = OpcUa_BadResourceUnavailable;
          //getAddressSpaceLink()->setOperation_status(m_monitor_status,m_monitor_status);
#ifdef DEBUG
          LOG(Log::ERR) << log_e("stat_mon","Failed to query device for status. Setting read values to InvalidData");
#endif
        }
        // we should not use the speed readout to figure out
        // when it is moving
        std::this_thread::sleep_until(x);
      }
                }).detach();
  }

  void DIoLMotor::cib_movement_monitor()
  {
    // in this case, even though it is a separate thread, use the motor as the reference
    if (m_cib_monitor.load())
    {
      LOG(Log::WRN) << log_w("cib_mon","CIB monitor already running. Doing nothing.");
      return;
    }
    m_cib_monitor.store(true);
    std::thread([this]()
                {
      int32_t cpos;
      int32_t prev_pos = m_position_cib;
      int32_t prev_prev_pos = prev_pos;
      while (m_cib_monitor.load())
      {
        auto x = std::chrono::steady_clock::now() + std::chrono::milliseconds(m_refresh_cib_ms);
        //prev_pos =m_position_cib;
        prev_prev_pos = prev_pos;
        prev_pos = m_position_cib;
        UaStatus st = cib_get_position(cpos);
#ifdef DEBUG
        if (st != OpcUa_Good)
        {
          LOG(Log::ERR) << log_e("cib_monitor","Failed to get the current position : ") << cpos;
        }
#endif
        m_position_cib = cpos;
        getAddressSpaceLink()->setCurrent_position_cib(m_position_cib,OpcUa_Good);
        if (m_position_cib == prev_prev_pos)
        {
          m_is_moving = false;
          update_status(sReady);
        }
        else
        {
          m_is_moving = true;
          update_status(sOperating);
        }
        getAddressSpaceLink()->setIs_moving(m_is_moving,OpcUa_Good);

        std::this_thread::sleep_until(x);
      } })
        .detach();
  }
  UaStatus DIoLMotor::query_motor(const std::string request, json &reply, json &resp)
  {
    // All low level functions should call this one for requests
    const std::string lbl = "query_motor";
    string addr = "http://";
    addr+= m_server_host;
    addr += "/api/";
    addr += request;
//#ifdef DEBUG
//    LOG(Log::INF) << log_i(lbl.c_str(),"Query address : ") << addr;
//#endif
    uint16_t lport = m_server_port;
    //mutex to
    const std::lock_guard<std::mutex> lock(m_motor_mtx);
    auto curl = curl_easy_init();
    if (curl)
    {
      curl_easy_setopt(curl, CURLOPT_URL, addr.c_str());
      curl_easy_setopt(curl, CURLOPT_PORT, lport);

      curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
      // this may eventually become a configuration parameter?
      //curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 500L);

      //curl_easy_setopt(curl, CURLOPT_USERPWD, "user:pass");
      curl_easy_setopt(curl, CURLOPT_USERAGENT, "curl/7.42.0");
      curl_easy_setopt(curl, CURLOPT_MAXREDIRS, 50L);
      curl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, 1L);

      std::string response_string;
      std::string header_string;
      curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_write_function);
      curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_string);
      curl_easy_setopt(curl, CURLOPT_HEADERDATA, &header_string);
      CURLcode res = curl_easy_perform(curl);
      // Check for errors
      // timeout error is  CURLE_OPERATION_TIMEDOUT
      if (res != CURLE_OK)
      {
        std::ostringstream msg("");
        msg << log_e(lbl.c_str(),"curl_easy_perform() failed: ") << curl_easy_strerror(res);
#ifdef DEBUG
        LOG(Log::ERR) << msg.str();
#endif
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadCommunicationError;
        curl_easy_cleanup(curl);
        curl = NULL;
        // change this flag to indicate that the connection to the motor failed.
        // this should trigger a stop and a lockdown
        return OpcUa_BadCommunicationError;
      }
//#ifdef DEBUG
//      LOG(Log::INF) << log_i(lbl.c_str(),"Received response [") << response_string << "]";
//#endif
      try
      {
        reply = json::parse(response_string);
      }
      catch (std::exception &e)
      {
        std::ostringstream msg("");
        msg << log_e(lbl.c_str(),"Caucght an exception parsing the server response: ") << e.what();
#ifdef DEBUG
        LOG(Log::ERR) << msg.str();
#endif
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadCommunicationError;
        curl_easy_cleanup(curl);
        curl = NULL;
        return OpcUa_BadCommunicationError;
      }
    }
    curl_easy_cleanup(curl);
    curl = NULL;
    return OpcUa_Good;
  }
  UaStatus DIoLMotor::motor_get_info()
  {
    std::string request = "info";
    json reply, resp;
    UaStatus st = query_motor(request,reply,resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    try
    {
      // Occasionally there is some JSON parsing exception showing up from the motors
      // which I expect to come from here
      // if it arrived here, we have a valid answer
      if (reply.contains("cur_pos"))
      {
        m_position_motor = reply.at("cur_pos").get<int32_t>();
      }
      if (reply.contains("tar_pos"))
      {
        int32_t tpos = reply.at("tar_pos").get<int32_t>();
        if ((tpos < (m_position_setpoint-5)) || (tpos > (m_position_setpoint+5)))
        {
          // something is wrong, the target is not what we think
          // FIXME: What to do in this case?
#ifdef DEBUG
          LOG(Log::ERR) << log_e("get_info","Mismatch in set_point. Got ") << tpos << " expected " << m_position_setpoint;
#endif
          }
      }
      if (reply.contains("cur_speed"))
      {
        m_speed_readout = reply.at("cur_speed").get<uint32_t>();
      }
      if (reply.contains("torque"))
      {
        m_torque = std::stod(reply.at("torque").get<std::string>());
      }
      if (reply.contains("m_temp"))
      {
        m_temperature = std::stod(reply.at("m_temp").get<std::string>());
      }
      if (reply.contains("alarm_code"))
      {
        m_alarm_code_motor = reply.at("alarm_code").get<int32_t>();
      }
      m_monitor_status = OpcUa_Good;
    }
    catch(json::exception &e)
    {
      m_monitor_status = OpcUa_BadCommunicationError;
#ifdef DEBUG
      std::ostringstream msg("");
      msg << log_e("get_info","Caught a JSON exception : ") << e.what();
      LOG(Log::ERR) << msg.str();
#endif
      return OpcUa_BadCommunicationError;
    }
    catch(std::exception &e)
    {
      m_monitor_status = OpcUa_BadCommunicationError;
#ifdef DEBUG
      std::ostringstream msg("");
      msg << log_e("get_info","Caught an STL exception : ") << e.what();
      LOG(Log::ERR) << msg.str();
#endif
      return OpcUa_BadCommunicationError;
    }

    return OpcUa_Good;
  }
  //
  UaStatus DIoLMotor::motor_stop(json &resp)
  {
    const std::string lbl = "stop";
    UaStatus st = OpcUa_Good;
    std::string query = "stop";
    json answer;
    st = query_motor(query,answer,resp);
#ifdef DEBUG
    LOG(Log::INF) << "Received response [" << answer << "]";
#endif
    // now we should parse the answer
    // it is meant to be a json object
    if (answer["status"] == string("OK"))
    {
      std::ostringstream msg("");
      msg << log_i(lbl.c_str(),"Remote command successful");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
#ifdef DEBUG
      LOG(Log::INF) << msg.str();
#endif
      st =  OpcUa_Good;
    }
    else
    {
      std::ostringstream msg("");
      msg << log_e(lbl.c_str(),"Failed to execute remote command successful");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      st = OpcUa_Bad;
    }
    // -- why not, refresh also the current position, as stated by the motor
    st = cib_set_init_position(m_position_motor);
    return st;
  }
  UaStatus DIoLMotor::motor_clear_alarm(json &resp)
  {
    const std::string lbl = "clear_alarm";
    UaStatus st = OpcUa_Good;
    std::string query = "clear_alarm";
    json answer;
    st = query_motor(query,answer,resp);
#ifdef DEBUG
    LOG(Log::INF) << "Received response [" << answer << "]";
#endif
    // now we should parse the answer
    // it is meant to be a json object
    if (answer["status"] == string("OK"))
    {
      std::ostringstream msg("");
      msg << log_i(lbl.c_str(),"Remote command successful");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
#ifdef DEBUG
      LOG(Log::INF) << msg.str();
#endif
      st =  OpcUa_Good;
    }
    else
    {
      std::ostringstream msg("");
      msg << log_e(lbl.c_str(),"Failed to execute remote command successful");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      st = OpcUa_Bad;
    }
    return st;
  }
  UaStatus DIoLMotor::motor_get_position(json &resp)
  {
    const std::string lbl = "motor_get_position";
    UaStatus st = OpcUa_Good;
    std::string query = "position";
    json answer;
    st = query_motor(query,answer,resp);
//#ifdef DEBUG
//    LOG(Log::INF) << "Received response [" << answer << "]";
//#endif
    // now we should parse the answer
    // it is meant to be a json object
    if (answer["status"] == string("OK"))
    {
      m_position_motor = answer.at("position").get<int32_t>();
      std::ostringstream msg("");
      msg << log_i(lbl.c_str(),"Remote command successful");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
//#ifdef DEBUG
//      LOG(Log::INF) << msg.str();
//#endif
      st =  OpcUa_Good;
    }
    else
    {
      std::ostringstream msg("");
      msg << log_e(lbl.c_str(),"Failed to execute remote command successful");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      st = OpcUa_Bad;
    }
    return st;
  }
  UaStatus DIoLMotor::motor_get_alarm(json &resp)
  {
    const std::string lbl = "motor_get_alarm";
    UaStatus st = OpcUa_Good;
    std::string query = "get_alarm";
    json answer;
    st = query_motor(query,answer,resp);
#ifdef DEBUG
    LOG(Log::INF) << "Received response [" << answer << "]";
#endif
    // now we should parse the answer
    // it is meant to be a json object
    if (answer["status"] == string("OK"))
    {
      m_alarm_code_motor = answer.at("alarm_code").get<int32_t>();
      std::ostringstream msg("");
      msg << log_i(lbl.c_str(),"Remote command successful");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
#ifdef DEBUG
      LOG(Log::INF) << msg.str();
#endif
      st =  OpcUa_Good;
    }
    else
    {
      std::ostringstream msg("");
      msg << log_e(lbl.c_str(),"Failed to execute command : ") << answer["status"];
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      st = OpcUa_Bad;
    }
    return st;
  }

  // set the motor range to validate requests
  UaStatus DIoLMotor::set_range_min(const int32_t &v)
  {
    // this is just an internal limiter, so just make the assignment
    m_range_min = v;
    UaStatus ss = getAddressSpaceLink()->setRange_min(m_range_min,OpcUa_Good);
    return ss;
  }
  UaStatus DIoLMotor::set_range_max(const int32_t &v)
  {
    // this is just an internal limiter, so just make the assignment
    m_range_max = v;
    UaStatus ss = getAddressSpaceLink()->setRange_max(m_range_max,OpcUa_Good);
    return ss;
  }
  UaStatus DIoLMotor::set_id(const std::string &id)
  {
    m_id = id;
    return OpcUa_Good;
  }
  UaStatus DIoLMotor::set_refresh_period(const uint16_t &v)
  {
    m_refresh_ms = v;
#ifdef DEBUG
    LOG(Log::INF) << "Updating refresh rate for motor " << m_id << " to " << v << " ms";
#endif
    if (v != 0 && !m_stats_monitor)
    {
#ifdef DEBUG
      LOG(Log::INF) << "Starting a timer on motor " << m_id << " to refresh every " << v << " ms";
#endif
//      motor_position_monitor();
//      // -- do 10 times that for the stats
//      motor_stats_monitor();
    }
    else if (v == 0)
    {
#ifdef DEBUG
      LOG(Log::WRN) << "Stopping the monitor timer" ;
#endif
      m_stats_monitor = false;
    }
    UaStatus st = getAddressSpaceLink()->setRefresh_period_ms(v,OpcUa_Good);
    //
    return st;
  }
  UaStatus DIoLMotor::set_acceleration(const uint32_t &v)
  {
#ifdef DEBUG
    LOG(Log::INF) << "Updating acceleration motor " << m_id << " to " << v ;
#endif
    m_acceleration = v;
    UaStatus st = getAddressSpaceLink()->setAcceleration(m_acceleration,OpcUa_Good);
    return st;
  }
  UaStatus DIoLMotor::set_deceleration(const uint32_t &v)
  {
#ifdef DEBUG
    LOG(Log::INF) << "Updating deceleration motor " << m_id << " to " << v ;
#endif
    m_deceleration = v;
    UaStatus st= getAddressSpaceLink()->setDeceleration(m_deceleration,OpcUa_Good);
    return st;
  }
  UaStatus DIoLMotor::set_speed(const uint32_t &v)
  {
#ifdef DEBUG
    LOG(Log::INF) << "Updating spped of motor " << m_id << " to " << v ;
#endif
    m_speed_setpoint = v;
    UaStatus st = getAddressSpaceLink()->setSpeed(m_speed_setpoint,OpcUa_Good);
    return st;
  }
  //
  UaStatus DIoLMotor::config(json &conf, json &resp)
  {
    UaStatus st = OpcUa_Good;
    const std::string lbl = "config";
    std::ostringstream msg("");
    // -- first things first, validate the configuration fragment
    st = validate_config_fragment(conf,resp);
    if (st != OpcUa_Good )
    {
      msg.clear();msg.str("");
      msg << log_e(lbl.c_str()," ") << "Incomplete config fragment.";
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["messages"].push_back(msg.str());
      return OpcUa_BadInvalidArgument;
    }
    // first confirm that this configuration is for the correct motor
#ifdef DEBUG
    LOG(Log::INF) << "Dumping  config fragment : " << conf.dump();
#endif
    if (conf.at("id").get<std::string>() != m_id)
    {
      msg << log_e("config"," ") << "Mismatch in motor id on configuration token (" << m_id << "!=" << conf.at("id").get<std::string>() << ")";
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return OpcUa_BadInvalidArgument;
    }
    // if the ids match, lets set the parameters
    // special iterator member functions for objects
    // -- not that it matters in this specific case, but lets first map the registers
    json regconf = conf.at("mmap");
    st = map_registers(regconf,resp);
    if (st != OpcUa_Good)
    {
      msg.clear();msg.str("");
      msg << log_e(lbl.c_str()," ") << "Failed to map registers.";
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return OpcUa_BadInvalidArgument;
    }
    for (json::iterator it = conf.begin(); it != conf.end(); ++it)
    {
#ifdef DEBUG
      LOG(Log::INF) << "Processing " << it.key() << " : " << it.value() << "\n";
#endif
      if (it.key() == "server_address")
      {
        m_server_host = it.value();
        UaString as_v(m_server_host.c_str());
        st = getAddressSpaceLink()->setServer_addr(as_v,OpcUa_Good);
        if (st!= OpcUa_Good)
        {
          msg.clear(); msg.str("");
          msg << log_w(lbl.c_str(),"Failure updating [server_addr] in adress space. Returned code ") << st;
          resp["messages"].push_back(msg.str());
#ifdef DEBUG
          LOG(Log::WRN) << msg.str();
#endif
        }
      }
      if (it.key() == "server_port")
      {
        m_server_port = it.value();
        st = getAddressSpaceLink()->setServer_port(m_server_port,OpcUa_Good);
        if (st!= OpcUa_Good)
        {
          msg.clear(); msg.str("");
          msg << log_w(lbl.c_str(),"Failure updating [server_port] in adress space. Returned code ") << st;
          resp["messages"].push_back(msg.str());
#ifdef DEBUG
          LOG(Log::WRN) << msg.str();
#endif
        }
      }
      if (it.key() == "speed")
      {
        st = set_speed(it.value());
      }
      if (it.key() == "acceleration")
      {
        st = set_acceleration(it.value());
      }
      if (it.key() == "deceleration")
      {
        st = set_deceleration(it.value());
      }
      if (it.key() == "refresh_period_ms")
      {
        st = set_refresh_period(it.value());
      }
      if (it.key() == "range")
      {
        int32_t min, max;
        min = it.value().at(0);
        max = it.value().at(1);
        st = set_range_min(min);
        st = set_range_max(max);
      }
      if (it.key() == "coordinate_index")
      {
        m_coordinate_index = it.value();
      }
      if (it.key() == "refresh_movememt_ms")
      {
        // timer to refresh the cib position
        m_refresh_cib_ms = it.value();
        // since by now the registers are mapped, we can initiate the thread
      }
    }
    update_status(sReady);
    //
    // configuration is done.
    // start by resetting the target position to the current position
    st = motor_get_position(resp);
    if (st == OpcUa_Good)
    {
      m_position_setpoint = m_position_motor;
    }
    //
    // start the monitors
    motor_position_monitor();
    motor_stats_monitor();
    cib_movement_monitor();
    //
    return st;
  }
  UaStatus DIoLMotor::validate_config_fragment(json &conf, json &resp)
  {
    // this is just a validation check for the available keys.
    // it will only check the mandatory keys.
    const std::string lbl = "validate_config";
    std::vector<std::string> mandatory_keys = {
        "id","coordinate_index","server_address","server_port",
        "speed","range","acceleration","deceleration",
        "refresh_period_ms","refresh_movement_ms","mmap"
    };
    std::vector<std::string> optional_keys = {   };
    //
    // actually, check for all entries and report all missing ones
    std::vector<std::string> missing;
    //
    for (auto entry: mandatory_keys)
    {
      if (!conf.contains(entry))
      {
        missing.push_back(entry);
      }
    }
    if (missing.size() > 0)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Missing mandatory entries in MOTOR config fragment [");
      for (auto e : missing)
      {
        msg << "(" <<  e << "),";
      }
      msg << "]";
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return OpcUa_BadInvalidArgument;
    }
    //
    missing.clear();
    // check the optional keys
    for (auto entry: optional_keys)
    {
      if (!conf.contains(entry))
      {
        missing.push_back(entry);
      }
    }
    if (missing.size() > 0)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_w(lbl.c_str(),"Missing optional entries in MOTOR config fragment [");
      for (auto e : missing)
      {
        msg << "(" <<  e << "),";
      }
      msg << "]";
      resp["messages"].push_back(msg.str());
    }
    // all good, return true
    return OpcUa_Good;
  }
  UaStatus DIoLMotor::set_position_setpoint(const int32_t target)
  {
    m_position_setpoint = target;
    getAddressSpaceLink()->setTarget_position(m_position_setpoint,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLMotor::get_position_setpoint(int32_t &target)
  {
    target = m_position_setpoint;
    return OpcUa_Good;
  }
  UaStatus DIoLMotor::get_position_motor(int32_t &pos, json &resp)
  {
    UaStatus st = motor_get_position(resp);
    pos = m_position_motor;
    return st;
  }

  UaStatus DIoLMotor::init_cib_mem()
  {
    // -- there may be several registers to be mapped
    cib_gpio_t tmpreg;
    tmpreg.id = MOTOR_1_REG;
    tmpreg.paddr = GPIO_MOTOR_1_MEM_LOW;
    tmpreg.size = 0xFFF;
    tmpreg.vaddr = cib::util::map_phys_mem(m_mmap_fd,GPIO_MOTOR_1_MEM_LOW,GPIO_MOTOR_1_MEM_HIGH);
    if (tmpreg.vaddr == 0x0)
    {
      LOG(Log::ERR) << "\n\nFailed to map MOTOR_1 CIB memory region. This is going to fail spectacularly!!!\n\n";
    }
    m_reg_map.insert(std::pair<int,cib_gpio_t>(tmpreg.id,tmpreg));
#ifdef DEBUG
    LOG(Log::INF) << "\n\n MOTOR_1_REG mapped to "
        << std::hex << m_reg_map.at(MOTOR_1_REG).vaddr << std::dec;
#endif
    tmpreg.id= MOTOR_2_REG;
    tmpreg.paddr = GPIO_MOTOR_2_MEM_LOW;
    tmpreg.size = 0xFFF;
    tmpreg.vaddr = cib::util::map_phys_mem(m_mmap_fd,GPIO_MOTOR_2_MEM_LOW,GPIO_MOTOR_2_MEM_HIGH);
    if (tmpreg.vaddr == 0x0)
    {
      LOG(Log::ERR) << "\n\nFailed to map MOTOR_2 CIB memory region. This is going to fail spectacularly!!!\n\n";
    }
    m_reg_map.insert(std::pair<int,cib_gpio_t>(tmpreg.id,tmpreg));
#ifdef DEBUG
    LOG(Log::INF) << "\n\n MOTOR_2_REG mapped to " << std::hex << m_reg_map.at(MOTOR_2_REG).vaddr << std::dec;
#endif
    tmpreg.id= MOTOR_3_REG;
    tmpreg.paddr = GPIO_MOTOR_3_MEM_LOW;
    tmpreg.size = 0xFFF;
    tmpreg.vaddr = cib::util::map_phys_mem(m_mmap_fd,GPIO_MOTOR_3_MEM_LOW,GPIO_MOTOR_3_MEM_HIGH);
    if (tmpreg.vaddr == 0x0)
    {
      LOG(Log::ERR) << "\n\nFailed to map MOTOR_3 CIB memory region. This is going to fail spectacularly!!!\n\n";
    }
    m_reg_map.insert(std::pair<int,cib_gpio_t>(tmpreg.id,tmpreg));
#ifdef DEBUG
    LOG(Log::INF) << "\n\nMOTOR_3_REG mapped to " << std::hex << m_reg_map.at(MOTOR_3_REG).vaddr << std::dec;
#endif
    if (m_reg_map.size() != 3)
    {
      // sError is a special case of status, since this
      LOG(Log::ERR) << "\n\nDIoLLaserUnit::DIoLLaserUnit : Failed to map one or more CIB memory regions. This is going to fail spectacularly!!!\n\n";
    }
    return OpcUa_Good;
  }

  bool DIoLMotor::is_in_range(const int32_t &v)
  {
    if ((v > m_range_min) and (v < m_range_max)) return true;
    return false;
  }
  UaStatus DIoLMotor::terminate(json &resp)
  {
    update_status(sOffline);
    // the main thing here is to stop the monitors
    m_cib_monitor.store(false);
    m_position_monitor.store(false);
    m_stats_monitor.store(false);
    //
    return OpcUa_Good;
  }
  UaStatus DIoLMotor::check_cib_mem(json &resp)
  {
    const std::string lbl = "check_cib";
    if (m_reg_map.size() == 0x0)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"CIB memory not mapped. System on lockdown.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
    }
    else
    {
      return OpcUa_Good;
    }
  }
  UaStatus DIoLMotor::validate_registers(json &conf,json &resp)
  {
    const std::string lbl = "validate_registers";
    std::vector<std::string> mandatory_keys = {
        "direction","init_pos","cur_pos"
    };
    //
    // actually, check for all entries and report all missing ones
    std::vector<std::string> missing;
    //
    for (auto entry: mandatory_keys)
    {
      if (!conf.contains(entry))
      {
        missing.push_back(entry);
      }
    }
    if (missing.size() > 0)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Missing mandatory entries in CIB mmap config fragment [");
      for (auto e : missing)
      {
        msg << "(" <<  e << "),";
      }
      msg << "]";
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return OpcUa_BadInvalidArgument;
    }
    //
    missing.clear();
    // all good, return true
    return OpcUa_Good;
  }
  UaStatus DIoLMotor::map_registers(json &conf,json &resp)
  {
    UaStatus st = validate_registers(conf,resp);
    if (st != OpcUa_Good)
    {
      return OpcUa_BadInvalidArgument;
    }
    // this method is specific for each device
    // -- first obtain a map to all the memory
    std::ostringstream msg("");
    const std::string lbl = "map_registers";
    json reginfo = conf;
#ifdef DEBUG
    LOG(Log::INF) << log_i(lbl.c_str(),"Mapping registers");
#endif
    st = check_cib_mem(resp);
    if(st != OpcUa_Good)
    {
#ifdef DEBUG
      LOG(Log::ERR) << log_e(lbl.c_str(),"CIB memory not mapped");
#endif
      return st;
    }
    else
    {
      // if there are any registers there, clean them out
      if (m_regs.size())
      {
        m_regs.clear();
      }
      // now grab the entries
      try
      {
        for (auto jt = reginfo.begin(); jt != reginfo.end(); ++jt)
        {
          if (jt.value().at(0) == -1)
          {
            // disabled register
            // skip
            continue;
          }
          cib_param_t tmp;
          // for these, nothing is optional
          // offset corresponds to the
          tmp.reg = m_reg_map.at(jt.value().at(0));
          tmp.offset = jt.value().at(1);
          tmp.bit_high = jt.value().at(2);
          tmp.bit_low = jt.value().at(3);
          tmp.maddr = (tmp.reg.vaddr+(tmp.offset*GPIO_CH_OFFSET));
          tmp.mask = cib::util::bitmask(tmp.bit_high,tmp.bit_low);
#ifdef DEBUG
          LOG(Log::INF) << "Mapping register " << jt.key() << " with reg_id " << tmp.reg.id
              << " offset " << tmp.offset << " bh " << tmp.bit_high << " bl " << tmp.bit_low
              << " addr " << std::hex << tmp.maddr << std::dec << " mask " << std::hex << tmp.mask
              << std::dec << " ";
#endif
          m_regs.insert(std::pair<std::string,cib_param_t>(jt.key(),tmp));
        }
      }
      catch(json::exception &e)
      {
        msg.clear();msg.str("");
        msg << log_e(lbl.c_str()," ") << "Incomplete config fragment [mmap] : " << e.what();
        resp["messages"].push_back(msg.str());
        return OpcUa_Bad;
      }
      catch(std::exception &e)
      {
        msg.clear();msg.str("");
        msg << log_e(lbl.c_str()," ") << "Problem parsing config fragment [mmap] : " << e.what();
        resp["messages"].push_back(msg.str());
        return OpcUa_Bad;
      }
    }
    // if we reached this point, all is good, so lets start the CIB position monitoring service
    return OpcUa_Good;
  }
  UaStatus DIoLMotor::check_motor_ready(json &resp)
  {
    const std::string lbl = "check_motor_ready";
    if (!is_ready())
    {
      if (!resp.contains("messages"))
      {
        resp["messages"] = json::array();
      }
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      resp["status"] = "ERROR";
      msg << log_e(lbl.c_str(),"Motor is not ready to operate");
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      LOG(Log::ERR) << msg.str();
      return OpcUa_BadInvalidState;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLMotor::check_monitor_status(json &resp)
  {
    if (m_monitor_status != OpcUa_Good)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      resp["status"] = "WARNING";
      msg << log_e("mon_status","Bad motor monitor status ") << m_monitor_status;
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidState;
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      return OpcUa_BadInvalidState;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLMotor::clear_cib_mem()
  {
    // this just cleans up the mapped GPIO registers
    // first clear up the specific mapped registers
    m_regs.clear();
    for (auto item: m_reg_map)
    {
      cib::util::unmap_mem(item.second.vaddr,item.second.size);
    }
    m_reg_map.clear();
    close(m_mmap_fd);
    m_mmap_fd = 0x0;
    return OpcUa_Good;
  }

  UaStatus DIoLMotor::cib_set_init_position(int32_t &pos)
  {
    // convert the position into a signed value with the specific mask
    uint32_t position = cib::util::cast_from_signed(pos,m_regs.at("init_pos").mask);
    cib::util::reg_write_mask_offset(m_regs.at("init_pos").maddr,position,m_regs.at("init_pos").mask,m_regs.at("init_pos").bit_low);
    // load the initial position into the firmware
    cib::util::reg_write_mask_offset(m_regs.at("load").maddr,0x1,m_regs.at("load").mask,m_regs.at("load").bit_low);
    // and now untoggle it
    cib::util::reg_write_mask_offset(m_regs.at("load").maddr,0x0,m_regs.at("load").mask,m_regs.at("load").bit_low);
    return OpcUa_Good;
  }
  UaStatus DIoLMotor::cib_set_direction(uint32_t &dir)
  {
    // convert the position into a signed value with the specific mask
    cib::util::reg_write_mask_offset(m_regs.at("direction").maddr,dir,m_regs.at("direction").mask,m_regs.at("direction").bit_low);
    return OpcUa_Good;
  }
  UaStatus DIoLMotor::cib_get_position(int32_t &pos)
  {
    // Grab the position
    // read the register
    uint32_t reg_val = cib::util::reg_read(m_regs.at("cur_pos").maddr);
    int32_t m_pos = cib::util::cast_to_signed((reg_val & m_regs.at("cur_pos").mask),m_regs.at("cur_pos").mask);
//#ifdef DEBUG
//    LOG(Log::INF) << log_i("cib_get_position","Readout position ") << m_pos;
//#endif
    pos = m_pos;
    return OpcUa_Good;
  }
  UaStatus DIoLMotor::check_position_in_range(const int32_t pos, json &resp)
  {
    if ((pos < m_range_min) || (pos > m_range_max))
    {
      std::ostringstream msg("");
      resp["status"] = "ERROR";
      msg << log_e("check_range","Requested position") << " (" << pos << ") not in motor range [" << m_range_min << ", " << m_range_max << "]";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      return OpcUa_BadInvalidArgument;
    }
    else
    {
      return OpcUa_Good;
    }
  }
  void DIoLMotor::update_status(Status s)
  {
    m_status = s;
    UaString ss(m_status_map.at(m_status).c_str());
    getAddressSpaceLink()->setState(ss,OpcUa_Good);
  }
} // -- namespace


