
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.

    The stub of this file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.


 */


#include <Configuration.hxx> // TODO; should go away, is already in Base class for ages

#include <DIoLLaserUnit.h>
#include <ASIoLLaserUnit.h>
#include <utilities.hh>
#include <Laser.hh>
#include <string>
#include <sstream>
#include <thread>
#include <chrono>
#include <mem_utils.h>
#include <cstdint>
#include <cib_registers.h>

using json = nlohmann::json;
//
#define log_msg(s,met,msg) "[" << s << "]::" << met << " : " << msg
//
#define log_e(m,s) log_msg("ERROR",m,s)
#define log_w(m,s) log_msg("WARN",m,s)
#define log_i(m,s) log_msg("INFO",m,s)
//
using std::ostringstream;
using std::map;
using std::string;
//
namespace Device
{
  // 1111111111111111111111111111111111111111111111111111111111111111111111111
  // 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
  // 1     Users don't modify this code!!!!                                  1
  // 1     If you modify this code you may start a fire or a flood somewhere,1
  // 1     and some human being may possible cease to exist. You don't want  1
  // 1     to be charged with that!                                          1
  // 1111111111111111111111111111111111111111111111111111111111111111111111111






  // 2222222222222222222222222222222222222222222222222222222222222222222222222
  // 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
  // 2     (code for which only stubs were generated automatically)          2
  // 2     You should add the implementation but dont alter the headers      2
  // 2     (apart from constructor, in which you should complete initializati2
  // 2     on list)                                                          2
  // 2222222222222222222222222222222222222222222222222222222222222222222222222

  /* sample ctr */
  DIoLLaserUnit::DIoLLaserUnit (
      const Configuration::IoLLaserUnit& config,
      Parent_DIoLLaserUnit* parent
  ):
            Base_DIoLLaserUnit( config, parent)

            /* fill up constructor initialization list here */
            ,m_is_ready(false)
            ,m_status(sOffline)
            ,m_laser(nullptr)
            ,m_divider(0)
            //FIXME: What is the pump HV default?
            ,m_pump_hv(0.0)
            ,m_rate_hz(10.0)
            ,m_qswitch(200)
            ,m_laser_shutter_close(true)
            ,m_shot_count(0)
            ,m_comport("auto")
            ,m_baud_rate(9600)
            ,m_count_flashes(false)
            ,m_name("")
            ,m_idle_counter(0)
            ,m_idle_timeout(0)
            ,m_mmap_fd(0)
            ,m_mapped_mem(0)
            ,m_pause_timeout(10) // 10 min timeout by default
            ,m_standby_timeout(60) // 1h timeout for standby
            ,m_qswitch_delay(170) // 170 us by default
            ,m_qswitch_width(10) // 10 us
            ,m_fire_width(10)
            ,m_serial_number("")
            ,m_warmup_timer(30) // 30 min
            {
    /* fill up constructor body here */
    m_name = config.name();
    LOG(Log::INF) << "DIoLLaserUnit::DIoLLaserUnit : Building instance of  [" << m_name << "]";
    m_serial_number = serial_number();
    //    if (m_comport == "auto")
    //    {
    //      LOG(Log::WRN) << "DIoLLaserUnit::DIoLLaserUnit : Attempting automatic port detection based off serial number [" << serial_number() << "]";
    //      automatic_port_search();
    //    }
    LOG(Log::INF) << "DIoLLaserUnit::DIoLLaserUnit : Port set to [" << m_comport << "]";

    // -- initialize the status map
    m_status_map.insert({sOffline,"offline"});
    //m_status_map.insert({sInit,"init"});
    m_status_map.insert({sReady,"ready"});
    m_status_map.insert({sWarmup,"warmup"});
    m_status_map.insert({sLasing,"lasing"});
    m_status_map.insert({sPause,"pause"});
    m_status_map.insert({sStandby,"standby"});

    // try to initialize the system with the defaults
    m_config.word.init(0x0);
    // No. Either config or init should be called explicitely
    //    json resp;
    //    init(resp);

    // Should we apply already map the control bit of the external shutter?
    //uintptr_t addr = cib::util::map_phys_mem(0x100000,0x100);
            }

  /* sample dtr */
  DIoLLaserUnit::~DIoLLaserUnit ()
  {
  }

  /* delegates for cachevariables */

  /* Note: never directly call this function. */

  UaStatus DIoLLaserUnit::writeQswitch_us ( const OpcUa_UInt32& v)
  {
    LOG(Log::INF) << "Setting QSwitch";
    std::ostringstream msg;
    // we need the system to be at least in unconfigured state
    // as we need the device connection to be established
    if (m_status == sOffline)
    {
      return OpcUa_BadInvalidState;
    }
    if (!m_laser)
    {
      return OpcUa_BadInvalidState;
    }
    json resp;
    return write_qswitch(static_cast<uint16_t>(v & 0xFFFF), resp);
  }
  /* Note: never directly call this function. */

UaStatus DIoLLaserUnit::writeDischarge_voltage_kV ( const OpcUa_Double& v)
  {
    LOG(Log::INF) << "Setting discharge voltage to " << v;
    std::ostringstream msg;
    // we need the system to be at least in unconfigured state
    // as we need the device connection to be established
    if (m_status == sOffline)
    {
      return OpcUa_BadInvalidState;
    }
    if (!m_laser)
    {
      return OpcUa_BadInvalidState;
    }
    json resp;
    return write_hv(v,resp);

  }
  /* Note: never directly call this function. */

UaStatus DIoLLaserUnit::writeRep_rate_hz ( const OpcUa_Double& v)
  {
    LOG(Log::INF) << "Setting Repetition rate";
    std::ostringstream msg;
    // we need the system to be at least in unconfigured state
    // as we need the device connection to be established
    if (m_status == sOffline)
    {
      return OpcUa_BadInvalidState;
    }
    if (!m_laser)
    {
      return OpcUa_BadInvalidState;
    }
    json resp;
    return write_rate(v,resp);
  }
  /* Note: never directly call this function. */

  UaStatus DIoLLaserUnit::writeRep_rate_divider ( const OpcUa_UInt16& v)
  {
    LOG(Log::INF) << "Setting Rate Divider / Prescale to " << v;
    // we need the system to be at least in unconfigured state
    // as we need the device connection to be established
    if (m_status == sOffline)
    {
      return OpcUa_BadInvalidState;
    }
    if (!m_laser)
    {
      return OpcUa_BadInvalidState;
    }
    json resp;
    return write_divider(v,resp);
    // we don't really care for the responses in this case
    // just whether it went well or not
  }

  /* delegators for methods */
  UaStatus DIoLLaserUnit::callSet_connection (
      const UaString&  device_port,
      OpcUa_UInt16 baud_rate,
      UaString& response
  )
  {
    std::ostringstream msg("");
    json resp;
    std::string port = device_port.toUtf8();
    UaStatus st = set_conn(port,baud_rate,resp);

    if (st != OpcUa_Good)
    {
      msg << log_e("set_connection","Failed to set connection. Check previous messages.");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      if (!resp.contains("status_code"))
      {
        resp["status_code"] = OpcUa_Bad;
      }
    }
    else
    {
      if (!resp.contains("status"))
      {
        resp["status"] = "OK";
      }
      resp["messages"].push_back(std::string("Connection parameters set"));
      if (!resp.contains("status_code"))
      {
        resp["status_code"] = OpcUa_Good;
      }
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::callConfig (
    const UaString&  conf,
      UaString& response
  )
  {
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    json cfrag;
    UaStatus st = OpcUa_Good;
    try
    {
      cfrag = json::parse(conf.toUtf8());
      st = config(cfrag,resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
      response = UaString(resp.dump().c_str());
      return OpcUa_Good;
    }
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Configuration failed.");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      if (!resp.contains("status_code"))
      {
        resp["status_code"] = OpcUa_Bad;
      }
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i("config","Configuration successful.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::callInit (
      UaString& response
  )
  {
    return OpcUa_BadNotImplemented;
  }
  UaStatus DIoLLaserUnit::callStop (
      UaString& response
  )
  {
    std::ostringstream msg("");
    json resp;
    UaStatus st = stop(resp);
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Failed to stop. See previous messages");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Stopped successfully.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::callCheck_status (
      OpcUa_UInt16& status,
      UaString& description
  )
  {
    std::ostringstream msg("");
    bool got_exception = false;
    // force a stop on the laser firing
    // start by closing hte shutter, and
    // since this is a usually kind of critical method, do not even care to check whether the
    // laser is firing or not, just stop and close the shutter
    if (!m_laser)
    {
      status = 99;
      msg << log_e("status","There is no connection to the laser.");
      description = UaString(msg.str().c_str());
      getAddressSpaceLink()->setStatus_code(status,OpcUa_BadInvalidState);

      return OpcUa_Good;
    }
    //
    try
    {
      std::string desc;

      m_laser->security(status, desc);
      description = UaString(desc.c_str());
      getAddressSpaceLink()->setStatus_code(status,OpcUa_Good);
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("status"," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("status","Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("status","Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("status","Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      status = 98;
      LOG(Log::ERR) << msg.str();
      description = UaString(msg.str().c_str());
      getAddressSpaceLink()->setStatus_code(status,OpcUa_BadCommunicationError);
      return OpcUa_Good;
    }
    //
    return OpcUa_Good;
    //
  }
  UaStatus DIoLLaserUnit::callSingle_shot (
      UaString& response
  )
  {
    json resp;
    (void) single_shot(resp);
    response = UaString(resp.dump().c_str());

    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::callFire_standalone (
      OpcUa_Boolean fire,
      OpcUa_UInt32 num_shots,
      UaString& response
  )
  {
    // this calls the fire command without input from the CIB
    // it is meant to be used without CIB access
    // for now do not implement it
    return OpcUa_BadNotImplemented;
  }
  UaStatus DIoLLaserUnit::callSwitch_laser_shutter (
      OpcUa_Boolean close,
      UaString& response
  )
  {
    std::ostringstream msg("");
    json resp;
    UaStatus st = switch_laser_shutter(close,resp);
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Failed to stop. See previous messages");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Stopped successfully.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::callForce_ext_shutter (
      OpcUa_Boolean close,
      UaString& response
  )
  {
    std::ostringstream msg("");
    json resp;
    UaStatus st = force_ext_shutter(close,resp);
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Failed to stop. See previous messages");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Stopped successfully.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::callTerminate (
      UaString& response
  )
  {
    return OpcUa_BadNotImplemented;
  }

  // 3333333333333333333333333333333333333333333333333333333333333333333333333
  // 3     FULLY CUSTOM CODE STARTS HERE                                     3
  // 3     Below you put bodies for custom methods defined for this class.   3
  // 3     You can do whatever you want, but please be decent.               3
  // 3333333333333333333333333333333333333333333333333333333333333333333333333

  UaStatus DIoLLaserUnit::set_conn(const std::string port, uint16_t baud, json &resp)
  {
    std::ostringstream msg("");
    if (m_status != sOffline)
    {
      msg.clear(); msg.str("");
      msg << log_e("set_conn","Laser is online. You must first shut it down.");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidState;
      return OpcUa_Bad;
    }
    // do a second cross-check. At this stage there should not be any instantiated object
    // we shouldn't actually ever reach this state
    if (m_laser)
    {
      msg.clear(); msg.str("");
      msg << log_w("set_conn","Laser instance found. This is unexpected and therefore a termination will be forced first.");
      resp["status"] = "WARNING";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
      (void)terminate(resp);
    }
    // at this stage we are good to set the connection parameters
    // otherwise, it is fair game
    if (port == std::string("auto"))
    {
      automatic_port_search();
      msg.clear(); msg.str("");
      msg << log_i("set_conn","Automatic search found port [") << m_comport << "]";
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
    }
    else
    {
      m_comport = port;
    }
    if (m_comport.size() == 0)
    {
      // the port is invalid. Something failed.
      msg.clear(); msg.str("");
      msg << log_e("set_conn","Port is invalid [") << m_comport << "]";
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidArgument;
      return OpcUa_BadInvalidArgument;
    }
    UaString ss(m_comport.c_str());
    getAddressSpaceLink()->setPort(ss,OpcUa_Good);
    //
    // -- Now the baud rate
    //
    if (baud == 0)
    {
      // just leave what it is presently set
      msg.clear(); msg.str("");
      msg << log_i("set_conn","Baud rate kept to current value[") << m_baud_rate << "]";
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
    }
    else
    {
      m_baud_rate = baud;
    }
    update_status(sOffline);
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::switch_laser_shutter(const bool close, json &resp)
  {
    std::ostringstream msg("");
    bool got_exception = false;
    if (m_status == sOffline)
    {
      msg.clear(); msg.str("");
      msg << log_e("shutter","Laser is offline. No operation possible.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidState;
      return OpcUa_Bad;
    }
    if (!m_laser)
    {
      msg.clear(); msg.str("");
      msg << log_e("shutter","There is no connection to the laser. Doing nothing.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidState;
      return OpcUa_Bad;
    }
    try
    {
      if (close)
      {
        // -- if we close the shutter, we should disable qswitch
        cib::util::reg_write_mask_offset(m_regs.at("qs_enable").addr,
                                         0x0,
                                         m_regs.at("qs_enable").mask,
                                         m_regs.at("qs_enable").bit_low);
        m_laser->shutter_close();
        m_laser_shutter_closed = true;
        getAddressSpaceLink()->setLaser_shutter_open(false,OpcUa_Good);
        update_status(sStandby);
        start_standby_timer();
        msg.clear(); msg.str("");
        msg << log_i("shutter","Laser shutter closed.");
      }
      else
      {
        // -- if we open the shutter, we should activate qswitch
        // but it could make sense to switch to pause state
        // shouldn't we first switch to pause?
        pause(resp);
        m_laser->shutter_open();
        cib::util::reg_write_mask_offset(m_regs.at("qs_enable").addr,
                                         0x1,
                                         m_regs.at("qs_enable").mask,
                                         m_regs.at("qs_enable").bit_low);
        getAddressSpaceLink()->setLaser_shutter_open(true,OpcUa_Good);
        msg.clear(); msg.str("");
        msg << log_i("stop","Laser shutter open.");
      }
      // requery the laser system for its present status, in case there are issues to report
      refresh_status();
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop"," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::force_ext_shutter(const bool close, json &resp)
  {
    uint32_t state = (close)?(0x1<<m_regs.at("force_shutter").bit_low):0x0;
    uint32_t c_state = (cib::util::reg_read(m_regs.at("force_shutter").addr) & m_regs.at("force_shutter").mask);
    // the code below looks cool but if makes some things difficult. It does work, though
    if (close && (!m_ext_shutter_closed))
    {
      // we want to close and it wasn't yet
      // states are not the same
      cib::util::reg_write_mask_offset(m_regs.at("force_shutter").addr,
                                       0x1,
                                       m_regs.at("force_shutter").mask,
                                       m_regs.at("force_shutter").bit_low);
      m_ext_shutter_closed = true;
      getAddressSpaceLink()->setExt_shutter_open(!m_ext_shutter_closed,OpcUa_Good);
      // start the timer
      update_status(sPause);
      start_pause_timer();
    }
    else
    {
      // was closed and want to open
      if (!close && m_ext_shutter_closed)
      {
        // we want to close and it wasn't yet
        // states are not the same
        cib::util::reg_write_mask_offset(m_regs.at("force_shutter").addr,
                                         0x0,
                                         m_regs.at("force_shutter").mask,
                                         m_regs.at("force_shutter").bit_low);
        m_ext_shutter_closed = false;
        getAddressSpaceLink()->setExt_shutter_open(!m_ext_shutter_closed,OpcUa_Good);
        // -- stop the timer, if it is going
        // actually, the timer should cancel itself once it realises the shutter is open
      }
    }
//
//    // if both are the same, do nothing
//    // otherwise change state
//    if (state ^ c_state)
//    {
//      // states are not the same
//      cib::util::reg_write_mask_offset(m_regs.at("force_shutter").addr,
//                                       state,
//                                       m_regs.at("force_shutter").mask,
//                                       m_regs.at("force_shutter").bit_low);
//      getAddressSpaceLink()->setExt_shutter_open(!state,OpcUa_Good);
//    }
    return OpcUa_Good;
  }
  void DIoLLaserUnit::start_standby_timer()
  {
    // initate a timer that will check for the status of the internal shutter every second
    // until it reaches the total timeout.
    // if it reaches the total timeout, it shuts the laser down (for safeguarding)
    std::thread([this]()
                {
      uint32_t nsecs = 0;
      while (nsecs < (m_standby_timeout*60))
      {
        if (!m_laser_shutter_closed)
        {
          // stop the timer
          return;
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
        nsecs++;
      }
      // reached the end of the loop and shutter is still closed
      // stop the system
      LOG(Log::WRN) << "Reached the end of the timer. Stopping the laser.";
      json r;
      stop(r);
                }
    ).detach();
  }
  void DIoLLaserUnit::start_pause_timer()
  {

    // initate a timer that will check for the status of the external shutter every second
    // until it reaches the total timeout.
    // if it reaches the total timeout, it switches to standby
    // and then automatically switch to paused state
    std::thread([this]()
                {
      uint32_t nsecs = 0;
      while (nsecs < (m_pause_timeout*60))
      {
        if (!m_ext_shutter_closed)
        {
          // stop the timer
          return;
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
        nsecs++;
      }
      // reached the end of the loop and shutter is still closed
      // switch to standby and open this
      LOG(Log::WRN) << "Reached the end of the timer. Switching to standby.";
      json r;
      standby(r);

                }
    ).detach();
  }


  UaStatus DIoLLaserUnit::terminate(json &resp)
  {
    // FIXME: Review this to sync with CIB
    UaStatus st = OpcUa_Good;
    std::ostringstream msg("");
    // this is meant to do a smooth temrination of the device
    if (m_status == sOffline)
    {
      // there should not be a valid pointer
      if (m_laser)
      {
        msg.clear(); msg.str("");
        msg << log_w("terminate","There is live pointer but state is offline. This should not happen. Attempting to clear object.");
        resp["messages"].push_back(msg.str());
        delete m_laser;
        m_laser = nullptr;
        return OpcUa_Uncertain;
      }
    }
    if (m_status == sLasing)
    {
      st = stop(resp);
    }
    // -- now just delete the
    delete m_laser;
    m_laser = nullptr;
    update_status(sOffline);
    return OpcUa_Good;
  }

  UaStatus DIoLLaserUnit::stop(json &resp)
  {
    // FIXME: Review this
    // force a stop on the laser firing
    // start by closing hte shutter, and
    // since this is a usually kind of critical method, do not even care to check whether the
    // laser is firing or not, just stop and close the shutter
    std::ostringstream msg("");
    bool got_exception = false;
    if (!m_laser)
    {
      msg.clear(); msg.str("");
      msg << log_w("stop","There is no connection to the laser. Doing nothing.");
      LOG(Log::WRN) << msg.str();
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
      return OpcUa_Good;
    }
    try
    {
      m_laser->fire_stop();
      m_laser->shutter_close();
      // downgrade anything above ready to ready to operate
      // states below remain as they are
      if (m_status == sLasing)
      {
        update_status(sReady);
      }
      // requery the laser system for its present status, in case there are issues to report
      refresh_status();
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop"," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    resp["status"] = "OK";
    msg.clear(); msg.str("");
    msg << log_i("stop","Laser stopped.");
    resp["messages"].push_back(msg.str());
    resp["status_code"] = OpcUa_Good;
    return OpcUa_Good;
  }

  UaStatus DIoLLaserUnit::start_cib(json &resp)
  {
    // Tell the cib to start.This can only be called when the system is in sReady state
    // this will switch the laser into sWarmup state.
    // sWarmup is pretty much the same as a standby.
    // qswitch is off, the internal shutter closed, external shutter open
    std::ostringstream msg("");
    bool got_exception = false;
    if (!m_laser)
    {
      msg.clear(); msg.str("");
      msg << log_w("start_cib","There is no connection to the laser. Doing nothing.");
      LOG(Log::WRN) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
    }
    if (m_status != sReady)
    {
      msg.clear(); msg.str("");
      msg << log_w("start_cib","System is not in the sReady state, as it should.");
      LOG(Log::WRN) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
    }
    try
    {
      // deassert qswitch enable
      cib::util::reg_write_mask_offset(m_regs.at("qs_enable").addr,
                                       0x0,
                                       m_regs.at("qs_enable").mask,
                                       m_regs.at("qs_enable").offset);
      // close the shutter
      m_laser->shutter_close();
      // start the laser firing
      cib::util::reg_write_mask_offset(m_regs.at("start").addr,
                                       0x1,
                                       m_regs.at("start").mask,
                                       m_regs.at("start").offset);
      // downgrade anything above ready to ready to operate
      update_status(sWarmup);
      // initiate the warmup timer.
      // !!! Nothing is supposed to happen during warmup
      start_warmup_timer();
      // requery the laser system for its present status, in case there are issues to report
      refresh_status();
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("start_cib"," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("start_cib","Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("start_cib","Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("start_cib","Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    resp["status"] = "OK";
    msg.clear(); msg.str("");
    msg << log_i("start_cib","Laser started.");
    resp["messages"].push_back(msg.str());
    resp["status_code"] = OpcUa_Good;
    return OpcUa_Good;
  }
  void DIoLLaserUnit::start_warmup_timer()
  {
    // this only matters if we are in warmup state
    if (m_status != sWarmup)
    {
      LOG(Log::WRN) << "Trying to start a warmup timer without being in warmup state. Doing nothing.";
      return;
    }
    // initate a timer that will just sleep until the timer is over
    // and then automatically switch to paused state
    std::thread([this]()
                {
      std::this_thread::sleep_for(std::chrono::minutes(m_warmup_timer));
      // once the sleep is done do the following:
      // close external shutter
      // open internal shutter
      // enable qswitch
      //
      // actually, check that we are still in warmup state before doing anything
      // this safeguards if someone hits stop or terminate while warming up
      //
      if (m_status != sWarmup)
      {
        // state charged for some reason. Do nothing.
        // only stop and terminate can actually interfere with warmup
        LOG(Log::WRN) << "Warmup timer reached end but state no longer in warmup. Doing nothing.";
        return;
      }
      //
      // 1. close external shutter
      json r;
      force_ext_shutter(true,r);
      // 2. open internal shutter
      switch_laser_shutter(false,r);
      // 3. enable qswitch
      cib::util::reg_write_mask_offset(m_regs.at("qs_enable").addr, 0x1,m_regs.at("qs_enable").mask,m_regs.at("qs_enable").bit_low);
      // call pause to make sure that all this is done
      // also keep in mind that pause has an associated timer, after which switches to standby
      pause(r);
                }
    ).detach();
  }
  UaStatus DIoLLaserUnit::pause(json &resp)
  {
    // this is a state that closes the external shutter while keeping everything else working
    // can only be called from sWarmup or sLasing
    std::ostringstream msg("");
    bool got_exception = false;
    if (!m_laser)
    {
      msg.clear(); msg.str("");
      msg << log_w("pause","There is no connection to the laser. Doing nothing.");
      LOG(Log::WRN) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
    }
    // pause can be called from either sWarmup or sLasing
    // one could potentially call it from sReady, but that would be kind of silly
    // we can simply force the shutter closed in that case
    if ((m_status != sWarmup) && (m_status != sLasing) && (m_status != sStandby))
    {
      msg.clear(); msg.str("");
      msg << log_w("pause","System is not operating. Pause does not make sense.");
      LOG(Log::WRN) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
    }
    try
    {
      // if it is in one of the previous stages redo the whole procedure
      // make sure qswitch enable is asserted
      // if it was already, it won't change anything and it only costs a handful of microseconds
      force_ext_shutter(true,resp);
      // this in itself will also trigger a timer
      // that will be checked every second for the state of the shutter

      cib::util::reg_write_mask_offset(m_regs.at("qs_enable").addr,
                                       0x1,
                                       m_regs.at("qs_enable").mask,
                                       m_regs.at("qs_enable").offset);
      // downgrade anything above ready to ready to operate
      update_status(sPause);
      // requery the laser system for its present status, in case there are issues to report
      refresh_status();
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("pause"," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("pause","Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("pause","Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("pause","Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    resp["status"] = "OK";
    msg.clear(); msg.str("");
    msg << log_i("pause","Laser operation paused.");
    resp["messages"].push_back(msg.str());
    resp["status_code"] = OpcUa_Good;
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::standby(json &resp)
  {
    // this is a state that opens the external shutter,
    // closes the internal shutter and disables qswitch
    // can be called from sLasing and sPause
    std::ostringstream msg("");
    bool got_exception = false;
    if (!m_laser)
    {
      msg.clear(); msg.str("");
      msg << log_w("standby","There is no connection to the laser. Doing nothing.");
      LOG(Log::WRN) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
    }
    // pause can be called from either sWarmup or sLasing
    // one could potentially call it from sReady and/or sStandby, but that would be kind of silly
    // we can simply force the shutter closed in that case
    if ((m_status != sPause) && (m_status != sLasing))
    {
      msg.clear(); msg.str("");
      msg << log_w("standby","System is not operating. Standby does not make sense.");
      LOG(Log::WRN) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
    }
    try
    {
      // if it is in one of the previous stages redo the whole procedure
      // make sure qswitch enable is deasserted
      cib::util::reg_write_mask_offset(m_regs.at("qs_enable").addr,
                                       0x0,
                                       m_regs.at("qs_enable").mask,
                                       m_regs.at("qs_enable").offset);
      // close internal shutter
      switch_laser_shutter(true,resp);
      // this in itself will also trigger a timer
      // that will be checked every second for the state of the shutter
      force_ext_shutter(false,resp);
      // downgrade anything above ready to ready to operate
      update_status(sStandby);
      // requery the laser system for its present status, in case there are issues to report
      refresh_status();
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("standby"," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("standby","Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("standby","Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("standby","Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    resp["status"] = "OK";
    msg.clear(); msg.str("");
    msg << log_i("standby","Laser operation on standby.");
    resp["messages"].push_back(msg.str());
    resp["status_code"] = OpcUa_Good;
    return OpcUa_Good;
  }

  void DIoLLaserUnit::automatic_port_search()
  {
    try
    {
      // the automatic port search queries all available ports, their descriptions and IDs for an occurrence of the device
      // serial number
      // this has been shown to work for most cases, but there is always a chance that something fails
      // for example, the wrong serial number was provided
      m_comport = util::find_port(m_serial_number);
      if (m_comport.size() == 0)
      {
        LOG(Log::ERR) << "DIoLLaserUnit::automatic_port_search : Couldn't find device port";
      }
      m_status = sOffline;
    }
    catch(...)
    {
      m_status = sOffline;
      LOG(Log::ERR) << "DIoLLaserUnit::automatic_port_search : Caught an exception searching for the port";
      m_comport = "";
    }
  }
  void DIoLLaserUnit::refresh_status()
  {
    json resp;
    refresh_status(resp);
  }
  void DIoLLaserUnit::refresh_status(json &resp)
  {
    std::ostringstream msg("");
    uint16_t status = 99;
    std::string desc;
    bool got_exception = false;
    if (!m_laser)
    {
      msg.clear(); msg.str("");
      msg << log_e("status","There is no connection to the laser. Doing nothing.");
      LOG(Log::ERR) << msg.str();
      resp["messages"].push_back(msg.str());
      resp["status"] = "ERROR";
      resp["status_code"] = OpcUa_BadInvalidState;
      return;
    }
    try
    {
      m_laser->security(status, desc);
      getAddressSpaceLink()->setStatus_code(status,OpcUa_Good);
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("status"," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("status","Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("status","Failed with an STL exception :") << e.what();
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("status","Failed with an unknown exception.");
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    if (got_exception)
    {
      getAddressSpaceLink()->setStatus_code(status,OpcUa_BadDataUnavailable);
    }
  }
  void DIoLLaserUnit::timer_start(DIoLLaserUnit *obj)
  {
    if (m_count_flashes)
    {
      LOG(Log::WRN) << "Trying to set a timer that has already been set up. Skipping.";
      return;
    }
    m_count_flashes = true;
    std::thread([obj]()
                {
      while (obj->get_counting_flashes())
      {
        // We know that the laser will be firing at 10 Hz, that means 100 ms
        auto x = std::chrono::steady_clock::now() + std::chrono::milliseconds(50);
        if (obj->refresh_shot_count() != OpcUa_Good)
        {
          LOG(Log::ERR) << "Failed to query device for status. Setting read values to InvalidData";
        }
        std::this_thread::sleep_until(x);
      }
                }).detach();
  }
  UaStatus DIoLLaserUnit::refresh_shot_count()
  {
    std::ostringstream msg("");
    bool caught_exception = false;
    if (m_status == sOffline)
    {
      msg.clear(); msg.str("");
      msg << log_w("count","Trying to refresh shot count without a serial connection.");
      LOG(Log::WRN) << msg.str();
      return OpcUa_BadInvalidState;
    }
    // this should never happen
    if (!m_laser)
    {
      msg.clear(); msg.str("");
      msg << log_w("count","Trying to refresh shot count without a serial connection.");
      LOG(Log::WRN) << msg.str();
      return OpcUa_BadInvalidState;
    }
    static uint32_t count = 0;
    // everything seems ready. Get counter
    try
    {
      m_laser->get_shot_count(count);
      // set the local cache
      m_shot_count = count;
      // FIXME: This should perhaps be in the update()
      getAddressSpaceLink()->setFlash_count(m_shot_count, OpcUa_Good);
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("single_shot"," ") << "Port not open [" << e.what() << "]";
      caught_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("single_shot","Failed with a Serial exception :") << e.what();
      caught_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("single_shot","Failed with an STL exception :") << e.what();
      caught_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("single_shot","Failed with an unknown exception.");
      caught_exception = true;
    }
    if (caught_exception)
    {
      LOG(Log::ERR) << msg.str();
      getAddressSpaceLink()->setFlash_count(m_shot_count, OpcUa_BadDataUnavailable);
    }
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::init(json &resp)
  {
    // if the system is already initialized do nothing and give back a warning
    bool got_exception = false;
    ostringstream msg("");
    UaStatus ret = OpcUa_Good;
    if (m_status != sOffline)
    {
      msg.clear(); msg.str("");
      msg << log_w("init","System already initialized.Skipping.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
      return OpcUa_Good;
    }
    if (m_comport.size() == 0)
    {
      msg.clear(); msg.str("");
      msg << log_e("init","Unkonwn port.");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return OpcUa_BadInvalidArgument;
    }
    if (m_comport == std::string("auto"))
    {
      msg.clear(); msg.str("");
      msg << log_w("init","Port set to auto. Probing ports.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
      automatic_port_search();
    }
    // -- at this stage either things went well, or have returned already
    try
    {
      if (m_laser)
      {
        msg.clear(); msg.str("");
        msg << log_w("init","System already initialized. Just reconfiguring.");
        resp["messages"].push_back(msg.str());
        bool clean_and_rebuild = false;
        if (m_laser->get_port() != m_comport)
        {
          clean_and_rebuild = true;
        }
        if (m_laser->get_baud() != m_baud_rate)
        {
          clean_and_rebuild = true;
        }
        if (clean_and_rebuild)
        {
          // that means that we should terminate and recreate
          delete m_laser;
          m_laser = nullptr;
          m_laser = new device::Laser(m_comport.c_str(),m_baud_rate);
        }
      }
      else
      {
        m_laser = new device::Laser(m_comport.c_str(),m_baud_rate);
      }
      // -- now that we have the system, let's update the settings in
      // the local cache
      update_status(sReady);

      // since we are at the init stage, we can call directly the device methods
      // call the internal methods, as these also check valid ranges
      // try to write all. If one fails, pass the error,
      // but give the opportunity for all settings to be written
      ret = write_hv(m_pump_hv,resp);
      ret = ret | write_divider(m_divider,resp);
      // for external driving these two don't really matter
      ret = ret | write_rate(m_rate_hz,resp);
      ret = ret | write_qswitch(m_qswitch,resp);
      if (ret != OpcUa_Good)
      {
        // something failed. Whatever it was, should already be in the
        // response string
        msg.clear(); msg.str("");
        msg << log_w("init","Some parameters failed to be set. Check previous messages.");
        return OpcUa_Bad;
      }
      else {
        msg.clear(); msg.str("");
        msg << log_i("init","System configured sucessfully.");
        if (m_config.is_ready())
        {
          update_status(sReady);
        }
      }
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("init"," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("init","Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("init","Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("init","Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
      return OpcUa_Bad;
    } else
    {
      msg.clear(); msg.str("");
      msg << log_i("init","System initialized.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
      return OpcUa_Good;
    }
  }
  UaStatus DIoLLaserUnit::write_divider(const uint16_t v,json &resp)
  {
    // NOTE: This method does not check whether the system is ready to execute
    // that is the job of the original method
    uint16_t nv = v;
    static ostringstream msg("");
    bool got_exception = false;
    if (m_status != sReady)
    {
      msg.clear(); msg.str("");
      msg << log_e("prescale"," ") << "Laser is not in ready state. Crrent state :" << m_status_map.at(m_status);
      resp["messages"].push_back(msg.str());
      LOG(Log::ERR) << msg.str();
      return OpcUa_BadInvalidState;
    }
    if ( v > 99)
    {
      nv = 99;
      msg.clear(); msg.str("");
      msg << log_w("prescale"," ") << "Value out of bounds. Truncating to max [ " << v << " --> " << nv << "]";
      resp["messages"].push_back(msg.str());
      LOG(Log::WRN) << msg.str();
    }
    try
    {
      m_laser->set_prescale(nv);
      m_divider = nv;
      // update the address space as well
      getAddressSpaceLink()->setRep_rate_divider(m_divider, OpcUa_Good);
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("prescale"," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("prescale","Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("prescale","Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("prescale","Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    resp["status"] = "OK";
    resp["statuscode"] = OpcUa_Good;
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::write_rate(const double v,json &resp)
  {
    // NOTE: This method does not check whether the system is ready to execute
    // that is the job of the original method
    // check range
    static ostringstream msg("");
    bool got_exception = false;
    if (m_status != sReady)
    {
      msg.clear(); msg.str("");
      msg << log_e("prescale"," ") << "Laser is not in ready state. Current state :" << m_status_map.at(m_status);
      resp["messages"].push_back(msg.str());
      LOG(Log::ERR) << msg.str();
      return OpcUa_BadInvalidState;
    }
    // check range
    if (v <= 0.0 || v > 20.0)
    {
      msg.clear(); msg.str("");
      msg << log_e("rate","Value out of bounds: ") << v << "<> [0.0,20.0]";
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadOutOfRange;
      return OpcUa_BadOutOfRange; // This shouldn't even be changed
    }
    try
    {
      m_laser->set_repetition_rate(v);
      m_rate_hz = v;
      getAddressSpaceLink()->setRep_rate_hz(m_rate_hz, OpcUa_Good);
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("rate"," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("rate","Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("rate","Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("rate","Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::write_hv(const double v,json &resp)
  {
    // NOTE: This method does not check whether the system is ready to execute
    // that is the job of the original method
    // check range
    static ostringstream msg("");
    bool got_exception = false;
    if (m_status != sReady)
    {
      msg.clear(); msg.str("");
      msg << log_e("prescale"," ") << "Laser is not in ready state. Current state :" << m_status_map.at(m_status);
      resp["messages"].push_back(msg.str());
      LOG(Log::ERR) << msg.str();
      return OpcUa_BadInvalidState;
    }
    // check range
    if ((v < 0) || (v > 1.3))
    {
      msg.clear(); msg.str("");
      msg << log_e("rate","Value out of bounds: ") << v << "<> [0.0,20.0]";
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadOutOfRange;
      return OpcUa_BadOutOfRange; // avoid overflow
    }
    try
    {
      m_laser->set_pump_voltage(v);
      m_pump_hv = v;
      getAddressSpaceLink()->setDischarge_voltage_kV(m_pump_hv, OpcUa_Good);
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("voltage"," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("voltage","Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("voltage","Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("voltage","Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::write_qswitch(const uint16_t v,json &resp)
  {
    // NOTE: This method does not check whether the system is ready to execute
    // that is the job of the original method
    // check range
    uint16_t nv = v;
    static ostringstream msg("");
    bool got_exception = false;
    if (m_status != sReady)
    {
      msg.clear(); msg.str("");
      msg << log_e("prescale"," ") << "Laser is not in ready state. Current state :" << m_status_map.at(m_status);
      resp["messages"].push_back(msg.str());
      LOG(Log::ERR) << msg.str();
      return OpcUa_BadInvalidState;
    }
    if ( v > 999)
    {
      nv = 999;
      msg.clear(); msg.str("");
      msg << log_w("qswitch"," ") << "Value out of bounds. Truncating to max [ " << v << " --> " << nv << "]";
      resp["messages"].push_back(msg.str());
      LOG(Log::WRN) << msg.str();
    }
    try
    {
      m_laser->set_qswitch(nv);
      m_qswitch = nv;
      // update the address space as well
      getAddressSpaceLink()->setQswitch_us(m_qswitch, OpcUa_Good);
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("qswitch"," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("qswitch","Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("qswitch","Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("qswitch","Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    return OpcUa_Good;
  }


  void DIoLLaserUnit::update()
  {
    // do just periodic checks, that are meant to happen less often than usual
    // for example, check the laser unit status
    if (m_laser)
    {
      json resp;
      refresh_status(resp);
    }
  }
  UaStatus DIoLLaserUnit::fire_standalone(uint32_t num_pulses,json &resp)
  {
    return OpcUa_BadNotImplemented;
  }

  UaStatus DIoLLaserUnit::single_shot(json & answer)
  {
    std::ostringstream msg("");
    json resp;
    bool caught_exception = false;
    if (!m_laser)
    {
      msg.clear(); msg.str("");
      msg << log_e("single_shot","There is no connection to the laser. Doing nothing.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidState;
      return OpcUa_Good;
    }
    // if the laser is not in the sReady state, also do nothing
    // likely some parameter is not set yet
    // also fail if the laser is firing
    if (m_status != sReady)
    {
      msg.clear(); msg.str("");
      msg << log_e("single_shot","The laser is in the wrong state") << " (expected " << static_cast<uint16_t>(sReady) << " have " << static_cast<uint16_t>(m_status) << ")";
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidState;
      return OpcUa_Good;
    }

    // if the shutter is not open, there is no point in firing
    //
    if (!m_laser_shutter_close)
    {
      msg.clear(); msg.str("");
      msg << log_e("single_shot","The laser shutter is not open");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidState;
      return OpcUa_Good;
    }
    // everything seems ready. Fire away
    try
    {
      // FIXME: This logic is not doing anything about the external shutter
      // once the external shutter is in place, one should actually stop using this command and instead
      // drive a single shot from the CIB (so that the external shutter is also timely opened)
      m_status = sLasing;
      // FIXME: If the operational status is propagated to the address space, we need to update it here
      m_laser->single_shot(); // ensure that the prescale is rescaled
      m_status = sReady;
      // FIXME: The operation status should perhaps be reported back to SC
      //getAddressSpaceLink()->setStatus_code(status,OpcUa_Good);
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("single_shot"," ") << "Port not open [" << e.what() << "]";
      caught_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("single_shot","Failed with a Serial exception :") << e.what();
      caught_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("single_shot","Failed with an STL exception :") << e.what();
      caught_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("single_shot","Failed with an unknown exception.");
      caught_exception = true;
    }
    if (caught_exception)
    {
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
    }
    else {
      // all was good
      msg.clear(); msg.str("");
      msg << log_i("single_shot","Laser single shot fired");
      LOG(Log::INF) << msg.str();
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }
  bool DIoLLaserUnit::validate_config_fragment(json &conf, json &resp)
  {
    // this is just a validation check for the available keys.
    // it will only check the mandatory keys.
    std::vector<std::string> keys = {"name","port","serial_number","baud_rate",
        "repetition_rate_divider", "discharge_voltage", "repetition_rate", "qswitch",
        "pause_timeout_min","standby_timeout_min","qswitch_delay_us","qswitch_width_us",
        "fire_width_us","mmap"
    };
    // actually, check for all entries and report all missing ones
    std::vector<std::string> missing;
    for (auto entry: keys)
    {
      if (!conf.contains(entry))
      {
        missing.push_back(entry);
      }
    }
    if (missing.size() > 0)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_e("config","Missing entries in Laser Unit config fragment [");
      for (auto e : missing)
      {
        msg << "(" <<  e << "),";
      }
      msg << "]";
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidArgument;
      return false;
    }
    // all good, return true
    return true;
  }

  UaStatus DIoLLaserUnit::config(json & config, json &resp)
  {
    std::ostringstream msg("");
    bool got_exception = false;
    UaStatus st;
    try
    {
      json conf = config;
      // the very first thing is to check that the laser is offline
      // if it isn't fail immediately
      if (m_status != sOffline)
      {
        msg.clear(); msg.str("");
        msg << log_e("config","Unit is not offline. Before configuring, you should shut it down.");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["status_code"] = OpcUa_BadInvalidState;
        return OpcUa_BadInvalidState;
      }
      // then check the configuration is aimed to the proper device
      if (conf.at("name").get<std::string>() != m_name)
      {
        msg.clear(); msg.str("");
        msg << log_e("config","Mismatch between name in object and configuration fragment :")
                  << " (" << conf.at("name").get<std::string>() <<" <> " << m_name << ")";
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["status_code"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      // validate that all settings are here
      if (!validate_config_fragment(conf,resp))
      {
        return OpcUa_BadInvalidArgument;
      }
      // if it is a valid configuration fragment start processing it.
      // first grab the serial number, as it is necessary in case the port is set to
      // "auto"
      m_serial_number = conf.at("serial_number").get<std::string>();

      // first grab the connection settings, since we want the connection
      // to be established before processing the other settings
      std::string port = conf.at("port").get<std::string>();
      uint16_t baud = conf.at("baud_rate").get<uint16_t>();
      st = set_conn(port,baud,resp);
      if ( st != OpcUa_Good)
      {
        // just fail
        return st;
      }
      // all good so far, so lets initiate the connection by creating an instance of the laser system
      m_laser = new device::Laser(m_comport.c_str(),static_cast<uint32_t>(m_baud_rate));
      update_status(sReady);
      // if the ids match, lets set the parameters
      // special iterator member functions for objects
      for (json::iterator it = conf.begin(); it != conf.end(); ++it)
      {
        LOG(Log::INF) << "Processing " << it.key() << " : " << it.value() << "\n";
        if (it.key() == "repetition_rate")
        {
          st = write_rate(it.value(),resp);
          if (st != OpcUa_Good)
          {
            getAddressSpaceLink()->setRep_rate_hz(m_rate_hz, st);
            return st;
          }
        }
        if (it.key() == "repetition_rate_divider")
        {
          st = write_divider(it.value(),resp);
          if (st != OpcUa_Good)
          {
            getAddressSpaceLink()->setRep_rate_divider(m_divider,st);
            return st;
          }
        }
        if (it.key() == "qswitch")
        {
          st = write_qswitch(it.value(),resp);
          if (st != OpcUa_Good)
          {
            getAddressSpaceLink()->setQswitch_us(m_qswitch, st);
            return st;
          }
        }
        if (it.key() == "discharge_voltage")
        {
          st = write_hv(it.value(), resp);
          if (st != OpcUa_Good)
          {
            getAddressSpaceLink()->setDischarge_voltage_kV(m_pump_hv, st);
            return st;
          }
        }
        if (it.key() == "pause_timeout_min")
        {
          st = set_pause_timeout(it.value(), resp);
          if (st != OpcUa_Good)
          {
            getAddressSpaceLink()->setPause_timeout(m_pause_timeout, st);
            return st;
          }
        }
        if (it.key() == "standby_timeout_min")
        {
          st = set_standby_timeout(it.value(), resp);
          if (st != OpcUa_Good)
          {
            getAddressSpaceLink()->setStandby_timeout(m_standby_timeout, st);
            return st;
          }
        }
        if (it.key() == "qswitch_delay_us")
        {
          st = set_qswitch_delay(it.value(), resp);
          if (st != OpcUa_Good)
          {
            getAddressSpaceLink()->setQswitch_delay_us(m_qswitch_delay, st);
            return st;
          }
        }
        if (it.key() == "qswitch_width_us")
        {
          st = set_qswitch_width(it.value(), resp);
          if (st != OpcUa_Good)
          {
            getAddressSpaceLink()->setQswitch_width_us(m_qswitch_width, st);
            return st;
          }
        }
        if (it.key() == "fire_width_us")
        {
          st = set_fire_width(it.value(), resp);
          if (st != OpcUa_Good)
          {
            getAddressSpaceLink()->setFire_width_us(m_fire_width, st);
            return st;
          }
        }
        if (it.key() == "mmap")
        {
          // if there are any registers there, clean them out
          if (m_regs.size())
          {
            m_regs.clear();
          }
          json frag = it.value();
          // now grab the entries
          try
          {
            for (auto jt = frag.begin(); jt != frag .end(); ++jt)
            {
              laser_regs_t tmp;
              // for these, nothing is optional
              tmp.offset = jt.value().at(0);
              tmp.bit_high = jt.value().at(1);
              tmp.bit_low = jt.value().at(2);
              tmp.addr = 0x0;
              tmp.mask = cib::util::bitmask(tmp.bit_high,tmp.bit_low);
              m_regs.insert(std::pair<std::string,laser_regs_t>(it.key(),tmp));
            }
          }
          catch(json::exception &e)
          {
            msg.clear();msg.str("");
            msg << log_e("config"," ") << "Incomplete config fragment [mmap] : " << e.what();
            resp["messages"].push_back(msg.str());
            throw;
          }
          catch(std::exception &e)
          {
            msg.clear();msg.str("");
            msg << log_e("config"," ") << "Problem parsing config fragment [mmap] : " << e.what();
            resp["messages"].push_back(msg.str());
            throw;
          }
        }
      }
      // if we reached this point we don't have an exception, so things should be good
      // if we reached this point, things seem to be good
      // now it is time to map the registers
      map_registers();
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i("config","System configured");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
      return OpcUa_Good;
    }
    return OpcUa_Good;
  }
  void DIoLLaserUnit::update_status(Status s)
  {
    m_status = s;
    //FIXME: Add a status cache variable
    getAddressSpaceLink()->setState(m_status_map.at(m_status),OpcUa_Good);
  }
  UaStatus DIoLLaserUnit::map_registers()
  {
    // this method is specific for each device
    // -- first obtain a map to all the memory
    if (m_mapped_mem)
    {
      std::ostringstream msg("");
      msg << log_e("map_registers"," ") << "Memory pointer already populated. Doing nothing.";
      LOG(Log::WRN) << msg.str();
      return OpcUa_Bad;
    }
    m_mapped_mem = cib::util::map_phys_mem(m_mmap_fd,cib::mem::config_base_addr,cib::mem::config_high_addr);
    if (m_mapped_mem != 0)
    {
      // fill up each register and set the respective register pointers
      for (auto it : m_regs)
      {
        // note that there are 4 bytes in each register
        it.second.addr = (m_mapped_mem+(it.second.offset*sizeof(uint32_t)));
      }
      // start the movement monitor
      return OpcUa_Good;
    }
    else
    {
      // do nothing and just complain back
      return OpcUa_Bad;
    }
  }
  UaStatus DIoLLaserUnit::unmap_registers()
  {
    size_t size = cib::mem::config_high_addr - cib::mem::config_base_addr;
    int ret = cib::util::unmap_mem(cib::util::cast_to_void(m_mapped_mem), size);
    if (ret == 0)
    {
      return OpcUa_Good;
    }
    else
    {
      return OpcUa_Bad;
    }
    close(m_mmap_fd);
  }


}
