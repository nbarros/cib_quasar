
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.

    The stub of this file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.


 */

#include <Configuration.hxx> // TODO; should go away, is already in Base class for ages

#include <DIoLLaserUnit.h>
#include <ASIoLLaserUnit.h>
#include <utilities.hh>
#include <Laser.hh>
#include <string>
#include <sstream>
#include <thread>
#include <chrono>
#include <mem_utils.h>
#include <cib_mem.h>
#include <cstdint>
#include <cib_registers.h>
#include <chrono>
#include <thread>

using json = nlohmann::json;
//
#define log_msg(s,dev,met,msg) "[" << s << "]::" << dev << ":" << met << " : " << msg
//
#define log_e(m,s) log_msg("ERROR","laser",m,s)
#define log_w(m,s) log_msg("WARN","laser",m,s)
#define log_i(m,s) log_msg("INFO","laser",m,s)
//
#define DEBUG 1
using std::ostringstream;
using std::map;
using std::string;
//
namespace Device
{
// 1111111111111111111111111111111111111111111111111111111111111111111111111
// 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
// 1     Users don't modify this code!!!!                                  1
// 1     If you modify this code you may start a fire or a flood somewhere,1
// 1     and some human being may possible cease to exist. You don't want  1
// 1     to be charged with that!                                          1
// 1111111111111111111111111111111111111111111111111111111111111111111111111






// 2222222222222222222222222222222222222222222222222222222222222222222222222
// 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
// 2     (code for which only stubs were generated automatically)          2
// 2     You should add the implementation but dont alter the headers      2
// 2     (apart from constructor, in which you should complete initializati2
// 2     on list)                                                          2
// 2222222222222222222222222222222222222222222222222222222222222222222222222

/* sample ctr */
DIoLLaserUnit::DIoLLaserUnit (
    const Configuration::IoLLaserUnit& config,
    Parent_DIoLLaserUnit* parent
):
    Base_DIoLLaserUnit( config, parent)

    /* fill up constructor initialization list here */
            ,m_is_ready(false)
            ,m_status(sOffline)
            ,m_laser(nullptr)
            ,m_divider(0)
            ,m_pump_hv(1.1)
            ,m_rate_hz(10.0)
            ,m_part_state(0x2)
            ,m_shot_count(0)
            ,m_comport("auto")
            ,m_baud_rate(9600)
            ,m_count_flashes(false)
            ,m_name("")
            ,m_idle_counter(0)
            ,m_idle_timeout(0)
            ,m_mmap_fd(0)
            ,m_pause_timeout(10) // 10 min timeout by default
            ,m_standby_timeout(60) // 1h timeout for standby
            ,m_qswitch_delay(170) // 170 us by default
            ,m_qswitch_width(10) // 10 us
            ,m_fire_width(10)
            ,m_serial_number("")
            ,m_warmup_timer(20) // 30 min
//            ,m_serial_busy(false)
            ,m_config_completed(false)
            ,m_is_terminating(false)
{
    /* fill up constructor body here */
    m_name = config.id();
    LOG(Log::INF) << "DIoLLaserUnit::DIoLLaserUnit : Building instance of  [" << m_name << "]";
    LOG(Log::INF) << "DIoLLaserUnit::DIoLLaserUnit : Using ID   [" << config.id() << "]";
    m_serial_number = "";
    LOG(Log::INF) << "DIoLLaserUnit::DIoLLaserUnit : Port set to [" << m_comport << "]";

    //m_part_state = laser_state_u(0x2);
    // -- initialize the status map
    m_status_map.insert({sOffline,"offline"});
    m_status_map.insert({sReady,"ready"});
    m_status_map.insert({sWarmup,"warmup"});
    m_status_map.insert({sLasing,"lasing"});
    m_status_map.insert({sPause,"pause"});
    m_status_map.insert({sStandby,"standby"});
    m_status_map.insert({sError,"error"});

    cib_init_mem();
}

/* sample dtr */
DIoLLaserUnit::~DIoLLaserUnit ()
{

  cib_free_mem();
}

/* delegates for cachevariables */

/* Note: never directly call this function. */

UaStatus DIoLLaserUnit::writeDischarge_voltage_kV ( const OpcUa_Double& v)
{
#ifdef DEBUG
    LOG(Log::INF) << "Setting discharge voltage to " << v;
#endif
    std::ostringstream msg;
    // we need the system to be at least in unconfigured state
    // as we need the device connection to be established
    if (m_status == sError)
    {
      return OpcUa_BadInvalidState;
    }
    if (m_status == sOffline)
    {
      return OpcUa_BadInvalidState;
    }
    if (!m_laser)
    {
      return OpcUa_BadInvalidState;
    }
    json resp;
    return write_hv(v,resp);

}
/* Note: never directly call this function. */

UaStatus DIoLLaserUnit::writeRep_rate_hz ( const OpcUa_Double& v)
{
#ifdef DEBUG
    LOG(Log::INF) << "Setting Repetition rate";
#endif
    std::ostringstream msg;
    // we need the system to be at least in unconfigured state
    // as we need the device connection to be established
    if (m_status == sError)
    {
      return OpcUa_BadInvalidState;
    }
    if (m_status == sOffline)
    {
      return OpcUa_BadInvalidState;
    }
    if (!m_laser)
    {
      return OpcUa_BadInvalidState;
    }
    json resp;
    return write_rate(v,resp);
}
/* Note: never directly call this function. */

UaStatus DIoLLaserUnit::writeRep_rate_divider ( const OpcUa_UInt32& v)
{
#ifdef DEBUG
  LOG(Log::INF) << "Setting Rate Divider / Prescale to " << v;
#endif
  // we need the system to be at least in unconfigured state
    // as we need the device connection to be established
    if (m_status == sError)
    {
      return OpcUa_BadInvalidState;
    }
    if (m_status == sOffline)
    {
      return OpcUa_BadInvalidState;
    }
    if (!m_laser)
    {
      return OpcUa_BadInvalidState;
    }
    json resp;
    return write_divider(v,resp);
    // we don't really care for the responses in this case
    // just whether it went well or not
}


/* delegators for methods */
UaStatus DIoLLaserUnit::callSet_connection (
    const UaString&  device_port,
    OpcUa_UInt16 baud_rate,
    UaString& response
)
{
    std::ostringstream msg("");
    json resp;
    std::string port = device_port.toUtf8();
    UaStatus st = OpcUa_Good;
    st = check_error_state(resp);
    if (st != OpcUa_Good)
    {
      response = UaString(resp.dump().c_str());
      return OpcUa_Good;
    }
    //
    st = set_conn(port,baud_rate,resp);
    //
    if (st != OpcUa_Good)
    {
      msg << log_e("set_connection","Failed to set connection. Check previous messages.");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      if (!resp.contains("statuscode"))
      {
        resp["statuscode"] = OpcUa_Bad;
      }
    }
    else
    {
      if (!resp.contains("init"))
      {
        resp["status"] = "SUCCESS";
      }
      resp["messages"].push_back(std::string("Connection parameters set"));
      if (!resp.contains("statuscode"))
      {
        resp["statuscode"] = OpcUa_Good;
      }
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLLaserUnit::callConfig (
    const UaString&  conf,
    UaString& response
)
{
    std::ostringstream msg("");
    bool got_exception = false;
    const std::string lbl = "config";
    json resp;
    json cfrag;
    UaStatus st = OpcUa_Good;
    //
    st = check_error_state(resp);
    if (st != OpcUa_Good)
    {
      response = UaString(resp.dump().c_str());
      return OpcUa_Good;
    }
    //
    try
    {
      cfrag = json::parse(conf.toUtf8());
      st = config(cfrag,resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      terminate(resp);
      response = UaString(resp.dump().c_str());
      return OpcUa_Good;
    }
    // if config complained about something
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Configuration failed.");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      if (!resp.contains("statuscode"))
      {
        resp["statuscode"] = OpcUa_Bad;
      }
      terminate(resp);
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i(lbl.c_str(),"Configuration successful.");
      resp["status"] = "SUCCESS";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLLaserUnit::callInit (
    UaString& response
)
{
    std::ostringstream msg("");
    bool got_exception = false;
    const std::string lbl = "init";
    json resp;
    json cfrag;
    UaStatus st = OpcUa_Good;
    //
    st = check_error_state(resp);
    if (st != OpcUa_Good)
    {
      response = UaString(resp.dump().c_str());
      return OpcUa_Good;
    }
    //
    try
    {
      st = init(resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      terminate(resp);
      response = UaString(resp.dump().c_str());
      return OpcUa_Good;
    }
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Initialization failed.");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      if (!resp.contains("statuscode"))
      {
        resp["statuscode"] = OpcUa_Bad;
      }
      terminate(resp);
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i(lbl.c_str(),"Initialization successful.");
      resp["status"] = "SUCCESS";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLLaserUnit::callStop (
    UaString& response
)
{
    // stop can be called in sError state. No harm in making sure that everything is shut down
    std::ostringstream msg("");
    json resp;
    const std::string lbl = "stop";
    UaStatus st = stop(resp);
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed to stop. See previous messages");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      terminate(resp);
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Stopped successfully.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "SUCCESS";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLLaserUnit::callCheck_laser_status (
    OpcUa_UInt16& status,
    UaString& description
)
{
    json resp;
    std::ostringstream msg("");
    const std::string lbl = "check_status";
    UaStatus st = OpcUa_Good;
    //
    st = check_error_state(resp);
    if (st != OpcUa_Good)
    {
      status = 98;
      description = UaString(resp.dump().c_str());
      getAddressSpaceLink()->setLaser_status_code(status,OpcUa_BadInvalidState);
      return OpcUa_Good;
    }
    //
    // force a stop on the laser firing
    // start by closing hte shutter, and
    // since this is a usually kind of critical method, do not even care to check whether the
    // laser is firing or not, just stop and close the shutter
    st = check_laser_instance(resp);
    if (st != OpcUa_Good)
    {
      status = 99;
      description = UaString(resp.dump().c_str());
      getAddressSpaceLink()->setLaser_status_code(status,OpcUa_BadInvalidState);
      return OpcUa_Good;
    }
    //
    std::string desc;
    laser_security(status,desc,resp);
    description= UaString(desc.c_str());
    return OpcUa_Good;
    //
}
UaStatus DIoLLaserUnit::callSingle_shot (
    UaString& response
)
{
    json resp;
    (void) single_shot(resp);
    response = UaString(resp.dump().c_str());

    return OpcUa_Good;
}
UaStatus DIoLLaserUnit::callStart_standalone (
    OpcUa_Boolean fire,
    OpcUa_UInt32 num_shots,
    UaString& response
)
{
    // this calls the fire command without input from the CIB
    // it is meant to be used without CIB access
    // for now do not implement it
    return OpcUa_BadNotImplemented;
}
UaStatus DIoLLaserUnit::callStart_cib (
    UaString& response
)
{
    std::ostringstream msg("");
    json resp;
    UaStatus st = OpcUa_Good;
    const std::string lbl = "start_cib";
    //
    st = check_error_state(resp);
    if (st != OpcUa_Good)
    {
      response = UaString(resp.dump().c_str());
      return OpcUa_Good;
}
    //
    st = start_cib(resp);
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed to start laser. See previous messages");
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i(lbl.c_str(),"Laser started operating");
#ifdef DEBUG
      LOG(Log::INF) << msg.str();
#endif
      resp["status"] = "SUCCESS";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
#ifdef DEBUG
    LOG(Log::INF) << "[" << resp.dump() << "]";
#endif
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }

UaStatus DIoLLaserUnit::callSwitch_laser_shutter (
    OpcUa_Boolean close,
    UaString& response
)
{
    std::ostringstream msg("");
    json resp;
    UaStatus st = OpcUa_Good;
    const std::string lbl = "switch_shutter";
    //
    st = check_error_state(resp);
    if (st != OpcUa_Good)
    {
      response = UaString(resp.dump().c_str());
      return OpcUa_Good;
    }
    ShutterState shst = (close)?ShutterState::sClose:ShutterState::sOpen;
    st = switch_laser_shutter(shst,resp);
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed to switch laser. See previous messages");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i(lbl.c_str(),"Shutter switched to ") << close;
      LOG(Log::ERR) << msg.str();
      resp["status"] = "SUCCESS";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLLaserUnit::callForce_ext_shutter (
    OpcUa_Boolean close,
    UaString& response
)
{
    std::ostringstream msg("");
    json resp;
    UaStatus st = OpcUa_Good;
    const std::string lbl = "ext_shutter";
    //
    st = check_error_state(resp);
    if (st != OpcUa_Good)
    {
      response = UaString(resp.dump().c_str());
      return OpcUa_Good;
    }
    // if the memory is not mapped, we also cannot do this
    st = check_cib_mem(resp);
    if (st != OpcUa_Good)
    {
      response = UaString(resp.dump().c_str());
      return OpcUa_Good;
    }
    ShutterState shst = (close)?ShutterState::sClose:ShutterState::sOpen;
    st = force_ext_shutter(shst,resp);
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed to set ext shutter. See previous messages");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"ext shutter changed state successfully.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "SUCCESS";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLLaserUnit::callTerminate (
    UaString& response
)
{
    std::ostringstream msg("");
    json resp;
    const std::string lbl = "terminate";
    UaStatus st = terminate(resp);
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed to terminate laser. See previous messages");
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i(lbl.c_str(),"Laser unit connection terminated");
#ifdef DEBUG
      LOG(Log::INF) << msg.str();
#endif
      resp["status"] = "SUCCESS";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLLaserUnit::callStop_cib (
    UaString& response
)
{
    std::ostringstream msg("");
    json resp;
    const std::string lbl = "stop_cib";
    // there is only one stop operation.
    // it stops everything and in principle should never fail (even if memory is not mapped)
    // also, should not be subject to the sError state
    UaStatus st = stop(resp);
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed to stop laser. See previous messages");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i(lbl.c_str(),"Laser unit stopped. Back into a sReady state.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "SUCCESS";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLLaserUnit::callPause (
    UaString& response
)
{
    std::ostringstream msg("");
    json resp;
    const std::string lbl = "pause";
    // pause does not change anything in the laser itself.
    // just forces shut the external shutter
    UaStatus st = pause(resp);
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed to pause laser. See previous messages");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i(lbl.c_str(),"Laser unit paused. Beware of pause timer.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "SUCCESS";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLLaserUnit::callStandby (
    UaString& response
)
{
    std::ostringstream msg("");
    const std::string lbl = "standby";
    json resp;
    // there is only one stop operation.
    // it stops everything and in principle should never fail (even if memory is not mapped)
    // also, should not be subject to the sError state
    UaStatus st = standby(resp);
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed to put laser in standby. See previous messages");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i(lbl.c_str(),"Laser unit in standby. Beware of standby timer.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "SUCCESS";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLLaserUnit::callResume (
    UaString& response
)
{
    std::ostringstream msg("");
    json resp;
    const std::string lbl = "resume";
    UaStatus st = resume(resp);
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed to resume laser operation. See previous messages");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i(lbl.c_str(),"Laser operation resumed.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "SUCCESS";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}

// 3333333333333333333333333333333333333333333333333333333333333333333333333
// 3     FULLY CUSTOM CODE STARTS HERE                                     3
// 3     Below you put bodies for custom methods defined for this class.   3
// 3     You can do whatever you want, but please be decent.               3
// 3333333333333333333333333333333333333333333333333333333333333333333333333

UaStatus DIoLLaserUnit::set_conn(const std::string port, uint16_t baud, json &resp)
  {
    std::ostringstream msg("");
    const std::string lbl = "set_conn";
    UaStatus st = check_error_state(resp);
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"System in error state. Aborting.");
      LOG(Log::ERR) << msg.str();
      return st;
    }
    //
    // it only reaches here if it is also *not* in the sError state
    st = check_not_offline_state(resp);
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Laser instance found. This is unexpected and therefore a failure.");
      LOG(Log::ERR) << msg.str();
      return st;
    }
    // do a second cross-check. At this stage there should not be any instantiated object
    json tresp;
    st = check_laser_instance(tresp);
    // we shouldn't actually ever reach this state
    if (st == OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Laser instance found. This is unexpected and therefore a termination will be forced first.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
    }
    // at this stage we are good to set the connection parameters
    // otherwise, it is fair game
    if (port == std::string("auto"))
    {
      automatic_port_search();
      msg.clear(); msg.str("");
      msg << log_i(lbl.c_str(),"Automatic search found port [") << m_comport << "]";
#ifdef DEBUG
      LOG(Log::INF) << msg.str();
#endif
      resp["messages"].push_back(msg.str());
    }
    else
    {
      m_comport = port;
    }
    //
    if (m_comport.size() == 0)
    {
      // the port is invalid. Something failed.
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Port is invalid [") << m_comport << "]";
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return OpcUa_BadInvalidArgument;
    }
    // if we reached this point we have something apparently valid
    UaString ss(m_comport.c_str());
    getAddressSpaceLink()->setPort(ss,OpcUa_Good);
    //
    // -- Now the baud rate
    //
    if (baud == 0)
    {
      // just leave what it is presently set
      msg.clear(); msg.str("");
      msg << log_w(lbl.c_str(),"Baud rate kept to current value[") << m_baud_rate << "]";
#ifdef DEBUG
      LOG(Log::WRN) << msg.str();
#endif
      resp["messages"].push_back(msg.str());
    }
    else
    {
      m_baud_rate = baud;
    }
    getAddressSpaceLink()->setBaud_rate(m_baud_rate,OpcUa_Good);
    update_status(sOffline);
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::switch_laser_shutter(const ShutterState nstate, json &resp)
  {
    const std::string lbl = "switch_shutter";
    std::ostringstream msg("");
    bool got_exception = false;
    UaStatus st = OpcUa_Good;
    //
    st = check_error_state(resp);
    if (st != OpcUa_Good)
    {
      if (m_laser)
      {
        st = close_shutter(resp);
        m_part_state.state.laser_shutter_closed = true;
      }
      return st;
    }
    //
    st = check_offline_state(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    st = check_laser_instance(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    try
    {
      if (nstate == ShutterState::sClose)
      {
        // this basically forces a standby
        // we never refuse to close this shutter
        // but we do force qswitch to disable along with it
        // -- if we close the shutter, we should disable qswitch
        // disable qs_en
        disable_qswitch();
        close_shutter(resp);
        m_part_state.state.laser_shutter_closed = true;

        if (m_status != sStandby)
        {
          // if we are on standby, don't update, as we don't want to mess the timer
          update_status(sStandby);
          // this is now done on update_status
        }
        // if the external shutter is closed, open it
        // there is redundancy and there is no point
        if (m_part_state.state.ext_shutter_closed)
        {
          force_ext_shutter(ShutterState::sOpen,resp);
        }
        msg.clear(); msg.str("");
        msg << log_i(lbl.c_str(),"Laser shutter closed.");
      }
      else
      {
        // -- if we open the shutter, we should activate qswitch
        // but it could make sense to switch to pause state
        //
        // shouldn't we first switch to pause?
        // No, this interferes with the pause/resume logic
        // if we want to switch to pause, we close the shutter before releasing the standby
        // the logic here is a bit more convolved, based on which parts are active
        //
        // we have several combinations of states to consider
        // again, what actually matters is whether the laser has already started or not
        //
        Status newstate;
        if (m_part_state.state.fire_enable)
        {
          // the laser is operating.
          // This means that we should be getting out of
          // either sWarmup or sStandby
          // either way, we are switching to either
          // sPause (if ext shutter is closed)
          // or sLasing (if ext shutter is open)

          if (m_part_state.state.ext_shutter_closed)
          {
            // ext shutter is closed, we are in sPaused state
            newstate = sPause;
          }
          else
          {
            // coming into sLasing
            newstate = sLasing;
          }
        }
        else
        {
          // the laser is not operating
          // we switch to sReady state
          newstate = sReady;
        }
        // in both cases we first open the shutter and then activate qswitch
        open_shutter(resp);
        enable_qswitch();
        getAddressSpaceLink()->setLaser_shutter_open(true,OpcUa_Good);
        m_part_state.state.laser_shutter_closed = false;
        update_status(newstate);
        msg.clear(); msg.str("");
        msg << log_i(lbl.c_str(),"Laser shutter open.");

      }
      resp["status"] = "SUCCESS";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;

      // check if the start bit is set.
      // if yes, status changes to sLasing
      // otherwise status changes to sReady
      refresh_status();
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str()," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::force_ext_shutter(const ShutterState nstate, json &resp)
  {
    const std::string lbl = "ext_shutter";
    // if we are in some sort of error state and trying to open
    // refuse to do it, unless the internal shutter is already closed
    if ((m_status == sError) and (nstate == ShutterState::sOpen))
    {
      if (m_part_state.state.laser_shutter_closed)
      {
        // the internal shutter is closed, so we can authorize opening this one
        std::ostringstream msg("");
        msg.clear(); msg.str("");
        msg << log_w(lbl.c_str(),"Laser Unit in sError state and trying to open the shutter. allowing because internal shutter is closed.");
        resp["status"] = "SUCCESS";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_Uncertain;
        return OpcUa_Uncertain;
      }
      else
      {
        // internal shutter is also open, so refuse to open this one
        std::ostringstream msg("");
        msg.clear(); msg.str("");
        msg << log_e(lbl.c_str(),"Laser Unit in sError state and trying to open the shutter. System on lockdown. Check for error messages.");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidState;
        return OpcUa_BadInvalidState;
      }
    }
    // --no error state
    Status newstate;
    if ((nstate == ShutterState::sClose) && (!m_part_state.state.ext_shutter_closed))
    {
      // we want to close and right now is open : valid transition
      // there is nothing wrong with closing it, although it does trigger
      // a timeout
      close_ext_shutter();

      // if we are lasing, this puts the state in pause
      if (m_part_state.state.fire_enable)
      {
        // I am assuming that sPause trumps sStandby
        // as sPause has a shorter timeout
        // here we *cannot* use pause, because that method relies on this one
        newstate = sPause;
        update_status(sPause);
        // now done in update_status
        //start_pause_timer();

      }
      else
      {
        // we are not lasing, so state is sReady
        newstate = sReady;
        update_status(newstate);
      }
      // what to do if it is in sStandby or sReady?
      // for the others don't change the status...but keep track of the state
      // regardless of sate, the timer should be started
      // there is a triky part to this.
      // once we close the shutter, this timer turns on,
      // but then this could cause a change to sStandby.
      // would this be an issue?
    }
    else
    {
      // was closed and want to open
      if ((nstate == ShutterState::sOpen) && m_part_state.state.ext_shutter_closed)
      {
        // now we have a few states to consider
        // 8, to be exact
        // keep in mind that we are attempting to open the shutter
        // so that fixes already one state

        // the qswitch_en signal is always in opposite sign of the laser_shutter
        // if the laser is off, the state will always either revert
        // to sReady or sStandby
        if (m_part_state.state.fire_enable)
        {
          // laser is on.
          if (m_part_state.state.laser_shutter_closed)
          {
            // the internal shutter is closed
            // state goes to sStandby
            // in this case we do not trigger a timer, since it
            // should already be triggered
            newstate = sStandby;
          }
          else
          {
            // internal shutter is open
            // state goes to sLasing
            newstate = sLasing;
          }
        }
        else
        {
          // laser has not started
          // if we open the shutter, we are basically going to
          // sReady
          newstate = sReady;
        }
        open_ext_shutter();
        update_status(newstate);
      }
      else
      {
        // we're repeating a request tthat does not change state
        // do nothing
      }
    }
    return OpcUa_Good;
  }
  void DIoLLaserUnit::set_warmup_timer(uint32_t timer, json &resp)
  {
    m_warmup_timer = timer;
  }

  void DIoLLaserUnit::start_standby_timer()
  {
    // initate a timer that will check for the status of the internal shutter every second
    // until it reaches the total timeout.
    // if it reaches the total timeout, it shuts the laser down (for safeguarding)
    std::thread([this]()
                {
      uint32_t n_ticks = 0;
      const uint32_t n_ticks_per_sec = 2;
      uint32_t nsecs = 0;
      while (nsecs < (m_standby_timeout*60*n_ticks_per_sec))
      {
        if (m_status != sStandby)
        {
          // stop the timer
          getAddressSpaceLink()->setStandby_timer_s(0,OpcUa_Good);
          return;
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
        n_ticks++;
        if ((n_ticks%n_ticks_per_sec) == 0)
        {
          nsecs++;
          getAddressSpaceLink()->setStandby_timer_s(nsecs,OpcUa_Good);
        }
      }
      // reached the end of the loop and shutter is still closed
      // stop the system
      LOG(Log::WRN) << "Reached the end of the timer. Stopping the laser.";
      json r;
      stop(r);
                }
    ).detach();
  }
  void DIoLLaserUnit::start_pause_timer()
  {

    // initate a timer that will check for the status of the external shutter every second
    // until it reaches the total timeout.
    // if it reaches the total timeout, it switches to standby
    // and then automatically switch to paused state
    std::thread([this]()
                {
      uint32_t n_ticks = 0;
      const uint32_t n_ticks_per_sec = 10;
      uint32_t nsecs = 0;
      while (nsecs < (m_pause_timeout*60*n_ticks_per_sec))
      {
        if (!m_part_state.state.ext_shutter_closed)
        {
          // stop the timer
          getAddressSpaceLink()->setPause_timer_s(0,OpcUa_Good);

          return;
        }
        std::this_thread::sleep_for(std::chrono::seconds(100));
        n_ticks++;
        if ((n_ticks%n_ticks_per_sec) == 0)
        {
          nsecs++;
          getAddressSpaceLink()->setPause_timer_s(nsecs,OpcUa_Good);
        }
      }
      // reached the end of the loop and shutter is still closed
      // switch to standby and open this
      LOG(Log::WRN) << "Reached the end of the timer. Switching to standby.";
      json r;
      standby(r);
                }
    ).detach();
  }
  void DIoLLaserUnit::start_warmup_timer()
  {
    // initate a timer that will check for the status of the internal shutter every second
    // until it reaches the total timeout.
    // if it reaches the total timeout, it shuts the laser down (for safeguarding)
    std::thread([this]()
                {
      uint32_t n_ticks = 0;
      const uint32_t n_ticks_per_sec = 1;
      uint32_t nsecs = 0;
      while (nsecs < (m_warmup_timer*60*n_ticks_per_sec))
      {
        // if we somehow left warmup status, stop the timer
        if (m_status != sWarmup)
        {
          // stop the timer
          getAddressSpaceLink()->setWarmup_timer_s(0,OpcUa_Good);
          return;
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
        n_ticks++;
        if ((n_ticks%n_ticks_per_sec) == 0)
        {
          nsecs++;
          getAddressSpaceLink()->setWarmup_timer_s(nsecs,OpcUa_Good);
        }
      }
      // reached the end of the loop and shutter is still closed
      // stop the system
      LOG(Log::WRN) << "Reached the end of the warmup timer. ";
      if (m_status != sWarmup)
      {
        // state charged for some reason. Do nothing.
        // only stop and terminate can actually interfere with warmup
        LOG(Log::WRN) << "Warmup timer reached end but state no longer in warmup. Doing nothing.";
        return;
      }
      else
      {
        // -- reached the end of the warmup
        // switch to standby...which is pretty much the same thing, just with a different name
        update_status(sStandby);
      }
                }
    ).detach();
  }
  UaStatus DIoLLaserUnit::terminate(json &resp)
  {
    // this call does not care for sError state.
    // it attempts to do a peaceful shutdown, regardless of the overall state
    //    UaStatus st = OpcUa_Good;
    // we want terminate to take over the mutex as early as possible.
    // everything else is secondary
    std::ostringstream msg("");
    const std::string lbl = "terminate";
    m_is_terminating.store(true);
    // terminate should take on a mutex right away so other methods do nothing during this period

#ifdef DEBUG
    LOG(Log::WRN) << log_w(lbl.c_str(),"Terminating the current object instance.");
#endif
    // this is meant to do a smooth temrination of the device
    if (m_status == sOffline)
    {
      // there should not be a valid pointer
      if (m_laser)
      {
        // this is the state that could be more problematic
        // being already offline but with a live pointer
        // this should *NEVER* happen, but if it does, we're in trouble.
        msg.clear(); msg.str("");
        msg << log_w(lbl.c_str(),"There is a live pointer but state is offline. This should NEVER happen. Attempting to clear object.");
#ifdef DEBUG
        LOG(Log::WRN) << msg.str();
#endif
        resp["messages"].push_back(msg.str());
        //FIXME: What happens we if we lose the serial connection while the laser is connected?
        // Should we try to reconnect?
        // what happens if we delete this pointer after a serial exception?
        delete m_laser;
        m_laser = nullptr;
        return OpcUa_Uncertain;
      }
      // if it already is offline, all we need is to make sure
      // that the pointer is nullptr;
      m_laser = nullptr;
      return OpcUa_Good;
    }
    // don't call anything. This works like a reset
    // manually set all the states
    // disable the laser driver
    // even though it likely is already off
    // stop qs
    if (m_reg_map.size() !=0)
    {
      // stop qs_enable
      disable_qswitch();
      // cancel start
      disable_fire();
      // open the external shutter
      open_ext_shutter();
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"CIB memory not mapped. Can't control the laser driver.");
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["messages"].push_back(msg.str());
    }
    // close the internal shutter
#ifdef DEBUG
      LOG(Log::INF) << log_i(lbl.c_str(),"Closing laser shutter");
#endif
      // potential source of trouble here...close/open shutter
      // also lock the mutex, which will put them hanging, since the mutex is already on hold here

    switch_laser_shutter(ShutterState::sClose,resp);
    // at this stage, nothing else to be done.
    // just delete the device and go into offline mode
    // -- now just delete the device
    // FIXME: There is a potential rate condition here... if while we are terminating, other requests sit on a queue
    const std::lock_guard<std::mutex> lock(m_serial_mutex);
    update_status(sOffline);
    if (m_laser)
    {
#ifdef DEBUG
      std::ostringstream msg("");
      msg << log_w(lbl.c_str(),"Deleting the laser pointer");
      LOG(Log::WRN) << msg.str();
#endif
      delete m_laser;
#ifdef DEBUG
      LOG(Log::INF) << "Pointer deleted";
#endif
    }
    m_laser = nullptr;
    m_config_completed = false;
    m_is_terminating.store(false);
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::stop(json &resp)
  {
    // force a stop on the laser firing
    // start by closing the shutter, and
    // since this is a usually kind of critical method,
    // do not even care to check whether the
    // laser is firing or not, just stop and close the shutter
    std::ostringstream msg("");
    bool got_exception = false;
    const std::string lbl = "stop";
    // first thing. close the ext shutter. Not in pause mode, since that requires a laser connection
    UaStatus st = check_cib_mem(resp);
    if (st != OpcUa_Good)
    {
      terminate(resp);
      return st;
    }
    // if we have an external shutter, close it...at least until we stop everything else
    (void)force_ext_shutter(ShutterState::sClose,resp);
    try
    {
      // stop qs
      disable_qswitch();

      // cancel start
      disable_fire();

      // this stops the monitoring refresh
      // alternatively we could keep it always running and just set valid state when it is lasing
      m_count_flashes = false;

      // also tell the laser to stop.
      // it does not hurt
      if (m_laser)
      {
        st = stop_fire(resp);
        st = close_shutter(resp);
      }
      //  now open the external one
      force_ext_shutter(ShutterState::sOpen,resp);
      // downgrade anything above ready to ready to operate
      // states below remain as they are
      // if we reach this stage, we are ready...does not really matter what state we were before
      // as far as it was not sError
      update_status(sReady);
      // requery the laser system for its present status, in case there are issues to report
      refresh_status();
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    resp["status"] = "SUCCESS";
    msg.clear(); msg.str("");
    msg << log_i(lbl.c_str(),"Laser stopped.");
    resp["messages"].push_back(msg.str());
    resp["statuscode"] = OpcUa_Good;
    return OpcUa_Good;
  }

  UaStatus DIoLLaserUnit::start_cib(json &resp)
  {
    // Tell the cib to start firing.This can only be called when the system is in sReady state
    // this will switch the laser into sWarmup state.
    // sWarmup is pretty much the same as a standby.
    // qswitch is off, the internal shutter closed, external shutter open
    // however it does not have the stop timer turned on
    // once warmup is done, it automatically switches to sPause
    std::ostringstream msg("");
    const std::string lbl = "start_cib";
    bool got_exception = false;
    UaStatus st = OpcUa_Good;
    st = check_cib_mem(resp);
    if (st != OpcUa_Good)
    {
      terminate(resp);
      return st;
    }
    st = check_laser_instance(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    st = check_ready_state(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    // const std::lock_guard<std::mutex> lock(m_serial_mutex);
    try
    {
      // deassert qswitch enable
      disable_qswitch();

      // close the internal shutter
      st = close_shutter(resp);
      if (st != OpcUa_Good)
      {
        // something went wrong
        //
        return st;
      }
      st = start_fire(resp);
      if (st != OpcUa_Good)
      {
        // something went wrong
        // stop
        stop(resp);
        return st;
      }
      m_part_state.state.laser_shutter_closed = true;

      // if the external shutter is closed, open it
      force_ext_shutter(ShutterState::sOpen,resp);

      // start the laser firing on the CIB
      enable_fire();

      // downgrade anything above ready to ready to operate
      update_status(sWarmup);
      // initiate the warmup timer.
      // !!! Nothing is supposed to happen during warmup
      //start_warmup_timer();
      // requery the laser system for its present status, in case there are issues to report
      start_lasing_timer();
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    resp["status"] = "SUCCESS";
    msg.clear(); msg.str("");
    msg << log_i(lbl.c_str(),"Laser started.");
#ifdef DEBUG
    LOG(Log::INF) << msg.str();
#endif
    resp["messages"].push_back(msg.str());
    resp["statuscode"] = OpcUa_Good;
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::pause(json &resp)
  {
    // this is a state that closes the external shutter while keeping
    // everything else working
    // in principle it can be called from almost any state
    // but the resulting state is a little different
    std::ostringstream msg("");
    const std::string lbl = "pause";
    bool got_exception = false;
    UaStatus st = OpcUa_Good;
    st = check_cib_mem(resp);
    if (st != OpcUa_Good)
    {
      terminate(resp);
      return st;
    }
    st = check_laser_instance(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    try
    {
      // if it is in one of the previous stages redo the whole procedure
      // make sure qswitch enable is asserted
      // if it was already, it won't change anything and it only costs a
      // handful of microseconds
      (void)force_ext_shutter(ShutterState::sClose,resp);
      // this in itself will also trigger a timer
      // that will be checked e very second for the state of the shutter
      enable_qswitch();
      // downgrade anything above ready to ready to operate
      // can wereally be considered to be in pause?
      if (!m_part_state.state.fire_enable)
      {
        msg.clear(); msg.str("");
        msg << log_w(lbl.c_str(),"Pause called before laser was started. The shutter will close, but the laser will remain off.");
#ifdef DEBUG
        LOG(Log::WRN) << msg.str();
#endif
        resp["status"] = "SUCCESS";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_Uncertain;
        update_status(sReady);
      }
      else
      {
        update_status(sPause);
      }
      // requery the laser system for its present status, in case there are issues to report
      refresh_status();
      // start the pause timer (on the shutter)
      start_pause_timer();
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
#ifdef DEBUG
    LOG(Log::ERR) << msg.str();
#endif
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    resp["status"] = "SUCCESS";
    msg.clear(); msg.str("");
    msg << log_i(lbl.c_str(),"Laser operation paused.");
#ifdef DEBUG
    LOG(Log::INF) << msg.str();
#endif
    resp["messages"].push_back(msg.str());
    resp["statuscode"] = OpcUa_Good;
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::standby(json &resp)
  {
    // this is a state that opens the external shutter,
    // closes the internal shutter and disables qswitch
    // can be called from sLasing and sPause
    std::ostringstream msg("");
    bool got_exception = false;
    const std::string lbl = "standby";
    UaStatus st = OpcUa_Good;
    st = check_cib_mem(resp);
    if (st != OpcUa_Good)
    {
      terminate(resp);
      return st;
    }
    //    const std::lock_guard<std::mutex> lock(m_serial_mutex);
    st = check_laser_instance(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    // if it is either in warmup or standby do nothing
    if ((m_status == sWarmup) or (m_status == sStandby))
    {
      msg.clear(); msg.str("");
      msg << log_w(lbl.c_str(),"Laser already in warmup or standby state. Nothing to be done.");
#ifdef DEBUG
      LOG(Log::WRN) << msg.str();
#endif
      resp["status"] = "WARN";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_Good;
    }
    try
    {
      // disable qswitch
      disable_qswitch();
      // close the shutter
      switch_laser_shutter(ShutterState::sClose,resp);
      // if the external shutter is closed, open it
      force_ext_shutter(ShutterState::sOpen,resp);
      // if we are in sReady, sPause and sLasing, we can move to standby
      if (m_part_state.state.fire_enable)
      {
        update_status(sStandby);
      }
      else
      {
        update_status(sReady);
      }
      // requery the laser system for its present status, in case there are issues to report
      refresh_status();
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    resp["status"] = "SUCCESS";
    msg.clear(); msg.str("");
    msg << log_i(lbl.c_str(),"Laser operation on standby.");
#ifdef DEBUG
      LOG(Log::INF) << msg.str();
#endif
    resp["messages"].push_back(msg.str());
    resp["statuscode"] = OpcUa_Good;
    return OpcUa_Good;
  }

  void DIoLLaserUnit::automatic_port_search()
  {
    try
    {
      // the automatic port search queries all available ports, their descriptions and IDs for an occurrence of the device
      // serial number
      // this has been shown to work for most cases, but there is always a chance that something fails
      // for example, the wrong serial number was provided
      m_comport = util::find_port(m_serial_number);
      if (m_comport.size() == 0)
      {
        LOG(Log::ERR) << "DIoLLaserUnit::automatic_port_search : Couldn't find device port";
      }
      update_status(sOffline);
    }
    catch(...)
    {
      update_status(sOffline);
      LOG(Log::ERR) << "DIoLLaserUnit::automatic_port_search : Caught an exception searching for the port";
      m_comport = "";
    }
  }
  void DIoLLaserUnit::refresh_status()
  {
    json resp;
    refresh_status(resp);
  }
  void DIoLLaserUnit::refresh_status(json &resp)
  {
    //FIXME: There is a bug here, where after calling shutdown, this method crashes due to ongoing
    // connection
    std::ostringstream msg("");
    uint16_t status = 99;
    std::string desc;
    bool got_exception = false;
    const std::string lbl = "refresh_status";
    UaStatus st = OpcUa_Good;
    const std::lock_guard<std::mutex> lock(m_serial_mutex);
    try
    {
      st = check_laser_instance(resp);
      if (st != OpcUa_Good)
      {
        return;
      }
      st = check_offline_state(resp);
      if (st != OpcUa_Good)
      {
        return;
      }
// #ifdef DEBUG
// 	LOG(Log::INF) << log_i(lbl.c_str(),"Checking security");
// #endif
      m_laser->security(status, desc);
// #ifdef DEBUG
//       LOG(Log::INF) << log_i(lbl.c_str(),"Checking passed check");
// #endif
      getAddressSpaceLink()->setLaser_status_code(status,OpcUa_Good);
      UaString ss(m_status_map.at(m_status).c_str());
      getAddressSpaceLink()->setState(ss,OpcUa_Good);
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str()," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an STL exception :") << e.what();
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an unknown exception.");
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    if (got_exception)
    {
      getAddressSpaceLink()->setLaser_status_code(status,OpcUa_BadDataUnavailable);
    }
  }
  UaStatus DIoLLaserUnit::refresh_registers(json &resp)
  {
    const std::string lbl = "refresh_registers";
    bool has_error = false;
    UaStatus st = check_cib_mem(resp);
    if (st != OpcUa_Good)
    {
      has_error = true;
    }
    // refresh the fire width
    static uint32_t fw;
    try
    {
      st = get_fire_width(fw,resp);
      if (st != OpcUa_Good)
      {
        has_error = true;
      }
      static uint32_t qw;
      st = get_qswitch_width(qw,resp);
      if (st != OpcUa_Good)
      {
        has_error = true;
      }
      static uint32_t qd;
      st = get_qswitch_delay(qd,resp);
      if (st != OpcUa_Good)
      {
        has_error = true;
      }
      //FIXME: Implement the CIB number of shots
      // external shutter
      bool eso = false;
      st = get_ext_shutter_state(eso,resp);
      if (st != OpcUa_Good)
      {
        has_error = true;
      }
      static uint32_t fs;
      get_fire(fs);
      static uint32_t qs;
      get_qswitch(qs);
    }
    catch(std::exception &e)
    {
#ifdef DEBUG
      LOG(Log::ERR) << log_e(lbl.c_str(),"Failed to refresh the registers. Got exception : ") << e.what();
#endif
      has_error = true;
    }
    if (has_error)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str()," ") << "Errors found refreshing registers";
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["messages"].push_back(msg.str());
      return OpcUa_Bad;
    }
    return OpcUa_Good;
  }
  void DIoLLaserUnit::start_lasing_timer()
  {
    if (m_count_flashes)
    {
      LOG(Log::WRN) << "Trying to set a timer that has already been set up. Skipping.";
      return;
    }
    m_count_flashes = true;
    std::thread([this]()
                {
      while (get_counting_flashes())
      {
        // We know that the laser will be firing at 10 Hz, that means 100 ms period
        auto x = std::chrono::steady_clock::now() + std::chrono::milliseconds(50);
        if (refresh_shot_count() != OpcUa_Good)
        {
          LOG(Log::ERR) << "Failed to query device for status. Setting read values to InvalidData";
        }
        std::this_thread::sleep_until(x);
      }
                }).detach();
  }

  UaStatus DIoLLaserUnit::refresh_shot_count()
  {
    json resp;
    return refresh_shot_count(resp);
  }
  UaStatus DIoLLaserUnit::refresh_shot_count(json &resp)
  {
    std::ostringstream msg("");
    bool caught_exception = false;
    const std::string lbl = "get_shot_count";
    UaStatus st = OpcUa_Good;
    st = check_offline_state(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    const std::lock_guard<std::mutex> lock(m_serial_mutex);
    st = check_laser_instance(resp);
    if (st != OpcUa_Good)
    {
      getAddressSpaceLink()->setFlash_count(0, OpcUa_BadDataUnavailable);
      return st;
    }
    static uint32_t count = 0;
    // everything seems ready. Get counter
    try
    {
      m_laser->get_shot_count(count);
      // set the local cache
      m_shot_count = count;
      getAddressSpaceLink()->setFlash_count(m_shot_count, OpcUa_Good);
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str()," ") << "Port not open [" << e.what() << "]";
      caught_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with a Serial exception :") << e.what();
      caught_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an STL exception :") << e.what();
      caught_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an unknown exception.");
      caught_exception = true;
    }
    if (caught_exception)
    {
      LOG(Log::ERR) << msg.str();
      getAddressSpaceLink()->setFlash_count(m_shot_count, OpcUa_BadCommunicationError);
    }
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::init(json &resp)
  {
    // if the system is already initialized do nothing and give back a warning
    bool got_exception = false;
    ostringstream msg("");
    const std::string lbl = "init";
    UaStatus ret = OpcUa_Good;
    ret = check_error_state(resp);
    if (ret != OpcUa_Good)
    {
      return ret;
    }
    ret = check_not_offline_state(resp);
    if (ret != OpcUa_Good)
    {
      resp["statuscode"] = OpcUa_Uncertain;
      return OpcUa_BadInvalidState;
    }
    if (m_comport.size() == 0)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Unkonwn port.");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return OpcUa_BadInvalidArgument;
    }
    if (m_comport == std::string("auto"))
    {
      msg.clear(); msg.str("");
      msg << log_w(lbl.c_str(),"Port set to auto. Probing ports.");
      resp["status"] = "SUCCESS";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
      automatic_port_search();
    }
    // -- at this stage either things went well, or have returned already
    try
    {
      if (m_laser)
      {
        msg.clear(); msg.str("");
        msg << log_w(lbl.c_str(),"System already initialized. Just reconfiguring.");
        resp["messages"].push_back(msg.str());
        bool clean_and_rebuild = false;
        // no need of mutex for this, as far as there is an instance
        std::string lport = m_laser->get_port();
        if (lport != m_comport)
        {
          clean_and_rebuild = true;
        }
        // same here. No need for mutex
        uint16_t lbaud = m_laser->get_baud();
        //
        if (lbaud != m_baud_rate)
        {
          clean_and_rebuild = true;
        }
        if (clean_and_rebuild)
        {
          // that means that we should terminate and recreate
          // grab a mutex to destroy the object, so we don't leave operations hanging
          const std::lock_guard<std::mutex> lock(m_serial_mutex);
          delete m_laser;
          m_laser = nullptr;
          m_laser = new device::Laser(m_comport.c_str(),m_baud_rate);
        }
      }
      else
      {
        m_laser = new device::Laser(m_comport.c_str(),m_baud_rate);
      }
      // -- now that we have the system, let's update the settings in
      // the local cache
      update_status(sReady);

      // since we are at the init stage, we can call directly the device methods
      // call the internal methods, as these also check valid ranges
      // try to write all. If one fails, pass the error,
      // but give the opportunity for all settings to be written
      ret = write_hv(m_pump_hv,resp);
      ret = ret | write_divider(m_divider,resp);
      // for external driving these two don't really matter
      ret = ret | write_rate(m_rate_hz,resp);
      ret = ret | set_qswitch_delay(m_qswitch_delay,resp);
      if (ret != OpcUa_Good)
      {
        // something failed. Whatever it was, should already be in the
        // response string
        msg.clear(); msg.str("");
        msg << log_w(lbl.c_str(),"Some parameters failed to be set. Check previous messages.");
        return OpcUa_Bad;
      }
      else {
        msg.clear(); msg.str("");
        msg << log_i(lbl.c_str(),"System reconfigured sucessfully.");
      }
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str()," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      terminate(resp);
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i(lbl.c_str(),"System initialized.");
      resp["status"] = "SUCCESS";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
      return OpcUa_Good;
    }
  }
  UaStatus DIoLLaserUnit::write_divider(const uint16_t v,json &resp)
  {
    // that is the job of the original method
    uint16_t nv = v;
    static ostringstream msg("");
    bool got_exception = false;
    const std::string lbl = "write_divider";
    const std::lock_guard<std::mutex> lock(m_serial_mutex);
    UaStatus st = check_laser_instance(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    st = check_ready_state(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    if ( v > 99)
    {
      nv = 99;
      msg.clear(); msg.str("");
      msg << log_w(lbl.c_str()," ") << "Value out of bounds. Truncating to max [ " << v << " --> " << nv << "]";
      resp["messages"].push_back(msg.str());
#ifdef DEBUG
      LOG(Log::WRN) << msg.str();
#endif
    }
    try
    {
      m_laser->set_prescale(nv);
      m_divider = nv;
      getAddressSpaceLink()->setRep_rate_divider(m_divider, OpcUa_Good);
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str()," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      getAddressSpaceLink()->setRep_rate_divider(m_divider, OpcUa_BadCommunicationError);
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    resp["status"] = "SUCCESS";
    resp["statuscode"] = OpcUa_Good;
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::write_rate(const double v,json &resp)
  {
    // NOTE: This method does not check whether the system is ready to execute
    // that is the job of the original method
    // check range
    static ostringstream msg("");
    bool got_exception = false;
    const std::string lbl = "write_rate";
    UaStatus st = OpcUa_Good;
    // check range
    if (v <= 0.0 || v > 20.0)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Value out of bounds: ") << v << "<> [0.0,20.0]";
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadOutOfRange;
      return OpcUa_BadOutOfRange; // This shouldn't even be changed
    }
    // once the mutex is acquired, no more troubles should happen
    const std::lock_guard<std::mutex> lock(m_serial_mutex);
    st = check_laser_instance(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    st = check_ready_state(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    try
    {
      m_laser->set_repetition_rate(v);
#ifdef DEBUG
      LOG(Log::INF) << log_i(lbl.c_str(),"Repetition rate set");
#endif
      m_rate_hz = v;
      getAddressSpaceLink()->setRep_rate_hz(m_rate_hz, OpcUa_Good);
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str()," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      getAddressSpaceLink()->setRep_rate_hz(m_rate_hz, OpcUa_BadCommunicationError);
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::write_hv(const double v,json &resp)
  {
    // NOTE: This method does not check whether the system is ready to execute
    // that is the job of the original method
    // check range
    static ostringstream msg("");
    bool got_exception = false;
    const std::string lbl = "write_hv";
    UaStatus st = OpcUa_Good;
    // check range
    if ((v < 0) || (v > 1.3))
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Value out of bounds: ") << v << "<> [0.0,20.0]";
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadOutOfRange;
      return OpcUa_BadOutOfRange; // avoid overflow
    }
    const std::lock_guard<std::mutex> lock(m_serial_mutex);
    st = check_laser_instance(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    st = check_ready_state(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    try
    {
      m_laser->set_pump_voltage(v);
#ifdef DEBUG
      LOG(Log::INF) << log_i(lbl.c_str(),"Voltage set");
#endif
      m_pump_hv = v;
      getAddressSpaceLink()->setDischarge_voltage_kV(m_pump_hv, OpcUa_Good);
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str()," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      getAddressSpaceLink()->setDischarge_voltage_kV(m_pump_hv, OpcUa_BadCommunicationError);
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    return OpcUa_Good;
  }
  void DIoLLaserUnit::get_laser_shutter()
  {
    // this method just pushes the internal state, since we cannot query the laser itself
    getAddressSpaceLink()->setLaser_shutter_open(!m_part_state.state.laser_shutter_closed,OpcUa_Good);
  }

  void DIoLLaserUnit::update()
  {
    // This is a problematic method, since it runs on a separate thread.
    // Therefore it needs to do several checks to make sure it does not enter into race conditions with the normal operation
    // the main issue here is when there is a race condition with the termination
    json resp;
    if (m_is_terminating.load())
    {
      return;
    }

    if (m_laser)
    {
      // this could potentially cause a race condition
      refresh_status(resp);
      // this could potentially cause a race condition
      refresh_shot_count(resp);
      // this does not cause a crash. Just updates the slow control variable
      get_laser_shutter();
    }
    UaStatus st;
    // this should not cause crashes either.
    if ((m_status != sOffline) && m_config_completed)
    {
      st = refresh_registers(resp);
      if (st != OpcUa_Good)
      {
        LOG(Log::ERR) << "DIoLLaserUnit::update : Detected an error reading registers.";
      }
    }
  }
  UaStatus DIoLLaserUnit::fire_standalone(uint32_t num_pulses,json &resp)
  {
    // for now do not implement this.
    // but we could actually operate the laser from here. The procedure could use config and init as before
    // but then call fire_standalone to use the internal generator
    return OpcUa_BadNotImplemented;
  }
  UaStatus DIoLLaserUnit::fire_discrete_shots(uint32_t num_pulses,json &resp )
  {
    std::ostringstream msg("");
    //bool caught_exception = false;
    UaStatus st;
    st = check_error_state(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    st = check_laser_instance(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    // if the laser is not in the sReady state, also do nothing
    // likely some parameter is not set yet
    // also fail if the laser is firing
    if (!m_part_state.state.fire_enable)
    {
      msg.clear(); msg.str("");
      msg << log_e("fire_discrete_shots","The laser is operating") << " (current state " << m_status_map.at(m_status) << ")";
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
    }
    // we seem to be ready to operate
    // depending on the exact state, we want to release all shutters
    // count the appropriate number of pulses and go back to pause state
    uint32_t n_shots_prev = cib_get_shot_count();
    st = resume(resp);
    if (st != OpcUa_Good)
    {
      // failed to resume
      // force a standby
      (void)standby(resp);
      return st;
    }
    // we are firing, count shots
    while ((cib_get_shot_count()-n_shots_prev)<num_pulses)
    {
      std::this_thread::sleep_for(std::chrono::milliseconds(80));
    }
    // we are done. Close the shutter.
    st = standby(resp);
    return st;
  }

  UaStatus DIoLLaserUnit::single_shot(json & resp)
  {
    std::ostringstream msg("");
    bool caught_exception = false;
    UaStatus st = OpcUa_Good;
    st = check_error_state(resp);
    if(st != OpcUa_Good)
    {
      return st;
    }
    const std::lock_guard<std::mutex> lock(m_serial_mutex);
    st = check_laser_instance(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    st = check_ready_state(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    // if the shutter is not open, there is no point in firing
    //
    if (m_part_state.state.laser_shutter_closed)
    {
      msg.clear(); msg.str("");
      msg << log_e("single_shot","The laser shutter is not open");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_Good;
    }
    // if the external shutter is not open, there is no point in firing
    //
    if (m_part_state.state.ext_shutter_closed)
    {
      msg.clear(); msg.str("");
      msg << log_e("single_shot","The external shutter is not open");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_Good;
    }
    // everything seems ready. Fire away
    try
    {
      // FIXME: This logic is not doing anything about the external shutter
      // once the external shutter is in place, one should actually stop using this command and instead
      // drive a single shot from the CIB (so that the external shutter is also timely opened)
      update_status(sLasing);
//      while (m_serial_busy.load())
//      {
//        std::this_thread::sleep_for(std::chrono::milliseconds(5));
//      }
//      m_serial_busy.store(true);
      m_laser->single_shot(); // ensure that the prescale is rescaled
//      m_serial_busy.store(false);
      update_status(sReady);
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("single_shot"," ") << "Port not open [" << e.what() << "]";
      caught_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("single_shot","Failed with a Serial exception :") << e.what();
      caught_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("single_shot","Failed with an STL exception :") << e.what();
      caught_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("single_shot","Failed with an unknown exception.");
      caught_exception = true;
    }
    if (caught_exception)
    {
//      m_serial_busy.store(false);
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      standby(resp);

      return OpcUa_Bad;
    }
    else {
      // all was good
      msg.clear(); msg.str("");
      msg << log_i("single_shot","Laser single shot fired");
      LOG(Log::INF) << msg.str();
      resp["status"] = "SUCCESS";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }
  bool DIoLLaserUnit::validate_config_fragment(json &conf, json &resp)
  {
    // this is just a validation check for the available keys.
    // it will only check the mandatory keys.
    const std::string lbl = "validate_config";
    std::vector<std::string> mandatory_keys = {
        "id","port","serial_number","baud_rate",
        "pause_timeout_min","standby_timeout_min","qswitch_delay_us","qswitch_width_us",
        "fire_width_us","mmap", "warmup_timer_min"
    };
    std::vector<std::string> optional_keys = {
        "repetition_rate_divider", "discharge_voltage", "repetition_rate"
    };
    //
    // actually, check for all entries and report all missing ones
    std::vector<std::string> missing;
    //
    for (auto entry: mandatory_keys)
    {
      if (!conf.contains(entry))
      {
        missing.push_back(entry);
      }
    }
    if (missing.size() > 0)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Missing mandatory entries in LaserUnit config fragment [");
      for (auto e : missing)
      {
        msg << "(" <<  e << "),";
      }
      msg << "]";
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return false;
    }
    //
    missing.clear();
    // check the optional keys
    for (auto entry: optional_keys)
    {
      if (!conf.contains(entry))
      {
        missing.push_back(entry);
      }
    }
    if (missing.size() > 0)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_w(lbl.c_str(),"Missing optional entries in LaserUnit config fragment [");
      for (auto e : missing)
      {
        msg << "(" <<  e << "),";
      }
      msg << "]";
      resp["messages"].push_back(msg.str());
    }
    // all good, return true
    return true;
  }
  UaStatus DIoLLaserUnit::config(json & config, json &resp)
  {
    std::ostringstream msg("");
    bool got_exception = false;
    const std::string lbl = "config";
    UaStatus st;
    try
    {
      st = check_error_state(resp);
      if (st != OpcUa_Good)
      {
        return st;
      }
      json conf = config;
      // the very first thing is to check that the laser is offline
      // if it isn't fail immediately
      st = check_not_offline_state(resp);
      if (st != OpcUa_Good)
      {
        return st;
      }
      // then check the configuration is aimed to the proper device
      if (conf.at("id").get<std::string>() != m_name)
      {
        msg.clear(); msg.str("");
        msg << log_e(lbl.c_str(),"Mismatch between name in object and configuration fragment :")
                                          << " (" << conf.at("id").get<std::string>() <<" <> " << m_name << ")";
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      // validate that all settings are here
      if (!validate_config_fragment(conf,resp))
      {
        return OpcUa_BadInvalidArgument;
      }
      // if it is a valid configuration fragment start processing it.
      // first grab the serial number, as it is necessary in case the port is set to
      // "auto"
      m_serial_number = conf.at("serial_number").get<std::string>();
      // first grab the connection settings, since we want the connection
      // to be established before processing the other settings
      std::string port = conf.at("port").get<std::string>();
      uint16_t baud = conf.at("baud_rate").get<uint16_t>();
      st = set_conn(port,baud,resp);
      if ( st != OpcUa_Good)
      {
        // just fail
        LOG(Log::ERR) << log_e(lbl.c_str(),"Failed to determine device connection settings");
        return st;
      }
      // all good so far, so lets initiate the connection by creating an instance of the laser system
      m_laser = new device::Laser(m_comport.c_str(),static_cast<uint32_t>(m_baud_rate));
      st = check_laser_instance(resp);
      if (st != OpcUa_Good)
      {
#ifdef DEBUG
        LOG(Log::ERR) << log_e(lbl.c_str(),"Failed to create a laser instance");
#endif
        // cleaning up the 
        terminate(resp);
        return st;
      }
      update_status(sReady);
      // if the ids match, lets set the parameters
      // special iterator member functions for objects
      // after the connection parameters, go over the memory mapped details,since this is
      // relevant for the other settings
      json frag = conf.at("mmap");
      st =  map_registers(frag,resp);
      if (st != OpcUa_Good)
      {
        msg.clear();msg.str("");
        msg << log_e(lbl.c_str(),"Failed to map configuration registers");
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
        resp["messages"].push_back(msg.str());
        resp["status"] = "ERROR";
        resp["statuscode"] = OpcUa_Bad;
        update_status(sOffline);
        return st;
      }
#ifdef DEBUG
      else
      {
        LOG(Log::INF) << log_i(lbl.c_str(),"Registers mapped");
      }
#endif
      for (json::iterator it = conf.begin(); it != conf.end(); ++it)
      {
        LOG(Log::INF) << "Processing " << it.key() << " : " << it.value() << "\n";
        if (it.key() == "repetition_rate")
        {
#ifdef DEBUG
            LOG(Log::INF) << log_i(lbl.c_str(),"Setting repetition rate to ") << it.value();
#endif
          st = write_rate(it.value(),resp);
          if (st != OpcUa_Good)
          {
#ifdef DEBUG
            LOG(Log::ERR) << log_e(lbl.c_str(),"Failed to set repetition rate");
#endif
            getAddressSpaceLink()->setRep_rate_hz(m_rate_hz, st);
            terminate(resp);
            return st;
          }
#ifdef DEBUG
            LOG(Log::INF) << log_i(lbl.c_str(),"Repetition rate set ");
#endif
        }
        if (it.key() == "repetition_rate_divider")
        {
#ifdef DEBUG
            LOG(Log::INF) << log_i(lbl.c_str(),"Setting repetition rate divider to ") << it.value();
#endif
          st = write_divider(it.value(),resp);
          if (st != OpcUa_Good)
          {
#ifdef DEBUG
            LOG(Log::ERR) << log_e(lbl.c_str(),"Failed to set repetition rate divider");
#endif
            getAddressSpaceLink()->setRep_rate_divider(m_divider,st);
            terminate(resp);
            return st;
          }
        }
        if (it.key() == "discharge_voltage")
        {
#ifdef DEBUG
            LOG(Log::INF) << log_i(lbl.c_str(),"Setting voltage");
#endif
          st = write_hv(it.value(), resp);
          if (st != OpcUa_Good)
          {
#ifdef DEBUG
            LOG(Log::ERR) << log_e(lbl.c_str(),"Failed to set voltage");
#endif
            getAddressSpaceLink()->setDischarge_voltage_kV(m_pump_hv, st);
            terminate(resp);
            return st;
          }
#ifdef DEBUG
            LOG(Log::INF) << log_i(lbl.c_str(),"Voltage set");
#endif
        }
        if (it.key() == "pause_timeout_min")
        {
#ifdef DEBUG
            LOG(Log::INF) << log_i(lbl.c_str(),"Setting pause timeout to ") << it.value();
#endif
          set_pause_timeout(it.value(), resp);
        }
        if (it.key() == "standby_timeout_min")
        {
#ifdef DEBUG
            LOG(Log::INF) << log_i(lbl.c_str(),"Setting standby timeout to ") << it.value();
#endif
          set_standby_timeout(it.value(), resp);
        }
        if (it.key() == "qswitch_delay_us")
        {
#ifdef DEBUG
            LOG(Log::INF) << log_i(lbl.c_str(),"Setting qswitch delay to ") << it.value();
#endif
          st = set_qswitch_delay(it.value(), resp);
          if (st != OpcUa_Good)
          {
#ifdef DEBUG
            LOG(Log::ERR) << log_e(lbl.c_str(),"Failed to set qswitch delay");
#endif
            getAddressSpaceLink()->setQswitch_delay_us(m_qswitch_delay, st);
            terminate(resp);
            return st;
          }
        }
        if (it.key() == "warmup_timer_min")
        {
#ifdef DEBUG
          LOG(Log::INF) << log_i(lbl.c_str(), "Setting warmup timer to ") << it.value();
#endif
        set_warmup_timer(it.value(), resp);
        }
        if (it.key() == "qswitch_width_us")
        {
#ifdef DEBUG
            LOG(Log::INF) << log_i(lbl.c_str(),"Setting qswitch width to ") << it.value();
#endif
          st = set_qswitch_width(it.value(), resp);
          if (st != OpcUa_Good)
          {
#ifdef DEBUG
            LOG(Log::ERR) << log_e(lbl.c_str(),"Failed to set qswitch width");
#endif

            getAddressSpaceLink()->setQswitch_width_us(m_qswitch_width, st);
            terminate(resp);
            return st;
          }
        }
        if (it.key() == "fire_width_us")
        {
#ifdef DEBUG
            LOG(Log::INF) << log_i(lbl.c_str(),"Setting fire width to ") << it.value();
#endif
          st = set_fire_width(it.value(), resp);
          if (st != OpcUa_Good)
          {
#ifdef DEBUG
            LOG(Log::ERR) << log_e(lbl.c_str(),"Failed to set fire width");
#endif
            getAddressSpaceLink()->setFire_width_us(m_fire_width, st);
            terminate(resp);
            return st;
          }
        }
      }
#ifdef DEBUG
      LOG(Log::INF) << log_i(lbl.c_str(),"Done with config");
#endif
      // update the timers so that they don't complain about Waiting for data
      getAddressSpaceLink()->setWarmup_timer_s(0,OpcUa_Good);
      getAddressSpaceLink()->setStandby_timer_s(0,OpcUa_Good);
      getAddressSpaceLink()->setPause_timer_s(0,OpcUa_Good);

      m_config_completed = true;
      // if we reached this point we don't have an exception, so things should be good
      // if we reached this point, things seem to be good
      // now it is time to map the registers
      //      map_registers();
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      terminate(resp);
      return OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i(lbl.c_str(),"Laser system configured");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
      return OpcUa_Good;
    }
    return OpcUa_Good;
  }
  void DIoLLaserUnit::update_status(Status s)
  {
    m_status = s;
    UaString ss(m_status_map.at(m_status).c_str());
    getAddressSpaceLink()->setState(ss,OpcUa_Good);
    // check if we need to start any of the timers associated with specific statuses
    if (s == sPause)
    {
      start_pause_timer();
    }
    if (s == sStandby)
    {
      start_standby_timer();
    }
    if (s == sWarmup)
    {
      start_warmup_timer();
    }
  }
  UaStatus DIoLLaserUnit::map_registers(json &reginfo, json &resp)
  {
    // this method is specific for each device
    // -- first obtain a map to all the memory
    std::ostringstream msg("");
    const std::string lbl = "map_registers";
#ifdef DEBUG
    LOG(Log::INF) << log_i(lbl.c_str(),"Mapping registers");
#endif
    UaStatus st = check_cib_mem(resp);
    if(st != OpcUa_Good)
    {
#ifdef DEBUG
    LOG(Log::ERR) << log_e(lbl.c_str(),"CIB memory not mapped");
#endif
      return st;
    }
    else
    {
      // if there are any registers there, clean them out
      if (m_regs.size())
      {
        m_regs.clear();
      }
      // now grab the entries
      try
      {
        for (auto jt = reginfo.begin(); jt != reginfo.end(); ++jt)
        {
          if (jt.value().at(0) == -1)
          {
            // disabled register
            // skip
            continue;
          }
          laser_regs_t tmp;
          // for these, nothing is optional
          // offset corresponds to the
          tmp.reg_id = jt.value().at(0);
          tmp.offset = jt.value().at(1);
          tmp.bit_high = jt.value().at(2);
          tmp.bit_low = jt.value().at(3);
          tmp.addr = (m_reg_map.at(tmp.reg_id).vaddr+(tmp.offset*GPIO_CH_OFFSET));
          tmp.mask = cib::util::bitmask(tmp.bit_high,tmp.bit_low);
#ifdef DEBUG
          LOG(Log::INF) << "Mapping register " << jt.key() << " with reg_id " << tmp.reg_id
              << " offset " << tmp.offset << " bh " << tmp.bit_high << " bl " << tmp.bit_low
              << " addr " << std::hex << tmp.addr << std::dec << " mask " << std::hex << tmp.mask
              << std::dec << " ";
#endif
          m_regs.insert(std::pair<std::string,laser_regs_t>(jt.key(),tmp));
        }
      }
      catch(json::exception &e)
      {
        msg.clear();msg.str("");
        msg << log_e(lbl.c_str()," ") << "Incomplete config fragment [mmap] : " << e.what();
        resp["messages"].push_back(msg.str());
        return OpcUa_Bad;
      }
      catch(std::exception &e)
      {
        msg.clear();msg.str("");
        msg << log_e(lbl.c_str()," ") << "Problem parsing config fragment [mmap] : " << e.what();
        resp["messages"].push_back(msg.str());
        return OpcUa_Bad;
      }
      return OpcUa_Good;
    }
  }
  UaStatus DIoLLaserUnit::set_qswitch_delay(const uint32_t v,json &resp)
  {
    // this method does not check that the conditions are met...
    // that is the job of the original method. This one just does the job at hand
    // check range
    uint32_t nv = v;
    static ostringstream msg("");
    const std::string lbl = "set_qswitch_delay";
    UaStatus st = OpcUa_Good;
    bool got_exception = false;
    // this method should *NEVER* be called before the connection to the CIB is established
    st = check_cib_mem(resp);
    if (st !=OpcUa_Good)
    {
      return st;
    }
    // qswitch should only be set at the sReady state
    st = check_ready_state(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    if ( v > 999)
    {
      nv = 999;
      msg.clear(); msg.str("");
      msg << log_w(lbl.c_str()," ") << "Value out of bounds. Truncating to max [ " << v << " --> " << nv << "]";
      resp["messages"].push_back(msg.str());
#ifdef DEBUG
      LOG(Log::WRN) << msg.str();
#endif
      }
    try
    {
      // convert the value into 16 ns clocks
      uint32_t v_clock = conv_to_clock(nv);
//      uint32_t v_clock= nv*1000/16;
      // when reading out the configuration from JSON
      // this means that the code below is completely agnostic
      // set the value both at CIB and laser level
      // -- otherwise, set the memory region in the register, and the local cache variable too
#ifdef DEBUG
      LOG(Log::WRN) << "Writing qs_delay " << v_clock << " with \n"
          << "addr " << std::hex << m_regs.at("qs_delay").addr << std::dec << "\n"
          << "mask " << std::hex << m_regs.at("qs_delay").mask << std::dec << "\n"
          << "offset " << m_regs.at("qs_delay").bit_low;

      LOG(Log::INF) << "Original value :";
      LOG(Log::INF) << std::hex << cib::util::reg_read(m_regs.at("qs_delay").addr);
#endif
      cib::util::reg_write_mask_offset(m_regs.at("qs_delay").addr,
                                       v_clock,
                                       m_regs.at("qs_delay").mask,
                                       m_regs.at("qs_delay").bit_low);

#ifdef DEBUG
      LOG(Log::WRN) << "Done writing qs_delay ";
#endif
          //      m_laser->set_qswitch(nv);
      m_qswitch_delay = v_clock;
      // update the address space as well
      getAddressSpaceLink()->setQswitch_delay_us(nv, OpcUa_Good);
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("qswitch"," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("qswitch","Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("qswitch","Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("qswitch","Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
      getAddressSpaceLink()->setQswitch_delay_us(conv_to_us(m_qswitch_delay), OpcUa_Bad);
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::get_qswitch_delay(uint32_t &v,json &resp)
  {
    UaStatus st = check_cib_mem(resp);
    const std::string lbl = "get_qswitch_delay";
    if (st != OpcUa_Good)
    {
      uint32_t delay_us = conv_to_us(m_qswitch_delay);
      getAddressSpaceLink()->setQswitch_delay_us(delay_us, OpcUa_BadCommunicationError);
      return st;
    }
    // get the value from the register
    uint32_t rval = cib::util::reg_read(m_regs.at("qs_delay").addr);
    // now extract the delay from the register value
    uint32_t delay = ((rval & m_regs.at("qs_delay").mask) >> m_regs.at("qs_delay").bit_low);
//#ifdef DEBUG
//    LOG(Log::INF) << log_i(lbl.c_str()," Qswitch delay (clocks) :") << delay;
//#endif
    m_qswitch_delay = delay;
    // convert to floating point
    uint32_t delay_us = conv_to_us(delay);
//#ifdef DEBUG
//    LOG(Log::INF) << log_i(lbl.c_str()," QSwitch delay (us) :") << delay_us;
//#endif
    getAddressSpaceLink()->setQswitch_delay_us(delay_us, OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::set_qswitch_width(const uint32_t v,json &resp)
  {
    // this method should *NEVER* be called before the connection to the CIB is established
    UaStatus st = check_cib_mem(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    // convert the value into a 16 ns clock number
    // the set unit is us
    uint32_t v_clock= conv_to_clock(v);
    // -- otherwise, set the memory region in the register, and the local cache variable too
    cib::util::reg_write_mask_offset(m_regs.at("qs_width").addr,
                                     v_clock,
                                     m_regs.at("qs_width").mask,
                                     m_regs.at("qs_width").bit_low);
    m_qswitch_width = v_clock;
    getAddressSpaceLink()->setQswitch_width_us(conv_to_us(m_qswitch_width), OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::get_qswitch_width(uint32_t &v,json &resp)
  {
    UaStatus st = check_cib_mem(resp);
    const std::string lbl = "get_qswitch_width";
    if (st != OpcUa_Good)
    {
      getAddressSpaceLink()->setQswitch_width_us(conv_to_us(m_qswitch_width), OpcUa_BadCommunicationError);
      return st;
    }
    // get the value from the register
    uint32_t rval = cib::util::reg_read(m_regs.at("qs_width").addr);
    // now extract the width from the register value
    uint32_t width = ((rval & m_regs.at("qs_width").mask) >> m_regs.at("qs_width").bit_low);
//#ifdef DEBUG
//    LOG(Log::INF) << log_i(lbl.c_str()," Qswitch width (clocks) :") << width;
//#endif
    m_qswitch_width = width;
    // convert to floating point
    uint32_t width_us = conv_to_us(width);
//#ifdef DEBUG
//    LOG(Log::INF) << log_i(lbl.c_str()," QSwitch width (us) :") << width_us;
//#endif
    getAddressSpaceLink()->setQswitch_width_us(width_us, OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::set_fire_width(const uint32_t v,json &resp)
  {
    // this method should *NEVER* be called before the connection to the CIB is established
    UaStatus st = check_cib_mem(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    // convert the value into a 16 ns clock number
    // the set unit is us
    uint32_t v_clock= conv_to_clock(v);
    // -- otherwise, set the memory region in the register, and the local cache variable too
    cib::util::reg_write_mask_offset(m_regs.at("fire_width").addr,
                                     v_clock,
                                     m_regs.at("fire_width").mask,
                                     m_regs.at("fire_width").bit_low);
    m_fire_width = v_clock;
    getAddressSpaceLink()->setFire_width_us(conv_to_us(m_fire_width), OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::get_fire_width(uint32_t &v,json &resp)
  {
    UaStatus st = check_cib_mem(resp);
    const std::string lbl = "get_fire_width";
    if (st != OpcUa_Good)
    {
      getAddressSpaceLink()->setFire_width_us(m_fire_width, OpcUa_BadCommunicationError);
      return st;
    }
    // get the value from the register
    uint32_t rval = cib::util::reg_read(m_regs.at("fire_width").addr);
    // now extract the width from the register value
    uint32_t width = ((rval & m_regs.at("fire_width").mask) >> m_regs.at("fire_width").bit_low);
//#ifdef DEBUG
//    LOG(Log::INF) << log_i(lbl.c_str()," Fire width (clocks) :") << width;
//#endif
    m_fire_width = width;
    // convert to floating point
    uint32_t width_us = conv_to_us(width);
//#ifdef DEBUG
//    LOG(Log::INF) << log_i(lbl.c_str()," Fire width (us) :") << width_us;
//#endif
    getAddressSpaceLink()->setFire_width_us(width_us, OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::get_ext_shutter_state(bool &open,json &resp)
  {
    UaStatus st = check_cib_mem(resp);
    const std::string lbl = "get_ext_shutter_state";
    if (st != OpcUa_Good)
    {
      getAddressSpaceLink()->setExt_shutter_open(!m_part_state.state.ext_shutter_closed, OpcUa_BadCommunicationError);
      return st;
    }
    // refresh the state that is in the register
    bool sopen;
    get_ext_shutter(sopen);
    open = sopen;
    m_part_state.state.ext_shutter_closed = !sopen;
    getAddressSpaceLink()->setExt_shutter_open(sopen, OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::resume(json &resp)
  {
    // resume should only be called if we are in either sPause or sStandby states
    // anything else should use a different method
    // also, check that the memory is mapped on the CIB
    std::ostringstream msg("");
    const std::string lbl = "resume";
    UaStatus st = OpcUa_Good;
    st = check_cib_mem(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    st = check_laser_instance(resp);
    if(st != OpcUa_Good)
    {
      return st;
    }
    // check that we are in a valid state for this call
    if ((m_status != sPause) && (m_status != sStandby))
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Laser Unit not in a valid state. Resume should only be called in sPause or sStandby state.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_Good;
    }
    // -- do a couple moreconsistent checks
    if (!m_part_state.state.fire_enable)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Inconsistent state. Laser Unit is not firing.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_Good;
    }
    // FIXME:We may want to specifically force the state of the parameters
    // now start the proper work
    // the logic is slightly different whether we are coming out of sPause
    // or sStandby states
    if (m_status == sPause)
    {
      // if we are in pause, all we should do is reopen the shutter
      st = force_ext_shutter(ShutterState::sOpen,resp);
    }
    if (m_status == sStandby)
    {
      // if we are on standby, the order is a bit different.
      st = switch_laser_shutter(ShutterState::sOpen,resp);
    }
    if (st != OpcUa_Good)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed to resume laser. See previous messages");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i(lbl.c_str(),"Laser unit resumed operation.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "SUCCESS";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    update_status(sLasing);
    return st;
  }
  uint32_t DIoLLaserUnit::cib_get_shot_count()
  {
    return 0;
    // not implemented yet.
    //    return cib::util::reg_read(m_regs.at("shot_count").addr);
  }
  void DIoLLaserUnit::set_fire(const uint32_t s)
  {
#ifdef DEBUG
    LOG(Log::INF) << log_i("set_fire","Setting to ") << s << " (addr,mask,offset)=[0x"
        << std::hex << m_regs.at("fire_state").addr << " " << m_regs.at("fire_state").mask << std::dec
        << " " << m_regs.at("fire_state").bit_low;
#endif
    cib::util::reg_write_mask_offset(m_regs.at("fire_state").addr,
                                     s,
                                     m_regs.at("fire_state").mask,
                                     m_regs.at("fire_state").bit_low);
    m_part_state.state.fire_enable = (s!=0x0);
    getAddressSpaceLink()->setFire_active(m_part_state.state.fire_enable,OpcUa_Good);
  }
  void DIoLLaserUnit::get_fire(uint32_t &s)
  {
    uint32_t reg = cib::util::reg_read(m_regs.at("fire_state").addr);
    s = ((reg & m_regs.at("fire_state").mask) >> m_regs.at("fire_state").bit_low);
    m_part_state.state.fire_enable = (s!=0x0);
    getAddressSpaceLink()->setFire_active(m_part_state.state.fire_enable,OpcUa_Good);
  }
  void DIoLLaserUnit::set_qswitch(const uint32_t s)
  {

#ifdef DEBUG
    LOG(Log::INF) << log_i("set_qswitch","Setting to ") << s << " (addr,mask,offset)=[0x"
        << std::hex << m_regs.at("fire_state").addr << " " << m_regs.at("fire_state").mask << std::dec
        << " " << m_regs.at("fire_state").bit_low;
#endif
    cib::util::reg_write_mask_offset(m_regs.at("qs_state").addr,
                                     s,
                                     m_regs.at("qs_state").mask,
                                     m_regs.at("qs_state").bit_low);
    m_part_state.state.qswitch_enable = (s!=0x0);
    getAddressSpaceLink()->setQswitch_active(m_part_state.state.qswitch_enable,OpcUa_Good);
  }
  void DIoLLaserUnit::get_qswitch(uint32_t &s)
  {
    uint32_t reg = cib::util::reg_read(m_regs.at("qs_state").addr);
    s = ((reg & m_regs.at("qs_state").mask) >> m_regs.at("qs_state").bit_low);
    m_part_state.state.qswitch_enable = (s!=0x0);
    getAddressSpaceLink()->setQswitch_active(m_part_state.state.qswitch_enable,OpcUa_Good);
  }
  void DIoLLaserUnit::set_ext_shutter(const uint32_t s)
  {
#ifdef DEBUG
    LOG(Log::INF) << log_i("set_ext_shutter","Setting to ") << s << " (addr,mask,offset)=[0x"
        << std::hex << m_regs.at("fire_state").addr << " " << m_regs.at("fire_state").mask << std::dec
        << " " << m_regs.at("fire_state").bit_low;
#endif
    // we want to close and it wasn't yet
    cib::util::reg_write_mask_offset(m_regs.at("force_shutter").addr,
                                     s,
                                     m_regs.at("force_shutter").mask,
                                     m_regs.at("force_shutter").bit_low);
    m_part_state.state.ext_shutter_closed = (s!=0x0);
    getAddressSpaceLink()->setExt_shutter_open((s==0x0),OpcUa_Good);
  }
  void DIoLLaserUnit::get_ext_shutter(bool &open)
  {
    uint32_t rval = cib::util::reg_read(m_regs.at("force_shutter").addr);
    uint32_t state = ((rval & m_regs.at("force_shutter").mask) >> m_regs.at("force_shutter").bit_low);
    open = (state == 0);
    m_part_state.state.ext_shutter_closed = (state!=0x0);

  }

  void DIoLLaserUnit::enable_fire()
  {
    set_fire(0x1);
  }
  void DIoLLaserUnit::disable_fire()
  {
    set_fire(0x0);
  }
  void DIoLLaserUnit::enable_qswitch()
  {
    set_qswitch(0x1);
  }
  void DIoLLaserUnit::disable_qswitch()
  {
    set_qswitch(0x0);
  }
  void DIoLLaserUnit::close_ext_shutter()
  {
    set_ext_shutter(0x1);
  }
  void DIoLLaserUnit::open_ext_shutter()
  {
    set_ext_shutter(0x0);
  }
  //
  UaStatus DIoLLaserUnit::close_shutter(json &resp)
  {
    const std::string lbl = "close_shutter";
    std::ostringstream msg("");
    bool got_exception = false;
    UaStatus st = OpcUa_Good;
    try
    {
      const std::lock_guard<std::mutex> lock(m_serial_mutex);
      st = check_laser_instance(resp);
      if (st != OpcUa_Good)
      {
        return st;
      }
      m_laser->shutter_close();
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str()," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"]= OpcUa_BadCommunicationError;
      return OpcUa_BadCommunicationError;
    }
    m_part_state.state.laser_shutter_closed = true;
    getAddressSpaceLink()->setLaser_shutter_open(false,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::open_shutter(json &resp)
  {
    const std::string lbl = "open_shutter";
    std::ostringstream msg("");
    bool got_exception = false;
    UaStatus st = OpcUa_Good;
    try
    {
      const std::lock_guard<std::mutex> lock(m_serial_mutex);
      st = check_laser_instance(resp);
      if (st != OpcUa_Good)
      {
        return st;
      }
      m_laser->shutter_open();
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str()," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"]= OpcUa_BadCommunicationError;
      return OpcUa_BadCommunicationError;
    }
    m_part_state.state.laser_shutter_closed = false;
    getAddressSpaceLink()->setLaser_shutter_open(true,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::start_fire(json &resp)
  {
    const std::string desc = "start_fire";
    std::ostringstream msg("");
    bool got_exception = false;
    UaStatus st = OpcUa_Good;
    try
    {
      const std::lock_guard<std::mutex> lock(m_serial_mutex);
      st = check_laser_instance(resp);
      if (st != OpcUa_Good)
      {
        return st;
      }
      m_laser->fire_start();
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(desc.c_str()," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(desc.c_str(),"Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(desc.c_str(),"Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(desc.c_str(),"Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"]= OpcUa_BadCommunicationError;
      return OpcUa_BadCommunicationError;
    }
    getAddressSpaceLink()->setLaser_shutter_open(true,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::stop_fire(json &resp)
  {
    const std::string desc = "stop_fire";
    std::ostringstream msg("");
    bool got_exception = false;
    UaStatus st = OpcUa_Good;
    try
    {
      const std::lock_guard<std::mutex> lock(m_serial_mutex);
      st = check_laser_instance(resp);
      if (st != OpcUa_Good)
      {
        return st;
      }
      m_laser->fire_stop();
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(desc.c_str()," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(desc.c_str(),"Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(desc.c_str(),"Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(desc.c_str(),"Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"]= OpcUa_BadCommunicationError;
      return OpcUa_BadCommunicationError;
    }
    getAddressSpaceLink()->setLaser_shutter_open(true,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLLaserUnit::laser_security(uint16_t &code, std::string &desc,json &resp)
  {
    const std::string lbl = "security";
    std::ostringstream msg("");
    bool got_exception = false;
    UaStatus st = OpcUa_Good;
    try
    {
      const std::lock_guard<std::mutex> lock(m_serial_mutex);
      st = check_laser_instance(resp);
      if (st != OpcUa_Good)
      {
        return st;
      }
      m_laser->security(code,desc);
    }
    catch(serial::PortNotOpenedException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str()," ") << "Port not open [" << e.what() << "]";
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with a Serial exception :") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an STL exception :") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Failed with an unknown exception.");
      got_exception = true;
    }
    if (got_exception)
    {
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"]= OpcUa_BadCommunicationError;
      return OpcUa_BadCommunicationError;
    }
    getAddressSpaceLink()->setLaser_status_code(code,OpcUa_Good);
    return OpcUa_Good;
  }

  UaStatus DIoLLaserUnit::check_error_state(json &resp)
  {
    const std::string lbl = "check_error";
    if (m_status == sError)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"System in error state. Nothing can be done.");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
    }
    else
    {
      return OpcUa_Good;
    }
  }
  UaStatus DIoLLaserUnit::check_not_offline_state(json &resp)
  {
    const std::string lbl = "check_not_offline";
    if (m_status != sOffline)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Unit is not offline. Before configuring, you should shut it down (call terminate).");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
    }
    else
    {
      return OpcUa_Good;
    }
  }
  UaStatus DIoLLaserUnit::check_offline_state(json &resp)
  {
    const std::string lbl = "check_offline";
    if (m_status == sOffline)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Laser is offline. No operation possible.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_Bad;
    }
    else
    {
      return OpcUa_Good;
    }
  }
  UaStatus DIoLLaserUnit::check_cib_mem(json &resp)
  {
    const std::string lbl = "check_cib";
    if (m_reg_map.size() == 0x0)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"CIB memory not mapped. System on lockdown.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      update_status(sError);
      return OpcUa_BadInvalidState;
    }
    else
    {
      return OpcUa_Good;
    }
  }
  UaStatus DIoLLaserUnit::check_laser_instance(json &resp)
  {
    const std::string lbl = "check_laser";
    if (!m_laser)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"There is no connection to the laser. Doing nothing.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_Bad;
    }
    else
    {
      return OpcUa_Good;
    }
  }
  UaStatus DIoLLaserUnit::check_ready_state(json &resp)
  {
    const std::string lbl = "check_ready";
    if (m_status != sReady)
     {
      std::ostringstream msg("");
       msg.clear(); msg.str("");
       msg << log_e(lbl.c_str()," ") << "Laser is not in ready state. Current state :" << m_status_map.at(m_status);
       resp["messages"].push_back(msg.str());
#ifdef DEBUG
       LOG(Log::ERR) << msg.str();
#endif
       return OpcUa_BadInvalidState;
     }
    else
    {
      return OpcUa_Good;
    }
  }
  void DIoLLaserUnit::cib_init_mem()
  {
    // force clear anything in the map
    if (m_reg_map.size() != 0)
    {
      cib_free_mem();
    }
    // -- there are several registers to be mapped:
    cib_reg_t tmpreg;
    tmpreg.id = LASER_REG;
    tmpreg.paddr = GPIO_LASER_MEM_LOW;
    tmpreg.size = 0xFFF;
    tmpreg.vaddr = cib::util::map_phys_mem(m_mmap_fd,GPIO_LASER_MEM_LOW,GPIO_LASER_MEM_HIGH);
    if (tmpreg.vaddr == 0x0)
    {
      LOG(Log::ERR) << "\n\nDIoLLaserUnit::DIoLLaserUnit : Failed to map LASER CIB memory region. This is going to fail spectacularly!!!\n\n";
    }
    m_reg_map[LASER_REG] = tmpreg;
#ifdef DEBUG
    LOG(Log::INF) << "\n\nDIoLLaserUnit::DIoLLaserUnit : LASER_REG mapped to " << std::hex << m_reg_map.at(LASER_REG).vaddr << std::dec;
#endif
    tmpreg.id= MISC_REG;
    tmpreg.paddr = GPIO_MISC_MEM_LOW;
    tmpreg.size = 0xFFF;
    tmpreg.vaddr = cib::util::map_phys_mem(m_mmap_fd,GPIO_MISC_MEM_LOW,GPIO_MISC_MEM_HIGH);
    if (tmpreg.vaddr == 0x0)
    {
      LOG(Log::ERR) << "\n\nDIoLLaserUnit::DIoLLaserUnit : Failed to map ALIGN CIB memory region. This is going to fail spectacularly!!!\n\n";
    }
    m_reg_map[MISC_REG] = tmpreg;
#ifdef DEBUG
    LOG(Log::INF) << "\n\nDIoLLaserUnit::DIoLLaserUnit : MISC_REG mapped to " << std::hex << m_reg_map.at(MISC_REG).vaddr << std::dec;
#endif
    tmpreg.id= ALIGN_REG;
    tmpreg.paddr = GPIO_ALIGN_MEM_LOW;
    tmpreg.size = 0xFFF;
    tmpreg.vaddr = cib::util::map_phys_mem(m_mmap_fd,GPIO_ALIGN_MEM_LOW,GPIO_ALIGN_MEM_HIGH);
    if (tmpreg.vaddr == 0x0)
    {
      LOG(Log::ERR) << "\n\nDIoLLaserUnit::DIoLLaserUnit : Failed to map ALIGN CIB memory region. This is going to fail spectacularly!!!\n\n";
    }
    m_reg_map[ALIGN_REG] = tmpreg;
#ifdef DEBUG
    LOG(Log::INF) << "\n\nDIoLLaserUnit::DIoLLaserUnit : ALIGN_REG mapped to " << std::hex << m_reg_map.at(ALIGN_REG).vaddr << std::dec;
#endif
    if (m_reg_map.size() != 3)
    {
      LOG(Log::ERR) << "\n\nDIoLLaserUnit::DIoLLaserUnit : Failed to map oneor more CIB memory regionss. This is going to fail spectacularly!!!\n\n";
      m_status = sError;
    }
  }
  void DIoLLaserUnit::cib_free_mem()
  {
    // clear up the memory for the CIB
    LOG(Log::INF) << "\n\nDIoLLaserUnit::DIoLLaserUnit : Unammping CIB memory regions.";

    for (auto entry: m_reg_map)
    {
#ifdef DEBUG
      LOG(Log::INF) << "\n\nDIoLLaserUnit::DIoLLaserUnit : Clearing CIB memory [" << entry.first << "\n";
#endif
      cib::util::unmap_mem(entry.second.vaddr,entry.second.size);
    }
    close(m_mmap_fd);

  }
} // namespace
