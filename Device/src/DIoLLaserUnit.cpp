
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.

    The stub of this file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.


 */


#include <Configuration.hxx> // TODO; should go away, is already in Base class for ages

#include <DIoLLaserUnit.h>
#include <ASIoLLaserUnit.h>
#include <utilities.hh>
#include <Laser.hh>
#include <string>
#include <sstream>
#include <thread>
#include <chrono>
using json = nlohmann::json;
//
#define log_msg(s,met,msg) "[" << s << "]::" << met << " : " << msg
//
#define log_e(m,s) log_msg("ERROR",m,s)
#define log_w(m,s) log_msg("WARN",m,s)
#define log_i(m,s) log_msg("INFO",m,s)
//
using std::ostringstream;
using std::map;
using std::string;
//
namespace Device
{
// 1111111111111111111111111111111111111111111111111111111111111111111111111
// 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
// 1     Users don't modify this code!!!!                                  1
// 1     If you modify this code you may start a fire or a flood somewhere,1
// 1     and some human being may possible cease to exist. You don't want  1
// 1     to be charged with that!                                          1
// 1111111111111111111111111111111111111111111111111111111111111111111111111






// 2222222222222222222222222222222222222222222222222222222222222222222222222
// 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
// 2     (code for which only stubs were generated automatically)          2
// 2     You should add the implementation but dont alter the headers      2
// 2     (apart from constructor, in which you should complete initializati2
// 2     on list)                                                          2
// 2222222222222222222222222222222222222222222222222222222222222222222222222

/* sample ctr */
DIoLLaserUnit::DIoLLaserUnit (
    const Configuration::IoLLaserUnit& config,
    Parent_DIoLLaserUnit* parent
):
    Base_DIoLLaserUnit( config, parent)

    /* fill up constructor initialization list here */
	,m_is_ready(false)
	,m_status(sOffline)
	,m_laser(nullptr)
	,m_divider(0)
	//FIXME: What is the pump HV default?
  ,m_pump_hv(0.0)
  ,m_rate_hz(10.0)
  ,m_qswitch(200)
  ,m_shutter_open(false)
  ,m_shot_count(0)
  ,m_comport("auto")
  ,m_baud_rate(9600)
  ,m_count_flashes(false)
  ,m_name("")
{
  /* fill up constructor body here */
  m_name = config.name();
  LOG(Log::INF) << "DIoLLaserUnit::DIoLLaserUnit : Building instance of  [" << m_name << "]";

  // set the variables that are configuration parameters
  m_comport = port();
  LOG(Log::INF) << "DIoLLaserUnit::DIoLLaserUnit : Port set to [" << m_comport << "]";
  if (m_comport == "auto")
  {
    LOG(Log::WRN) << "DIoLLaserUnit::DIoLLaserUnit : Attempting automatic port detection based off serial number [" << serial_number() << "]";
    automatic_port_search();
  }

  // -- initialize the status map
  m_status_map.insert({sOffline,"offline"});
  m_status_map.insert({sInit,"init"});
  m_status_map.insert({sReady,"ready"});
  m_status_map.insert({sLasing,"lasing"});

  // try to initialize the system with the defaults
  m_config.word.init(0x0);
  json resp;
  init_device(resp);

}

/* sample dtr */
DIoLLaserUnit::~DIoLLaserUnit ()
{
  if (m_laser) delete m_laser;
}

/* delegates for cachevariables */

/* Note: never directly call this function. */

UaStatus DIoLLaserUnit::writeQswitch_us ( const OpcUa_UInt32& v)
{
  LOG(Log::INF) << "Setting QSwitch";
  std::ostringstream msg;
  // we need the system to be at least in unconfigured state
  // as we need the device connection to be established
  if (m_status == sOffline)
  {
    return OpcUa_BadInvalidState;
  }
  if (!m_laser)
  {
    return OpcUa_BadInvalidState;
  }
  json resp;
  return write_qswitch(static_cast<uint16_t>(v & 0xFFFF), resp);
}
/* Note: never directly call this function. */

UaStatus DIoLLaserUnit::writeDischarge_voltage_kV ( const OpcUa_Float& v)
{
  LOG(Log::INF) << "Setting discharge voltage to " << v;
  std::ostringstream msg;
  // we need the system to be at least in unconfigured state
  // as we need the device connection to be established
  if (m_status == sOffline)
  {
    return OpcUa_BadInvalidState;
  }
  if (!m_laser)
  {
    return OpcUa_BadInvalidState;
  }
  json resp;
  return write_hv(v,resp);

}
/* Note: never directly call this function. */

UaStatus DIoLLaserUnit::writeRep_rate_hz ( const OpcUa_Double& v)
{
  LOG(Log::INF) << "Setting Repetition rate";
  std::ostringstream msg;
  // we need the system to be at least in unconfigured state
  // as we need the device connection to be established
  if (m_status == sOffline)
  {
    return OpcUa_BadInvalidState;
  }
  if (!m_laser)
  {
    return OpcUa_BadInvalidState;
  }
  json resp;
  return write_rate(v,resp);
}
/* Note: never directly call this function. */

UaStatus DIoLLaserUnit::writeRep_rate_divider ( const OpcUa_UInt16& v)
{
  LOG(Log::INF) << "Setting Rate Divider / Prescale to " << v;
  // we need the system to be at least in unconfigured state
  // as we need the device connection to be established
  if (m_status == sOffline)
  {
    return OpcUa_BadInvalidState;
  }
  if (!m_laser)
  {
    return OpcUa_BadInvalidState;
  }
  json resp;
  return write_divider(v,resp);
  // we don't really care for the responses in this case
  // just whether it went well or not
}
/* Note: never directly call this function. */

UaStatus DIoLLaserUnit::writeExt_shutter_time_pre_shot ( const OpcUa_UInt32& v)
{
    // FIXME : Implement this in CIB register
    return OpcUa_BadNotImplemented;
}
/* Note: never directly call this function. */

UaStatus DIoLLaserUnit::writeExt_shutter_open_time_us ( const OpcUa_UInt32& v)
{
  // FIXME : Implement this in CIB register
    return OpcUa_BadNotImplemented;
}


/* delegators for methods */
UaStatus DIoLLaserUnit::callSet_port (
    const UaString&  device_port,
    UaString& response
)
{
  if (m_laser)
  {
    // laser is already connected. One should not change the port
    return OpcUa_BadInvalidState;
  }
  // otherwise, it is fair game. Set and try to connect
  m_comport = device_port.toUtf8();
  getAddressSpaceLink()->setDevice_port(device_port,OpcUa_Good);
  json resp;
  init_device(resp);
  response = UaString(resp.dump().c_str());
  // check if we have everything to init?
  return OpcUa_Good;
}
UaStatus DIoLLaserUnit::callStop (
    UaString& response
)
{
  bool got_exception = false;
  std::ostringstream msg("");
  json resp;
  // force a stop on the laser firing
  // start by closing hte shutter, and
  // since this is a usually kind of critical method, do not even care to check whether the
  // laser is firing or not, just stop and close the shutter
  if (!m_laser)
  {
    msg.clear(); msg.str("");
    msg << log_w("stop","There is no connection to the laser. Doing nothing.");
    LOG(Log::WRN) << msg.str();
    resp["status"] = "ERROR";
    resp["messages"].push_back(msg.str());
    resp["status_code"] = OpcUa_Bad;
    return OpcUa_Good;
  }

  try
  {
    m_laser->fire_stop();
    m_laser->shutter_close();
    // downgrade anything above ready to ready to operate
    // states below remain as they are
    if (m_status > sReady)
    {
      m_status = sReady;
    }
    // requery the laser system for its present status, in case there are issues to report
    refresh_status();
  }
  catch(serial::PortNotOpenedException &e)
  {
    msg.clear(); msg.str("");
    msg << log_e("stop"," ") << "Port not open [" << e.what() << "]";
    got_exception = true;
  }
  catch(serial::SerialException &e)
  {
    msg.clear(); msg.str("");
    msg << log_e("stop","Failed with a Serial exception :") << e.what();
    got_exception = true;
  }
  catch(std::exception &e)
  {
    msg.clear(); msg.str("");
    msg << log_e("stop","Failed with an STL exception :") << e.what();
    got_exception = true;
  }
  catch(...)
  {
    msg.clear(); msg.str("");
    msg << log_e("stop","Failed with an unknown exception.");
    got_exception = true;
  }
  if (got_exception)
  {
    LOG(Log::ERR) << msg.str();
    resp["status"] = "ERROR";
    resp["messages"].push_back(msg.str());
    resp["status_code"] = OpcUa_Bad;
    return OpcUa_Good;
  }

  resp["status"] = "OK";
  msg.clear(); msg.str("");
  msg << log_i("stop","Laser stopped.");
  resp["messages"].push_back(msg.str());
  resp["status_code"] = OpcUa_Good;

  return OpcUa_Good;
}
UaStatus DIoLLaserUnit::callCheck_status (
    OpcUa_UInt16& status,
    UaString& description
)
{
  std::ostringstream msg("");
  bool got_exception = false;
   // force a stop on the laser firing
   // start by closing hte shutter, and
   // since this is a usually kind of critical method, do not even care to check whether the
   // laser is firing or not, just stop and close the shutter
   if (!m_laser)
   {
     status = 99;
     msg << log_e("status","There is no connection to the laser.");
     description = UaString(msg.str().c_str());
     getAddressSpaceLink()->setStatus_code(status,OpcUa_BadInvalidState);

     return OpcUa_Good;
   }
   //
   try
   {
     std::string desc;

     m_laser->security(status, desc);
     description = UaString(desc.c_str());
     getAddressSpaceLink()->setStatus_code(status,OpcUa_Good);
   }
   catch(serial::PortNotOpenedException &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("status"," ") << "Port not open [" << e.what() << "]";
     got_exception = true;
   }
   catch(serial::SerialException &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("status","Failed with a Serial exception :") << e.what();
     got_exception = true;
   }
   catch(std::exception &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("status","Failed with an STL exception :") << e.what();
     got_exception = true;
   }
   catch(...)
   {
     msg.clear(); msg.str("");
     msg << log_e("status","Failed with an unknown exception.");
     got_exception = true;
   }
   if (got_exception)
   {
     status = 98;
     LOG(Log::ERR) << msg.str();
     description = UaString(msg.str().c_str());
     getAddressSpaceLink()->setStatus_code(status,OpcUa_BadCommunicationError);
     return OpcUa_Good;
   }
   //
   return OpcUa_Good;
   //
}
UaStatus DIoLLaserUnit::callConfigure_laser (
    const UaString&  config,
    UaString& response
)
{
  // FIXME: Implement the json interpretation
  // the input string is meant to be a json structure with all the settings
    // confirm that the configuration fragment is indeed for this object
  std::ostringstream msg("");
  bool got_exception = false;
  json resp;
  try
  {
    json conf = json::parse(config.toUtf8());
    if (conf.at("name").get<std::string>() != m_name)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Mismatch between name in object and configuration fragment :")
          << " (" << conf.at("name").get<std::string>() <<" <> " << m_name << ")";
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidArgument;
      response = UaString(resp.dump().c_str());
      return OpcUa_Good;
    }
    // if it is valid, iterate over all keys
    // if the ids match, lets set the parameters
    // special iterator member functions for objects
    for (json::iterator it = conf.begin(); it != conf.end(); ++it)
    {
      LOG(Log::INF) << "Processing " << it.key() << " : " << it.value() << "\n";
      if (it.key() == "port")
      {
        // if we
        if (m_laser)
        {
          // we are trying to set the port with an active laser connection
          // if the ports are not the same,
          // send a warning, close the connection and reopen it
          if (m_comport != it.value())
          {
            msg.clear(); msg.str("");
            msg << log_w("config","Different port in configuration. Resetting connection from ") << m_comport << " to " << it.value();
            resp["messages"].push_back(msg.str());
            m_status = sOffline;
            delete m_laser;
          }
        }
        else if (it.value() == "auto")
        {
          // this is kind of silly, we go from something already set
          // into something automatic...all over again
          msg.clear(); msg.str("");
          msg << log_w("config","Performing automatic search for port");
          resp["messages"].push_back(msg.str());
          automatic_port_search();
        }
        else
        {
          // the value seems valid
          m_comport = it.value();
        }
        getAddressSpaceLink()->setDevice_port(UaString(m_comport.c_str()),m_comport.size(),OpcUa_Good);
      }
      if (it.key() == "repetition_rate")
      {
        m_rate_hz = it.value();
        getAddressSpaceLink()->setRep_rate_hz(m_rate_hz, OpcUa_Good);
      }
      if (it.key() == "repetition_rate_divider")
      {
        m_divider = it.value();
        getAddressSpaceLink()->setRep_rate_divider(m_divider,OpcUa_Good);
      }
      if (it.key() == "qswitch")
      {
        m_qswitch = it.value();
        getAddressSpaceLink()->setQswitch_us(m_qswitch, OpcUa_Good);
      }
      if (it.key() == "discharge_voltage")
      {
        m_pump_hv = it.value();
        getAddressSpaceLink()->setDischarge_voltage_kV(m_pump_hv, OpcUa_Good);
      }
      if (it.key() == "external_shutter")
      {
        //FIXME: Implement me
        continue;
      }
    }
    // now that configuration has been loaded, init the system
    init_device(resp);
  }
  catch(json::exception &e)
  {
    msg.clear(); msg.str("");
    msg << log_e("config","Caught JSON exception : ") << e.what();
    got_exception = true;
  }
  catch(std::exception &e)
  {
    msg.clear(); msg.str("");
    msg << log_e("config","Caught JSON exception : ") << e.what();
    got_exception = true;
  }
  catch(...)
  {
    msg.clear(); msg.str("");
    msg << log_e("config","Caught an unknown exception");
    got_exception = true;
  }
  if (got_exception)
  {
    resp["status"] = "ERROR";
    resp["messages"].push_back(msg.str());
    resp["status_code"] = OpcUa_Bad;
    response = UaString(resp.dump().c_str());
  }
  else
  {
    msg.clear(); msg.str("");
    msg << log_i("config","System configured");
    resp["status"] = "OK";
    resp["messages"].push_back(msg.str());
    resp["status_code"] = OpcUa_Good;
    response = UaString(resp.dump().c_str());
  }
  return OpcUa_Good;
}
UaStatus DIoLLaserUnit::callSingle_shot (
    UaString& response
)
{
  std::ostringstream msg("");
  json resp;
  bool caught_exception = false;
  if (!m_laser)
   {
     msg.clear(); msg.str("");
     msg << log_e("single_shot","There is no connection to the laser. Doing nothing.");
     LOG(Log::ERR) << msg.str();
     resp["status"] = "ERROR";
     resp["messages"].push_back(msg.str());
     resp["status_code"] = OpcUa_BadInvalidState;
     response = UaString(resp.dump().c_str());
     return OpcUa_Good;
   }
  // if the laser is not in the sReady state, also do nothing
  // likely some parameter is not set yet
  // also fail if the laser is firing
  if (m_status != sReady)
  {
    msg.clear(); msg.str("");
    msg << log_e("single_shot","The laser is in the wrong state") << " (expected " << static_cast<uint16_t>(sReady) << " have " << static_cast<uint16_t>(m_status) << ")";
    LOG(Log::ERR) << msg.str();
    resp["status"] = "ERROR";
    resp["messages"].push_back(msg.str());
    resp["status_code"] = OpcUa_BadInvalidState;
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }

  // if the shutter is not open, there is no point in firing
  //
  if (!m_shutter_open)
  {
    msg.clear(); msg.str("");
    msg << log_e("single_shot","The laser shutter is not open");
    LOG(Log::ERR) << msg.str();
    resp["status"] = "ERROR";
    resp["messages"].push_back(msg.str());
    resp["status_code"] = OpcUa_BadInvalidState;
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }
  // everything seems ready. Fire away
   try
   {
     // FIXME: This logic is not doing anything about the external shutter
     // once the external shutter is in place, one should actually stop using this command and instead
     // drive a single shot from the CIB (so that the external shutter is also timely opened)
     m_status = sLasing;
     // FIXME: If the operational status is propagated to the address space, we need to update it here
     m_laser->single_shot(true); // ensure that the prescale is rescaled
     m_status = sReady;
     // FIXME: The operation status should perhaps be reported back to SC
     //getAddressSpaceLink()->setStatus_code(status,OpcUa_Good);
   }
   catch(serial::PortNotOpenedException &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("single_shot"," ") << "Port not open [" << e.what() << "]";
     caught_exception = true;
   }
   catch(serial::SerialException &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("single_shot","Failed with a Serial exception :") << e.what();
     caught_exception = true;
   }
   catch(std::exception &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("single_shot","Failed with an STL exception :") << e.what();
     caught_exception = true;
   }
   catch(...)
   {
     msg.clear(); msg.str("");
     msg << log_e("single_shot","Failed with an unknown exception.");
     caught_exception = true;
   }
   if (caught_exception)
   {
     LOG(Log::ERR) << msg.str();
     resp["status"] = "ERROR";
     resp["messages"].push_back(msg.str());
     resp["status_code"] = OpcUa_Bad;
     response = UaString(resp.dump().c_str());
   }
   else {
     // all was good
     msg.clear(); msg.str("");
     msg << log_i("single_shot","Laser single shot fired");
     LOG(Log::INF) << msg.str();
     resp["status"] = "OK";
     resp["messages"].push_back(msg.str());
     resp["status_code"] = OpcUa_Good;
   }
   return OpcUa_Good;
}
UaStatus DIoLLaserUnit::callSwitch_shutter (
    OpcUa_Boolean open,
    UaString& response
)
{
  std::ostringstream msg("");
  json resp;
  bool caught_exception = false;
  if (!m_laser)
   {
     msg.clear(); msg.str("");
     msg << log_e("shutter","There is no connection to the laser. Doing nothing.");
     LOG(Log::ERR) << msg.str();
     resp["status"] = "ERROR";
     resp["messages"].push_back(msg.str());
     resp["status_code"] = OpcUa_BadInvalidState;
     response = UaString(resp.dump().c_str());
     return OpcUa_Good;
   }
  // if the laser is not in the sReady state, also do nothing
  // likely some parameter is not set yet
  // also fail if the laser is firing
  if (m_status != sReady)
  {
    msg.clear(); msg.str("");
    msg << log_e("shutter","The laser is in the wrong state") << " (expected " << static_cast<uint16_t>(sReady) << " have " << static_cast<uint16_t>(m_status) << ")";
    LOG(Log::ERR) << msg.str();
    resp["status"] = "ERROR";
    resp["messages"].push_back(msg.str());
    resp["status_code"] = OpcUa_BadInvalidState;
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }
  // everything seems ready. open the shutter
  try
   {
     m_laser->shutter(static_cast<device::Laser::Shutter>(open));
     m_shutter_open = open;
     getAddressSpaceLink()->setLaser_shutter_open(m_shutter_open, OpcUa_Good);
     // FIXME: We may need another state in the state machine for open shutter
   }
   catch(serial::PortNotOpenedException &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("shutter"," ") << "Port not open [" << e.what() << "]";
     caught_exception = true;
   }
   catch(serial::SerialException &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("shutter","Failed with a Serial exception :") << e.what();
     caught_exception = true;
   }
   catch(std::exception &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("shutter","Failed with an STL exception :") << e.what();
     caught_exception = true;
   }
   catch(...)
   {
     msg.clear(); msg.str("");
     msg << log_e("shutter","Failed with an unknown exception.");
     caught_exception = true;
   }
   if (caught_exception)
   {
     LOG(Log::ERR) << msg.str();
     resp["status"] = "ERROR";
     resp["messages"].push_back(msg.str());
     resp["status_code"] = OpcUa_Bad;
     response = UaString(resp.dump().c_str());
   }
   else {
     // all was good
     msg.clear(); msg.str("");
     msg << log_i("shutter","Shutter open");
     LOG(Log::INF) << msg.str();
     resp["status"] = "OK";
     resp["messages"].push_back(msg.str());
     resp["status_code"] = OpcUa_Good;
   }
   return OpcUa_Good;
}
UaStatus DIoLLaserUnit::callFire_standalone (
    OpcUa_Boolean fire,
    UaString& response
)
{
  // FIXME: Note that this method does not do anything about the external shutter
  // it assumes that the external shutter is either not in place or has been in some other way operated to open
  // for these shots
  // ultimately, this is just meant to be used in commissioning. For normal operation
  // one will use the CIB directly to control the laser firing
  std::ostringstream msg("");
  json resp;
  bool caught_exception = false;
  if (!m_laser)
   {
     msg.clear(); msg.str("");
     msg << log_e("fire","There is no connection to the laser. Doing nothing.");
     LOG(Log::ERR) << msg.str();
     resp["status"] = "ERROR";
     resp["messages"].push_back(msg.str());
     resp["status_code"] = OpcUa_BadInvalidState;
     response = UaString(resp.dump().c_str());
     return OpcUa_Good;
   }
  // if the shutter is not open, there is no point in firing
  //
  if (!m_shutter_open)
  {
    msg.clear(); msg.str("");
    msg << log_e("fire","The laser shutter is not open");
    LOG(Log::ERR) << msg.str();
    resp["status"] = "ERROR";
    resp["messages"].push_back(msg.str());
    resp["status_code"] = OpcUa_BadInvalidState;
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }

  // if the laser is not in the sReady state, also do nothing
  // likely some parameter is not set yet
  // also fail if the laser is firing
  // if the laser is firing, calling it again should fail
  // this logic is a bit more complicated
  // since it depends on the tuple (status,fire)
  // sReady && true : OK
  // sLasing && false : OK
  // others : Fail
  if (!(((m_status == sReady) && fire) || (m_status == sLasing && !fire)))
  {
    msg.clear(); msg.str("");
    msg << log_e("fire","The laser is in the wrong state") << " (expected " << static_cast<uint16_t>(sReady) << " have " << static_cast<uint16_t>(m_status) << ")";
    LOG(Log::ERR) << msg.str();
    resp["status"] = "ERROR";
    resp["messages"].push_back(msg.str());
    resp["status_code"] = OpcUa_BadInvalidState;
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }

  // everything seems ready. Fire away
   try
   {

     if (fire)
     {
       // we are starting the laser
       m_laser->fire_start();
       m_status = sLasing;
       timer_start(this);
       // FIXME: We should start another thread to periodically query the shot count
     }
     else
     {
       m_laser->fire_stop();
       m_status = sReady;
       // stop the counter
       set_counting_flashes(false);
     }
     // FIXME: This logic is not doing anything about the external shutter
     // once the external shutter is in place, one should actually stop using this command and instead
     // drive a single shot from the CIB (so that the external shutter is also timely opened)
     m_status = sLasing;
     // FIXME: If the operational status is propagated to the address space, we need to update it here
     m_laser->fire(static_cast<device::Laser::Fire>(fire)); // ensure that the prescale is rescaled
     m_status = sReady;
     // FIXME: The operation status should perhaps be reported back to SC
     //getAddressSpaceLink()->setStatus_code(status,OpcUa_Good);
   }
   catch(serial::PortNotOpenedException &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("single_shot"," ") << "Port not open [" << e.what() << "]";
     caught_exception = true;
   }
   catch(serial::SerialException &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("single_shot","Failed with a Serial exception :") << e.what();
     caught_exception = true;
   }
   catch(std::exception &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("single_shot","Failed with an STL exception :") << e.what();
     caught_exception = true;
   }
   catch(...)
   {
     msg.clear(); msg.str("");
     msg << log_e("single_shot","Failed with an unknown exception.");
     caught_exception = true;
   }
   if (caught_exception)
   {
     LOG(Log::ERR) << msg.str();
     resp["status"] = "ERROR";
     resp["messages"].push_back(msg.str());
     resp["status_code"] = OpcUa_Bad;
     response = UaString(resp.dump().c_str());
   }
   else {
     // all was good
     msg.clear(); msg.str("");
     msg << log_i("single_shot","Laser single shot fired");
     LOG(Log::INF) << msg.str();
     resp["status"] = "OK";
     resp["messages"].push_back(msg.str());
     resp["status_code"] = OpcUa_Good;
   }
   return OpcUa_Good;
}

// 3333333333333333333333333333333333333333333333333333333333333333333333333
// 3     FULLY CUSTOM CODE STARTS HERE                                     3
// 3     Below you put bodies for custom methods defined for this class.   3
// 3     You can do whatever you want, but please be decent.               3
// 3333333333333333333333333333333333333333333333333333333333333333333333333

void DIoLLaserUnit::automatic_port_search()
{
 try
 {
  // the automatic port search queries all available ports, their descriptions and IDs for an occurrence of the device
  // serial number
  // this has been shown to work for most cases, but there is always a chance that something fails
  // for example, the wrong serial number was provided
  m_comport = util::find_port(serial_number());
  if (m_comport.size() == 0)
  {
    LOG(Log::ERR) << "DIoLLaserUnit::automatic_port_search : Couldn't find device port";
  }

  m_status = sOffline;
 }
 catch(...)
 {
   m_status = sOffline;
   LOG(Log::ERR) << "DIoLLaserUnit::automatic_port_search : Caught an exception searching for the port";
   m_comport = "";
 }
}

void DIoLLaserUnit::refresh_status()
{
  json resp;
  refresh_status(resp);
}

void DIoLLaserUnit::refresh_status(json &resp)
{
  std::ostringstream msg("");
  uint16_t status = 99;
  std::string desc;
  bool got_exception = false;
  if (!m_laser)
   {
     msg.clear(); msg.str("");
     msg << log_e("status","There is no connection to the laser. Doing nothing.");
     LOG(Log::ERR) << msg.str();
     //resp["status"] = "ERROR";
     return;
   }
   try
   {
     m_laser->security(status, desc);
     getAddressSpaceLink()->setStatus_code(status,OpcUa_Good);
   }
   catch(serial::PortNotOpenedException &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("status"," ") << "Port not open [" << e.what() << "]";
     got_exception = true;
   }
   catch(serial::SerialException &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("status","Failed with a Serial exception :") << e.what();
     got_exception = true;
   }
   catch(std::exception &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("status","Failed with an STL exception :") << e.what();
     LOG(Log::ERR) << msg.str();
     got_exception = true;
   }
   catch(...)
   {
     msg.clear(); msg.str("");
     msg << log_e("status","Failed with an unknown exception.");
     LOG(Log::ERR) << msg.str();
     got_exception = true;
   }
   if (got_exception)
   {
     getAddressSpaceLink()->setStatus_code(status,OpcUa_BadDataUnavailable);
   }
}

void DIoLLaserUnit::timer_start(DIoLLaserUnit *obj)
{
  if (m_count_flashes)
  {
    LOG(Log::WRN) << "Trying to set a timer that has already been set up. Skipping.";
    return;
  }
  m_count_flashes = true;

  std::thread([obj]()
  {
    while (obj->get_counting_flashes())
    {
      // We know that the laser will be firing at 10 Hz, that means 100 ms
      auto x = std::chrono::steady_clock::now() + std::chrono::milliseconds(100);
      if (obj->refresh_shot_count() != OpcUa_Good)
      {
        LOG(Log::ERR) << "Failed to query device for status. Setting read values to InvalidData";
      }

      std::this_thread::sleep_until(x);
    }
  }).detach();
}

UaStatus DIoLLaserUnit::refresh_shot_count()
{
  std::ostringstream msg("");
  json resp;
  bool caught_exception = false;

  // this should never happen
  if (!m_laser)
   {
     msg.clear(); msg.str("");
     msg << log_e("count","Something very wrong happened. Trying to refresh shot count without a serial connection.");
     LOG(Log::ERR) << msg.str();
     return OpcUa_BadInvalidState;
   }
  static uint32_t count = 0;
  // everything seems ready. Get counter
   try
   {
     m_laser->get_shot_count(count);
     // set the local cache
     m_shot_count = count;
     // FIXME: This should perhaps be in the update()
     getAddressSpaceLink()->setFlash_count(m_shot_count, OpcUa_Good);
   }
   catch(serial::PortNotOpenedException &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("single_shot"," ") << "Port not open [" << e.what() << "]";
     caught_exception = true;
   }
   catch(serial::SerialException &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("single_shot","Failed with a Serial exception :") << e.what();
     caught_exception = true;
   }
   catch(std::exception &e)
   {
     msg.clear(); msg.str("");
     msg << log_e("single_shot","Failed with an STL exception :") << e.what();
     caught_exception = true;
   }
   catch(...)
   {
     msg.clear(); msg.str("");
     msg << log_e("single_shot","Failed with an unknown exception.");
     caught_exception = true;
   }
   if (caught_exception)
   {
     LOG(Log::ERR) << msg.str();
     getAddressSpaceLink()->setFlash_count(m_shot_count, OpcUa_BadDataUnavailable);
   }

  return OpcUa_Good;
}

UaStatus DIoLLaserUnit::init_device(json &resp)
{
  // if the system is already initialized do nothing and give back a warning
  bool got_exception = false;
  ostringstream msg("");
  UaStatus ret = OpcUa_Good;
  if (m_status > sOffline)
  {
    msg.clear(); msg.str("");
    msg << log_e("init","System already initialized.Skipping.");
    resp["status"] = "ERROR";
    resp["messages"].push_back(msg.str());
    resp["statuscode"] = OpcUa_BadInvalidState;
    return OpcUa_Good;
  }
  if (m_comport.size() == 0)
  {
    msg.clear(); msg.str("");
    msg << log_e("init","Unkonwn port.");
    resp["status"] = "ERROR";
    resp["messages"].push_back(msg.str());
    resp["statuscode"] = OpcUa_BadInvalidArgument;
    return OpcUa_Good;
  }
  try
  {
    if (m_laser)
    {
      msg.clear(); msg.str("");
      msg << log_w("init","System already initialized. Just reconfiguring.");
      resp["messages"].push_back(msg.str());
    }
    else
    {
      m_laser = new device::Laser(m_comport.c_str(),m_baud_rate);
    }
    // -- now that we have the system, let's update the settings in
    // the local cache
    m_status = sInit;

    // since we are at the init stage, we can call directly the device methods
    // call the internal methods, as these also check valid ranges
    // try to write all. If one fails, pass the error,
    // but give the opportunity for all settings to be written
    ret = write_hv(m_pump_hv,resp);
    ret = ret | write_divider(m_divider,resp);
    ret = ret | write_rate(m_rate_hz,resp);
    ret = ret | write_qswitch(m_qswitch,resp);

    if (ret != OpcUa_Good)
    {
      // something failed. Whatever it was, should already be in the
      // response string
      msg.clear(); msg.str("");
      msg << log_w("init","Some parameters failed to be set. Check previous messages.");
      return OpcUa_Bad;
    }
    else {
      msg.clear(); msg.str("");
      msg << log_i("init","System configured sucessfully.");
      if (m_config.is_ready())
      {
        m_status = sReady;
      }
    }
  }
  catch(serial::PortNotOpenedException &e)
  {
    msg.clear(); msg.str("");
    msg << log_e("init"," ") << "Port not open [" << e.what() << "]";
    got_exception = true;
  }
  catch(serial::SerialException &e)
  {
    msg.clear(); msg.str("");
    msg << log_e("init","Failed with a Serial exception :") << e.what();
    got_exception = true;
  }
  catch(std::exception &e)
  {
    msg.clear(); msg.str("");
    msg << log_e("init","Failed with an STL exception :") << e.what();
    got_exception = true;
  }
  catch(...)
  {
    msg.clear(); msg.str("");
    msg << log_e("init","Failed with an unknown exception.");
    got_exception = true;
  }
  if (got_exception)
  {
    LOG(Log::ERR) << msg.str();
    resp["status"] = "ERROR";
    resp["messages"].push_back(msg.str());
    resp["status_code"] = OpcUa_Bad;
    return OpcUa_Bad;
  } else
  {
    msg.clear(); msg.str("");
    msg << log_i("init","System initialized.");
    resp["status"] = "OK";
    resp["messages"].push_back(msg.str());
    resp["statuscode"] = OpcUa_Good;
    return OpcUa_Good;
  }
}

UaStatus DIoLLaserUnit::write_divider(const uint16_t v,json &resp)
{
  // NOTE: This method does not check whether the system is ready to execute
  // that is the job of the original method
  // check range
  uint16_t nv = v;
  static ostringstream msg("");
  bool got_exception = false;
  if ( v > 99)
  {
    nv = 99;
    msg.clear(); msg.str("");
    msg << log_w("prescale"," ") << "Value out of bounds. Truncating to max [ " << v << " --> " << nv << "]";
    resp["messages"].push_back(msg.str());
    LOG(Log::WRN) << msg.str();
  }
  try
  {
    m_laser->set_prescale(nv);
    m_divider = nv;
    // update the address space as well
    getAddressSpaceLink()->setRep_rate_divider(m_divider, OpcUa_Good);
    // set the bit
    m_config.word.r_div = 0x1;
    if (m_config.is_ready() && m_status == sInit)
    {
      m_status = sReady;
    }
  }
  catch(serial::PortNotOpenedException &e)
  {
    msg.clear(); msg.str("");
    msg << log_e("prescale"," ") << "Port not open [" << e.what() << "]";
    got_exception = true;
  }
  catch(serial::SerialException &e)
  {
    msg.clear(); msg.str("");
    msg << log_e("prescale","Failed with a Serial exception :") << e.what();
    got_exception = true;
  }
  catch(std::exception &e)
  {
    msg.clear(); msg.str("");
    msg << log_e("prescale","Failed with an STL exception :") << e.what();
    got_exception = true;
  }
  catch(...)
  {
    msg.clear(); msg.str("");
    msg << log_e("prescale","Failed with an unknown exception.");
    got_exception = true;
  }
  if (got_exception)
  {
    LOG(Log::ERR) << msg.str();
    resp["status"] = "ERROR";
    resp["messages"].push_back(msg.str());
    resp["statuscode"] = OpcUa_Bad;
    return OpcUa_Bad;
  }
  resp["status"] = "OK";
  resp["statuscode"] = OpcUa_Good;
  return OpcUa_Good;
}
UaStatus DIoLLaserUnit::write_rate(const float v,json &resp)
{
  // NOTE: This method does not check whether the system is ready to execute
  // that is the job of the original method
  // check range
  static ostringstream msg("");
  bool got_exception = false;
  // check range
 if (v <= 0.0 || v > 20.0)
 {
   msg.clear(); msg.str("");
   msg << log_e("rate","Value out of bounds: ") << v << "<> [0.0,20.0]";
   LOG(Log::ERR) << msg.str();
   resp["status"] = "ERROR";
   resp["messages"].push_back(msg.str());
   resp["statuscode"] = OpcUa_BadOutOfRange;
   return OpcUa_BadOutOfRange; // This shouldn't even be changed
 }
 try
 {
   m_laser->set_repetition_rate(v);
   m_rate_hz = v;
   getAddressSpaceLink()->setRep_rate_hz(m_rate_hz, OpcUa_Good);
   // set the bit
   m_config.word.rate = 0x1;
   if (m_config.is_ready() && m_status == sInit)
   {
     m_status = sReady;
   }
 }
 catch(serial::PortNotOpenedException &e)
 {
   msg.clear(); msg.str("");
   msg << log_e("rate"," ") << "Port not open [" << e.what() << "]";
   got_exception = true;
 }
 catch(serial::SerialException &e)
 {
   msg.clear(); msg.str("");
   msg << log_e("rate","Failed with a Serial exception :") << e.what();
   got_exception = true;
 }
 catch(std::exception &e)
 {
   msg.clear(); msg.str("");
   msg << log_e("rate","Failed with an STL exception :") << e.what();
   got_exception = true;
 }
 catch(...)
 {
   msg.clear(); msg.str("");
   msg << log_e("rate","Failed with an unknown exception.");
   got_exception = true;
 }
 if (got_exception)
 {
   LOG(Log::ERR) << msg.str();
   resp["status"] = "ERROR";
   resp["messages"].push_back(msg.str());
   resp["statuscode"] = OpcUa_Bad;
   return OpcUa_Bad;
 }
 return OpcUa_Good;
}
UaStatus DIoLLaserUnit::write_hv(const float v,json &resp)
{
  // NOTE: This method does not check whether the system is ready to execute
  // that is the job of the original method
  // check range
  static ostringstream msg("");
  bool got_exception = false;
  // check range
  if ((v < 0) || (v > 1.3))
  {
    msg.clear(); msg.str("");
    msg << log_e("rate","Value out of bounds: ") << v << "<> [0.0,20.0]";
    LOG(Log::ERR) << msg.str();
    resp["status"] = "ERROR";
    resp["messages"].push_back(msg.str());
    resp["statuscode"] = OpcUa_BadOutOfRange;
    return OpcUa_BadOutOfRange; // avoid overflow
  }
  try
  {
    m_laser->set_pump_voltage(v);
    m_pump_hv = v;
    getAddressSpaceLink()->setDischarge_voltage_kV(m_pump_hv, OpcUa_Good);
    // set the bit
    m_config.word.hv = 0x1;
    if (m_config.is_ready() && m_status == sInit)
    {
      m_status = sReady;
    }
  }
  catch(serial::PortNotOpenedException &e)
  {
    msg.clear(); msg.str("");
    msg << log_e("voltage"," ") << "Port not open [" << e.what() << "]";
    got_exception = true;
  }
  catch(serial::SerialException &e)
  {
    msg.clear(); msg.str("");
    msg << log_e("voltage","Failed with a Serial exception :") << e.what();
    got_exception = true;
  }
  catch(std::exception &e)
  {
    msg.clear(); msg.str("");
    msg << log_e("voltage","Failed with an STL exception :") << e.what();
    got_exception = true;
  }
  catch(...)
  {
    msg.clear(); msg.str("");
    msg << log_e("voltage","Failed with an unknown exception.");
    got_exception = true;
  }
  if (got_exception)
  {
    LOG(Log::ERR) << msg.str();
    resp["status"] = "ERROR";
    resp["messages"].push_back(msg.str());
    resp["statuscode"] = OpcUa_Bad;
    return OpcUa_Bad;
  }
  return OpcUa_Good;
}
UaStatus DIoLLaserUnit::write_qswitch(const uint16_t v,json &resp)
{
  // NOTE: This method does not check whether the system is ready to execute
  // that is the job of the original method
  // check range
  uint16_t nv = v;
  static ostringstream msg("");
  bool got_exception = false;
  if ( v > 999)
  {
    nv = 999;
    msg.clear(); msg.str("");
    msg << log_w("qswitch"," ") << "Value out of bounds. Truncating to max [ " << v << " --> " << nv << "]";
    resp["messages"].push_back(msg.str());
    LOG(Log::WRN) << msg.str();
  }
  try
  {
    m_laser->set_qswitch(nv);
    m_qswitch = nv;
    // update the address space as well
    getAddressSpaceLink()->setQswitch_us(m_qswitch, OpcUa_Good);
    // set the bit
    m_config.word.qsw = 0x1;
    if (m_config.is_ready() && m_status == sInit)
    {
      m_status = sReady;
    }
  }
  catch(serial::PortNotOpenedException &e)
  {
    msg.clear(); msg.str("");
    msg << log_e("qswitch"," ") << "Port not open [" << e.what() << "]";
    got_exception = true;
  }
  catch(serial::SerialException &e)
  {
    msg.clear(); msg.str("");
    msg << log_e("qswitch","Failed with a Serial exception :") << e.what();
    got_exception = true;
  }
  catch(std::exception &e)
  {
    msg.clear(); msg.str("");
    msg << log_e("qswitch","Failed with an STL exception :") << e.what();
    got_exception = true;
  }
  catch(...)
  {
    msg.clear(); msg.str("");
    msg << log_e("qswitch","Failed with an unknown exception.");
    got_exception = true;
  }
  if (got_exception)
  {
    LOG(Log::ERR) << msg.str();
    resp["status"] = "ERROR";
    resp["messages"].push_back(msg.str());
    resp["statuscode"] = OpcUa_Bad;
    return OpcUa_Bad;
  }
  return OpcUa_Good;
}


void DIoLLaserUnit::update()
{
  // do just periodic checks, that are meant to happen less often than usual
  // for example, check the laser unit status

  if (m_laser)
  {
    json resp;
    refresh_status(resp);
  }
}

}
