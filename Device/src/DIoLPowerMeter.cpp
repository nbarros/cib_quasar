
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.

    The stub of this file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.


 */


#include <Configuration.hxx> // TODO; should go away, is already in Base class for ages

#include <DIoLPowerMeter.h>
#include <ASIoLPowerMeter.h>
#ifdef SIMULATION
#include <PowerMeterSim.hh>
#else
#include <PowerMeter.hh>
#endif

#include <utilities.hh>
#include <sstream>


#include <chrono>
#include <thread>
#include <functional>
#include <string>
#include <random>
#include <json.hpp>

using json = nlohmann::json;

#define log_msg(s,met,msg) "[" << s << "]::" << met << " : " << msg

#define log_e(m,s) log_msg("ERROR",m,s)
#define log_w(m,s) log_msg("WARN",m,s)
#define log_i(m,s) log_msg("INFO",m,s)

using std::ostringstream;

namespace Device
{
// 1111111111111111111111111111111111111111111111111111111111111111111111111
// 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
// 1     Users don't modify this code!!!!                                  1
// 1     If you modify this code you may start a fire or a flood somewhere,1
// 1     and some human being may possible cease to exist. You don't want  1
// 1     to be charged with that!                                          1
// 1111111111111111111111111111111111111111111111111111111111111111111111111






// 2222222222222222222222222222222222222222222222222222222222222222222222222
// 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
// 2     (code for which only stubs were generated automatically)          2
// 2     You should add the implementation but dont alter the headers      2
// 2     (apart from constructor, in which you should complete initializati2
// 2     on list)                                                          2
// 2222222222222222222222222222222222222222222222222222222222222222222222222

/* sample ctr */
DIoLPowerMeter::DIoLPowerMeter (
    const Configuration::IoLPowerMeter& config,
    Parent_DIoLPowerMeter* parent
):
    Base_DIoLPowerMeter( config, parent)

    /* fill up constructor initialization list here */
        ,m_pm(nullptr)
        ,m_comport("auto")
        ,m_status(sOffline)
        ,m_measurement_mode(1)
        ,m_sel_range(2)
        ,m_wavelength(266)
        ,m_e_threshold(1)
        ,m_ave_setting(1)
        ,m_pulse_width(1)
        ,m_energy_reading(0.0)
        ,m_pause_measurements(false)
        ,m_do_measurements(false)
        ,m_serial_number("")
        ,m_serial_busy(false)
        ,m_measurement_interval(200)
{
    m_name = config.id();
    m_serial_number = "";
    /* fill up constructor body here */
    // first probe the for the port that this meter is attached to
    m_threshold_limits.first = 0;
    m_threshold_limits.second = 0;
    //
    LOG(Log::INF) << "DIoLPowerMeter::DIoLPowerMeter : Port set to [" << m_comport << "]";
    if (m_comport == "auto")
    {
      LOG(Log::WRN) << "DIoLPowerMeter::DIoLPowerMeter : Attempting automatic port detection based off serial number.";
      automatic_port_search();
    }
    //
    // -- initialize the status map
    m_status_map.insert({sOffline,"offline"});
    m_status_map.insert({sReady,"ready"});
    m_status_map.insert({sOperating,"operating"});

}

/* sample dtr */
DIoLPowerMeter::~DIoLPowerMeter ()
{
}

/* delegates for cachevariables */



/* delegators for methods */
UaStatus DIoLPowerMeter::callInit (
    UaString& response
)
{
    json resp;
    init(resp);
    // complete the structure of the response object
    if (!resp.contains("status"))
    {
      resp["status"] = "SUCCESS";
    }
    if (!resp.contains("statuscode"))
    {
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLPowerMeter::callSet_connection (
    const UaString&  port,
    OpcUa_UInt16 baud_rate,
    UaString& response
)
{
    json resp;
    std::string p = port.toUtf8();
    set_conn(p,baud_rate,resp);
    // complete the structure of the response object
    if (!resp.contains("status"))
    {
      resp["status"] = "SUCCESS";
    }
    if (!resp.contains("statuscode"))
    {
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLPowerMeter::callSet_average (
    OpcUa_UInt16 target_value,
    UaString& response
)
{
    json resp;
    set_average(target_value,resp);
    // complete the structure of the response object
    if (!resp.contains("status"))
    {
      resp["status"] = "OK";
    }
    if (!resp.contains("statuscode"))
    {
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLPowerMeter::callSet_range (
    OpcUa_Int16 target_value,
    UaString& response
)
{
    json resp;
    set_range(target_value,resp);
    // complete the structure of the response object
    if (!resp.contains("status"))
    {
      resp["status"] = "OK";
    }
    if (!resp.contains("statuscode"))
    {
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLPowerMeter::callSet_pulse_width (
    OpcUa_UInt16 target_value,
    UaString& response
)
{
    json resp;
    set_pwidth(target_value,resp);
    // complete the structure of the response object
    if (!resp.contains("status"))
    {
      resp["status"] = "OK";
    }
    if (!resp.contains("statuscode"))
    {
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLPowerMeter::callSet_threshold (
    OpcUa_UInt16 target_value,
    UaString& response
)
{
    json resp;
    set_thresh(target_value,resp);
    // complete the structure of the response object
    if (!resp.contains("status"))
    {
      resp["status"] = "OK";
    }
    if (!resp.contains("statuscode"))
    {
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLPowerMeter::callSet_wavelength (
    OpcUa_UInt16 target_value,
    UaString& response
)
{
    json resp;
    set_lambda(target_value,resp);
    // complete the structure of the response object
    if (!resp.contains("status"))
    {
      resp["status"] = "OK";
    }
    if (!resp.contains("statuscode"))
    {
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLPowerMeter::callSet_measurement_mode (
    OpcUa_UInt16 target_value,
    UaString& response
)
{
    json resp;
    set_mmode(target_value,resp);
    // complete the structure of the response object
    if (!resp.contains("status"))
    {
      resp["status"] = "OK";
    }
    if (!resp.contains("statuscode"))
    {
      resp["statuscode"] = OpcUa_Good;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLPowerMeter::callReset (

)
{
    json resp;
    UaStatus st = reset(resp);
//    std::ostringstream msg("");
//    if (st != OpcUa_Good)
//    {
//      resp["status"] = "ERROR";
//      msg.clear(); msg.str("");
//      msg << log_i(label.c_str(),"Failed to reset power meter.");
//      resp["messages"].push_back(msg.str());
//    }
//    else
//    {
//      resp["status"] = "OK";
//      msg.clear(); msg.str("");
//      msg << log_i(label.c_str(),"Power meter reset.");
//      resp["messages"].push_back(msg.str());
//
//    }
//    resp["statuscode"] = st;
//    response = UaString(resp.dump().c_str());
    return st;
}
UaStatus DIoLPowerMeter::callConfig (
    const UaString&  conf,
    UaString& response
)
{
    std::ostringstream msg("");
    bool got_exception = false;
    const std::string label = "config";

    json resp;
    json cf;
    try
    {
      cf = json::parse(conf.toUtf8());
      (void)config(cf,resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str(),"Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      response = UaString(resp.dump().c_str());
      return OpcUa_Good;
    }

    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLPowerMeter::callStop_measurements (
    UaString& response
)
{
    json resp;
    const std::string label = "stop_measurements";

    UaStatus st = stop_readings(resp);
    std::ostringstream msg("");
    if (st != OpcUa_Good)
    {
      resp["status"] = "ERROR";
      msg.clear(); msg.str("");
      msg << log_i(label.c_str(),"Failed to stop measurements.");
      resp["messages"].push_back(msg.str());
    }
    else
    {
      resp["status"] = "OK";
      msg.clear(); msg.str("");
      msg << log_i(label.c_str(),"Measurements stopped.");
      resp["messages"].push_back(msg.str());

    }
    resp["statuscode"] = static_cast<uint32_t>(st);
    response = UaString(resp.dump().c_str());
    //
    return OpcUa_Good;
}
UaStatus DIoLPowerMeter::callStart_measurements (
    UaString& response
)
{

    json resp;
    const std::string label = "start_measurements";

    UaStatus st = start_readings(resp);
    std::ostringstream msg("");
    if (st != OpcUa_Good)
    {
      resp["status"] = "ERROR";
      msg.clear(); msg.str("");
      msg << log_i(label.c_str(),"Failed to start measurements.");
      resp["messages"].push_back(msg.str());
    }
    else
    {
      resp["status"] = "OK";
      msg.clear(); msg.str("");
      msg << log_i(label.c_str(),"Measurements started.");
      resp["messages"].push_back(msg.str());

    }
    resp["statuscode"] = static_cast<uint32_t>(st);
    response = UaString(resp.dump().c_str());

    return OpcUa_Good;
}
UaStatus DIoLPowerMeter::callTerminate (
    UaString& response
)
{
    json resp;
    const std::string label = "terminate";

    UaStatus st = terminate(resp);
    std::ostringstream msg("");
    if (st != OpcUa_Good)
    {
      resp["status"] = "ERROR";
      msg.clear(); msg.str("");
      msg << log_i(label.c_str(),"Failed to start measurements.");
      resp["messages"].push_back(msg.str());
    }
    else
    {
      resp["status"] = "OK";
      msg.clear(); msg.str("");
      msg << log_i(label.c_str(),"Measurements started.");
      resp["messages"].push_back(msg.str());

    }
    resp["statuscode"] = static_cast<uint32_t>(st);
    response = UaString(resp.dump().c_str());

    return OpcUa_Good;
}

// 3333333333333333333333333333333333333333333333333333333333333333333333333
// 3     FULLY CUSTOM CODE STARTS HERE                                     3
// 3     Below you put bodies for custom methods defined for this class.   3
// 3     You can do whatever you want, but please be decent.               3
// 3333333333333333333333333333333333333333333333333333333333333333333333333

  UaStatus DIoLPowerMeter::set_conn(const std::string port, const uint16_t baud, json &resp)
  {
    std::ostringstream msg("");
    //
    if (m_status != sOffline)
    {
      msg.clear(); msg.str("");
      msg << log_e("set_conn","Power Meter is online. You must first shut it down.");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
}
    // if the port is already set and the connection is
    // established, do nothing.
    // in this case one should first terminate and then reset the parameters
    if (m_pm)
    {
      resp["status"] = "ERROR";
      msg.clear(); msg.str("");
      msg << log_e("set_conn","Device is already connected. Should first \'terminate\' present connection.");
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
    }
    // check whether the port is "auto"
    // at this stage we are good to set the connection parameters
    // otherwise, it is fair game
    if (port == std::string("auto"))
    {
      automatic_port_search();
      msg.clear(); msg.str("");
      msg << log_i("set_conn","Automatic search found port [") << m_comport << "]";
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    else
    {
      m_comport = port;
    }
    if (m_comport.size() == 0)
    {
      // the port is invalid. Something failed.
      msg.clear(); msg.str("");
      msg << log_e("set_conn","Port is invalid [") << m_comport << "]";
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return OpcUa_BadInvalidArgument;
    }
    UaString ss(m_comport.c_str());
    getAddressSpaceLink()->setPort(ss,OpcUa_Good);
    //
    // -- Now the baud rate
    //
    if (baud == 0)
    {
      // just leave what it is presently set
      msg.clear(); msg.str("");
      msg << log_i("set_conn","Baud rate kept to current value[") << m_baud_rate << "]";
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    else
    {
      m_baud_rate = baud;
    }
    update_status(sOffline);
    return OpcUa_Good;
  }
  void DIoLPowerMeter::update()
  {
    OpcUa_StatusCode status= OpcUa_Good;
    // the very first time the code runs, we should update the
    // local variables with the address space contents
    static bool first = true;
    if (first)
    {
      // now initialize all relevant variables passed through configuration
      // even though we initialize the class with what we believe to be those initial values,
      // nothing prevents them from changing in the future

      getAddressSpaceLink()->getRange_selected(m_sel_range);
      getAddressSpaceLink()->getMeasurement_mode(m_measurement_mode);
      getAddressSpaceLink()->getWavelength(m_wavelength);
      getAddressSpaceLink()->getTrigger_threshold(m_e_threshold);
      getAddressSpaceLink()->getAverage_window(m_ave_setting);
      getAddressSpaceLink()->getPulse_width(m_pulse_width);
      UaString dp(m_comport.c_str());
      getAddressSpaceLink()->setPort(dp,OpcUa_Good);
      first = false;
    }
//    // get an energy reading
//    if (!m_pause_measurements)
//    {
//      refresh_energy_reading();
//
//      if (m_ave_setting == 1)
//      {
//        status = OpcUa_BadDataUnavailable;
//      }
//      else
//      {
//        refresh_average_reading();
//        status = OpcUa_Good;
//      }
//    }
    status = OpcUa_Good;
    UaString ua_str = UaString(m_status_map.at(m_status).c_str());
    getAddressSpaceLink()->setState(ua_str,status);
  }

  void DIoLPowerMeter::refresh_energy_reading()
  {
    if (m_status != sOperating)
    {
      getAddressSpaceLink()->setEnergy_reading(m_energy_reading, OpcUa_BadDataUnavailable);
    }
    else
    {
      // actually query the device for the
      bool success = false;
      try
      {
        const std::lock_guard<std::mutex> lock(m_serial_mutex);
        success = m_pm->read_energy(m_energy_reading);
        if (success)
        {
          getAddressSpaceLink()->setEnergy_reading(m_energy_reading, OpcUa_Good);
        }
      }
      catch(std::exception &e)
      {

      }
      catch(...)
      {

      }
    }
  }

  void DIoLPowerMeter::refresh_average_reading()
  {
    if (m_status != sOperating)
    {
      getAddressSpaceLink()->setAverage_reading(m_average_reading, OpcUa_BadDataUnavailable);
    }
    else
    {
      // actually query the device for the
      bool success = false;
      try
      {
        const std::lock_guard<std::mutex> lock(m_serial_mutex);
        success = m_pm->read_average(m_average_reading);
        if (success)
        {
          getAddressSpaceLink()->setAverage_reading(m_average_reading, OpcUa_Good);
        }
      }
      catch(std::exception &e)
      {
      }
      catch(...)
      {
      }
    }
  }


  void DIoLPowerMeter::automatic_port_search()
  {
    try
    {
      // the automatic port search queries all available ports, their descriptions and IDs for an occurrence of the device
      // serial number
      // this has been shown to work for most cases, but there is always a chance that something fails
      // for example, the wrong serial number was provided
      m_comport = util::find_port(m_serial_number);
      if (m_comport.size() == 0)
      {
        LOG(Log::ERR) << "DIoLPowerMeter::automatic_port_search : Couldn't find device port";
      }

      m_status = sOffline;
    }
    catch(...)
    {
      m_status = sOffline;
      LOG(Log::ERR) << "DIoLPowerMeter::automatic_port_search : Caught an exception searching for the port";
      m_comport = "";
    }
  }

  void DIoLPowerMeter::refresh_all_ranges()
  {
    refresh_measurement_ranges();
    refresh_pulse_width_ranges();
    refresh_average_ranges();
    refresh_threshold_limits();
  }


  void DIoLPowerMeter::refresh_measurement_modes()
  {
    std::string type,sn,name;
    bool power,energy,freq;
    // actually query the device for the
    if (m_status == sOffline)
    {
      std::string s = util::serialize_map(m_measurement_modes);
      UaString ss(s.c_str());
      getAddressSpaceLink()->setMeasurement_options(ss,s.size(), OpcUa_BadDataUnavailable);
      return;
    }
    //
    try
    {
      {
        const std::lock_guard<std::mutex> lock(m_serial_mutex);
        m_pm->head_info(type, sn, name, power, energy, freq);
      }
      // now build the map with the capabilities of the power meter
      m_measurement_modes.clear();
      // insert passive (all have passive)
      m_measurement_modes.insert({1, "passive"});
      if (energy)
      {
        m_measurement_modes.insert({2, "power"});
      }
      if (power)
      {
        m_measurement_modes.insert({3, "energy"});
      }
      if (freq)
      {
        m_measurement_modes.insert({4, "exposure"});
      }
      std::string s = util::serialize_map(m_measurement_modes);
      UaString ss(s.c_str());
      getAddressSpaceLink()->setMeasurement_options(ss,s.size(), OpcUa_Good);
    }
    catch(std::exception &e)
    {
    }
    catch(...)
    {
    }
  }
  void DIoLPowerMeter::refresh_threshold_limits()
  {
    uint16_t current, min, max;
    if (m_status == sOffline)
    {
      // do nothing...we are offline
      return;
    }
    //
    try
    {
      const std::lock_guard<std::mutex> lock(m_serial_mutex);
      m_pm->query_user_threshold(current, min, max);
      m_threshold_limits.first = min;
      m_threshold_limits.second = max;
      if (current != m_e_threshold)
      {
        LOG(Log::WRN) << "DIoLPowerMeter::refresh_threshold_limits : Mismatch between cached threshold and device reported ("
            << m_e_threshold << " <> " << current << ")";
      }
    }
    catch(std::exception &e)
    {
    }
    catch(...)
    {
    }
  }

  void DIoLPowerMeter::refresh_measurement_ranges()
  {
    //
    int16_t v;
    if (m_status == sOffline)
    {
      // do nothing...we are offline
      std::string s = util::serialize_map(m_ranges);
      UaString ss(s.c_str());
      getAddressSpaceLink()->setRange_options(ss,s.size(), OpcUa_BadDataUnavailable);
      return;
    }
    //
    try
    {
      {
        const std::lock_guard<std::mutex> lock(m_serial_mutex);
        m_pm->get_all_ranges(v);
      }
      if (v != m_sel_range)
      {
        LOG(Log::WRN) << "DIoLPowerMeter::refresh_measurement_ranges : Mismatch between cached range and device reported (" << m_sel_range << " <> " << v << ")";
      }
      {
        const std::lock_guard<std::mutex> lock(m_serial_mutex);
        m_pm->get_range_map(m_ranges);
      }
      // force address space update
      std::string s = util::serialize_map(m_ranges);
      UaString ss(s.c_str());
      getAddressSpaceLink()->setRange_options(ss,s.size(), OpcUa_Good);
    }
    catch(std::exception &e)
    {
    }
    catch(...)
    {
    }
  }

  void DIoLPowerMeter::refresh_pulse_width_ranges()
  {
    uint16_t a;
    if (m_status == sOffline)
    {
      std::string s = util::serialize_map(m_pulse_widths);
      UaString ss(s.c_str());
      getAddressSpaceLink()->setPulse_length_options(ss,s.size(), OpcUa_BadDataUnavailable);
      return;
    }
    //
    try
    {
      {
        const std::lock_guard<std::mutex> lock(m_serial_mutex);
        m_pm->pulse_length(0, a); // this guarantees that the map is filled
        m_pm->get_pulse_map(m_pulse_widths);
      }
      // force address space update
      std::string s = util::serialize_map(m_pulse_widths);
      UaString ss(s.c_str());
      getAddressSpaceLink()->setPulse_length_options(ss,s.size(), OpcUa_Good);
    }
    catch(std::exception &e)
    {
    }
    catch(...)
    {
    }
  }

  void DIoLPowerMeter::refresh_average_ranges()
  {
    // -- check the average window options
    uint16_t a;
    bool got_exception = false;
    if (m_status == sOffline)
    {
      std::string s = util::serialize_map(m_ave_windows);
      UaString ss(s.c_str());
      getAddressSpaceLink()->setAverage_options(ss,s.size(), OpcUa_BadDataUnavailable);
      return;
    }
    try
    {
      {
        const std::lock_guard<std::mutex> lock(m_serial_mutex);
        m_pm->average_query(0, a); // this guarantees that the map is filled
        m_pm->get_averages_map(m_ave_windows);
      }
      //
      // force address space update
      std::string s = util::serialize_map(m_ave_windows);
      UaString ss(s.c_str());
      getAddressSpaceLink()->setAverage_options(ss,s.size(), OpcUa_Good);
    }
    catch(std::exception &e)
    {
      got_exception = true;
    }
    catch(...)
    {
      got_exception = true;
    }
    if (got_exception)
    {
      m_serial_busy.store(false);
    }

  }
  UaStatus DIoLPowerMeter::init(json &resp, bool start)
  {
    // if the port does not start by '/'
    bool got_exception = false;
    ostringstream msg("");
    const std::string label = "init";

    UaStatus ret = OpcUa_Good;
    if (m_status != sOffline)
    {
      msg.clear(); msg.str("");
      msg << log_w(label.c_str(),"System already initialized.Skipping.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
      return OpcUa_Good;
    }
    if (m_comport.size() == 0)
    {
      msg << log_e(label.c_str(),"There is no port");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      LOG(Log::ERR) << msg.str();
      return OpcUa_Bad;
    }
    if (m_comport.at(0)!= '/')
    {
      msg << log_e(label.c_str()," ") << "Malformed port [" << m_comport << "]. Expected something like [/dev/ttyXXXXX]";
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    if (m_comport == std::string("auto"))
    {
      msg.clear(); msg.str("");
      msg << log_w(label.c_str(),"Port set to auto. Probing ports.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
      automatic_port_search();
    }
    // all seems good
    // try to establish the connection
    try
    {
      if (m_pm)
      {
        msg.clear(); msg.str("");
        msg << log_w(label.c_str(),"System already initialized. Just reconfiguring.");
        resp["messages"].push_back(msg.str());
        bool clean_and_rebuild = false;
        if (m_pm->get_port() != m_comport)
        {
          clean_and_rebuild = true;
        }
        if (m_pm->get_baud()  != m_baud_rate)
        {
          clean_and_rebuild = true;
        }
        if (clean_and_rebuild)
        {
          // that means that we should terminate and recreate
          const std::lock_guard<std::mutex> lock(m_serial_mutex);
          delete m_pm;
          m_pm = nullptr;
          m_pm = new device::PowerMeter(m_comport.c_str(),static_cast<uint32_t>(m_baud_rate));
        }
      }
      else
      {
        m_pm = new device::PowerMeter(m_comport.c_str(),static_cast<uint32_t>(m_baud_rate));
      }
      // set the device to the measurement mode we have set in configuration
      // query instrument for the measurement modes it can do
      std::string type, sn, name;
      bool power,energy,freq;
      {
        const std::lock_guard<std::mutex> lock(m_serial_mutex);
        m_pm->head_info(type, sn, name, power, energy, freq);
      }
      update_status(sReady);
      // if all is good update port and baud in the address space
      UaString dport(m_comport.c_str());
      getAddressSpaceLink()->setPort(dport,OpcUa_Good);
      getAddressSpaceLink()->setBaud_rate(m_baud_rate,OpcUa_Good);
      // now build the map with the capabilities of the power meter
      refresh_measurement_modes();
      json rep;
      set_mmode(m_measurement_mode,rep);
      // refresh all ranges for this measurement mode
      refresh_all_ranges();
      //
      // -- Select the measurement range
      //
      bool something_failed = false;

      ret = set_range(m_sel_range, rep);
      something_failed = (ret!=OpcUa_Good);
      //
      // -- Select the pulse widths/lengths
      //
      ret = set_pwidth(m_pulse_width,rep);
      something_failed |= (ret!=OpcUa_Good);
      //
      //-- Select the average setting
      //
      ret = set_average(m_ave_setting,rep);
      something_failed |= (ret!=OpcUa_Good);
      //
      // -- Select the wavelength
      //
      ret = set_lambda(m_wavelength,rep);
      something_failed |= (ret!=OpcUa_Good);
      //
      // -- Select the threshold
      //
      ret = set_thresh(m_e_threshold,rep);
      something_failed |= (ret!=OpcUa_Good);
      // -- if it reached this point, the whole thing is initialized
      // check if there were errors being throuwn
      if (something_failed)
      {
        if (rep.contains("status"))
        {
          if (rep.at("status").get<std::string>() == std::string("ERROR"))
          {
            resp["status"] = "ERROR";
            resp["statuscode"] = rep.at("statuscode");
            resp["messages"].insert(std::end(resp["messages"]),std::begin(rep["messages"]),std::end(rep["messages"]));
            msg.clear(); msg.str("");
            msg << log_e(label.c_str()," ") << "Failed to complete Power Meter configuration. See previous messages";
            resp["messages"].push_back(msg.str());
            LOG(Log::ERR) << msg.str();
            return OpcUa_Uncertain;
          }
        }
      }
      update_status(sReady);
      if (start)
      {
        // activate the measurements
        start_readings(resp);
      }
      else
      {
        stop_readings(resp);
      }
    }
    catch(serial::PortNotOpenedException &e)
    {
      // port is not open. Keep status as offline
      // don't commit any assignments
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Exception: Port not open [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught a serial exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an STL exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(...)
    {
      // caught something completely unexpected. Just treat it as something went really wrong.
      // Assume one is offline
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an unknown exception.";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    if (got_exception)
    {
      json dummy;
      terminate(dummy);
      update_status(sOffline);
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i(label.c_str(),"System inititalized");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
      return OpcUa_Good;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLPowerMeter::reset(json &resp)
  {
    // a reset is both issued to the device and used to clear out local states
    // the issue with the reset is that the connection with the device could be accidently terminated
    // to avoid weird states, after the reset the connection is terminated and reopened
    std::ostringstream msg("");
    bool got_exception = false;
    const std::string label = "reset";
    UaStatus st = check_offline_state(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    // -- if Reading, stop the measurements
    if (m_status == sOperating)
    {
      msg.clear(); msg.str("");
      msg << log_w(label.c_str(),"Power Meter is taking readings. Stopping first.");
      resp["messages"].push_back(msg.str());
      stop_readings(resp);
    }
    try
    {
      {
        const std::lock_guard<std::mutex> lock(m_serial_mutex);
        m_pm->reset();
      }
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Restarting the connection to the device.";
      terminate(resp);
      // re-initialize
      init(resp,false);
    }
    catch(serial::PortNotOpenedException &e)
    {
      // port is not open. Keep status as offline
      // don't commit any assignments
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Exception: Port not open [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught a serial exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an STL exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(...)
    {
      // caught something completely unexpected. Just treat it as something went really wrong.
      // Assume one is offline
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an unknown exception.";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    if (got_exception)
    {
      json dummy;
      terminate(dummy);
      // attempt to reinitialize
      init(resp);
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i(label.c_str(),"System reset");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
      return OpcUa_Good;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLPowerMeter::config(json &conf,json &resp)
  {
    bool got_exception = false;
    UaStatus st = OpcUa_Good;
    ostringstream msg("");
    const std::string label = "config";

    try
    {
      if (m_status != sOffline)
      {
        msg.clear(); msg.str("");
        msg << log_e(label.c_str(),"System already initialized.Should first terminate.Skipping.");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidState;
        return OpcUa_BadInvalidState;
      }
      // validate that all settings are here
      if (!validate_config_fragment(conf,resp))
      {
        return OpcUa_BadInvalidArgument;
      }
      // then check the configuration is aimed to the proper device
      if (conf.at("name").get<std::string>() != m_name)
      {
        msg.clear(); msg.str("");
        msg << log_e(label.c_str(),"Mismatch between name in object and configuration fragment :")
                          << " (" << conf.at("name").get<std::string>() <<" <> " << m_name << ")";
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      // if it is a valid configuration fragment start processing it.
      // first grab the connection settings, since we want the connection
      // to be established before processing the other settings
      std::string port = conf.at("port").get<std::string>();
      uint16_t baud = conf.at("baud_rate").get<uint16_t>();
      m_serial_number = conf.at("serial_number").get<std::string>();
      st = set_conn(port,baud,resp);
      if ( st != OpcUa_Good)
      {
        // just fail. The messages should carry the information
        return st;
      }
      // all seems good
      // try to establish the connection
      if (m_pm)
      {
        msg.clear(); msg.str("");
        msg << log_w(label.c_str(),"System already initialized. Just reconfiguring.");
        resp["messages"].push_back(msg.str());
        bool clean_and_rebuild = false;

        if (m_pm->get_port() != m_comport)
        {
          clean_and_rebuild = true;
        }
        if (m_pm->get_baud()  != m_baud_rate)
        {
          clean_and_rebuild = true;
        }
        if (clean_and_rebuild)
        {
          // that means that we should terminate and recreate
          // set a mutex so nothing else attempts anything funny
          const std::lock_guard<std::mutex> lock(m_serial_mutex);
          delete m_pm;
          m_pm = nullptr;
          m_pm = new device::PowerMeter(m_comport.c_str(),static_cast<uint32_t>(m_baud_rate));
        }
      }
      else
      {
        const std::lock_guard<std::mutex> lock(m_serial_mutex);
        m_pm = new device::PowerMeter(m_comport.c_str(),static_cast<uint32_t>(m_baud_rate));
      }
      update_status(sReady);
      // do another crosscheck on the serial number
      m_serial_number = conf.at("serial_number").get<std::string>();
      // query instrument for the measurement modes it can do
      std::string type, sn, name;
      bool power,energy,freq;
      // create an internal scope to constrain the lock duraction
      {
        const std::lock_guard<std::mutex> lock(m_serial_mutex);
        m_pm->head_info(type, sn, name, power, energy, freq);
      }
      update_status(sReady);
      // if all is good update port and baud in the address space
      UaString dport(m_comport.c_str());
      getAddressSpaceLink()->setPort(dport,OpcUa_Good);
      getAddressSpaceLink()->setBaud_rate(m_baud_rate,OpcUa_Good);
      // now build the map with the capabilities of the power meter
      refresh_measurement_modes();
      m_measurement_mode = conf.at("measurement_mode").get<uint16_t>();
      st = set_mmode(m_measurement_mode,resp);
      if (st != OpcUa_Good)
      {
        msg.clear(); msg.str("");
        msg << log_e(label.c_str()," ") << "Failed to set measurement mode : " << m_measurement_mode;
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_Bad;
        LOG(Log::ERR) << msg.str();
        return OpcUa_Bad;
      }
      // set the pulse width before refreshing the ranges
      m_pulse_width = conf.at("pulse_width").get<uint16_t>();
      st = set_pwidth(m_pulse_width, resp);
      getAddressSpaceLink()->setPulse_width(m_pulse_width, st);
      if (st != OpcUa_Good)
      {
        msg.clear();
        msg.str("");
        msg << log_e(label.c_str(), " ") << "Failed to set pulse length to  : " << m_pulse_width;
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_Bad;
        LOG(Log::ERR) << msg.str();
        return OpcUa_Bad;
      }

      // now refresh the ranges
      refresh_all_ranges();
      for (json::iterator it = conf.begin(); it != conf.end(); ++it)
      {
        LOG(Log::INF) << "Processing " << it.key() << " : " << it.value() << "\n";
        if (it.key() == "select_range")
        {
          st = set_range(it.value(),resp);
          getAddressSpaceLink()->setRange_selected(m_sel_range, st);
          if (st != OpcUa_Good)
          {
            return st;
          }
        }
        if (it.key() == "wavelength")
        {
          st = set_lambda(it.value(),resp);
          getAddressSpaceLink()->setWavelength(m_wavelength, st);
          if (st != OpcUa_Good)
          {
            return st;
          }
        }
        if (it.key() == "energy_threshold")
        {
          st = set_thresh(it.value(),resp);
          getAddressSpaceLink()->setTrigger_threshold(m_e_threshold, st);
          if (st != OpcUa_Good)
          {
            return st;
          }
        }
        if (it.key() == "average_setting")
        {
          st = set_average(it.value(),resp);
          getAddressSpaceLink()->setAverage_window(m_ave_setting, st);
          if (st != OpcUa_Good)
          {
            return st;
          }
        }
        if (it.key() == "measurement_interval_ms")
        {
          m_measurement_interval = it.value();
          getAddressSpaceLink()->setMeasurement_interval_ms(m_measurement_interval, OpcUa_Good);
        }
      }
      update_status(sReady);
      // -- will start right away
      st = start_readings(resp);
      if (st != OpcUa_Good)
      {
        resp["status"] = "ERROR";
        resp["messages"].push_back("Failed to start readings");
        resp["statuscode"] = static_cast<int>(st);
        LOG(Log::ERR) << "Failed to start readings";
      }
    }
    catch(serial::PortNotOpenedException &e)
    {
      // port is not open. Keep status as offline
      // don't commit any assignments
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Exception: Port not open [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught a serial exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an STL exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(...)
    {
      // caught something completely unexpected. Just treat it as something went really wrong.
      // Assume one is offline
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an unknown exception.";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    // if we get an exception, destroy the hardware connection
    if (got_exception)
    {
      m_serial_busy.store(false);
      json dummy;
      terminate(dummy);
      update_status(sOffline);
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i(label.c_str(),"System configured");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
      return OpcUa_Good;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLPowerMeter::stop_readings(json &resp)
  {
    const std::string label = "stop_readings";
    UaStatus st = check_offline_state(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    // this should just flip a variable
    m_do_measurements.store(false);
    update_status(sReady);
    return OpcUa_Good;
  }
  UaStatus DIoLPowerMeter::start_readings(json &resp)
  {
    // this should actually start a new thread that updates the measurements
    const std::string label = "start_readings";
    UaStatus st = check_offline_state(resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    if (m_do_measurements.load())
    {
      resp["status"] = "WARN";
      std::ostringstream msg("");
      msg << log_w(label.c_str(),"Readings already ongoing. Ignoring command.");
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Uncertain;
      return OpcUa_Good;
    }
    // check that the refresh interval is not too low or we'll run into troubles for sure
    if (m_measurement_interval < 50)
    {
      resp["status"] = "ERROR";
      std::ostringstream msg("");
      msg << log_e(label.c_str(),"Refresh interval is too low (should be at least above 50)");
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_BadInvalidArgument;
    }
    // if it reached this point, we should be good to go
    update_status(sOperating);
    start_readings();
    // this should just flip a variable
    return OpcUa_Good;
  }
  void DIoLPowerMeter::start_readings()
  {
    if (m_do_measurements.load())
    {
      LOG(Log::WRN) << log_w("start_readings","Readings are already ongoing.");
      return;
    }
    m_do_measurements.store(true);
    std::thread([this]()
                {
      while(m_do_measurements.load())
        {
        auto x = std::chrono::steady_clock::now() + std::chrono::milliseconds(m_measurement_interval);
        refresh_energy_reading();
        refresh_average_reading();
        std::this_thread::sleep_until(x);
        }
                }
                ).detach();

  }
  UaStatus DIoLPowerMeter::terminate(json &resp)
  {
    // this can be trickier since we need to hope
    // that any instability will be caught by the serial exceptions
    std::ostringstream msg("");
    bool got_exception = false;
    const std::string label = "terminate";
    try
    {
      stop_readings(resp);
      update_status(sOffline);
      if (m_pm) delete m_pm;
      m_pm = nullptr;
    }
    catch(serial::PortNotOpenedException &e)
    {
      // port is not open. Keep status as offline
      // don't commit any assignments
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Exception: Port not open [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught a serial exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an STL exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(...)
    {
      // caught something completely unexpected. Just treat it as something went really wrong.
      // Assume one is offline
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an unknown exception.";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    if (got_exception)
    {
      // do not attempt any deallocations
      // just nullify the pointer
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      update_status(sOffline);
      m_pm = nullptr;
      // the return value is actually not very relevant
      // one does not call terminate checking its result
      return OpcUa_Bad;
    }
    else
    {
      msg.clear(); msg.str("");
      msg << log_i(label.c_str(),"System terminated");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
      return OpcUa_Good;
    }
  }

  bool DIoLPowerMeter::is_ready()
  {
    // if it is operating, just let it go
    return ((m_status == sReady) || (m_status == sOperating));
  }
  void DIoLPowerMeter::update_status(Status s)
  {
    if (m_status == s)
    {
      // nothing to be done
      return;
    }
    m_status = s;
    UaString ss(m_status_map.at(m_status).c_str());
    getAddressSpaceLink()->setState(ss,OpcUa_Good);
  }
  UaStatus DIoLPowerMeter::set_average(const uint16_t ave, json &resp)
  {
    uint16_t u16;
    std::ostringstream msg("");
    const std::string label = "set_average";
    if (m_status == sOffline)
    {
      msg << log_e(label.c_str()," ") << "Device is offline. Can't query";
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_BadInvalidState;
    }
    bool got_exception = false;
    if (m_ave_windows.count(ave) == 0)
    {
      msg << log_e(label.c_str()," ") << "Can't find selected option in available options : " << ave;
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    try
    { 
      const std::lock_guard<std::mutex> lock(m_serial_mutex);
      m_pm->average_query(m_ave_setting, u16); // this ensures that the map is filled
    }
    catch(serial::PortNotOpenedException &e)
    {
      // port is not open. Keep status as offline
      // don't commit any assignments
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Exception: Port not open [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught a serial exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an STL exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(...)
    {
      // caught something completely unexpected. Just treat it as something went really wrong.
      // Assume one is offline
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an unknown exception.";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    if (got_exception)
    {
      m_serial_busy.store(false);
      // do not attempt any deallocations
      // just nullify the pointer
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      // the return value is actually not very relevant
      // one does not call terminate checking its result
      return OpcUa_Bad;
    }
    if (u16 != m_ave_setting)
    {
      msg << log_e(label.c_str()," ") << "Failed to select average window.";
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      LOG(Log::ERR) << msg.str();
      getAddressSpaceLink()->setAverage_window(u16,OpcUa_Bad);
      return OpcUa_Bad;
    }
    m_ave_setting = ave;
    getAddressSpaceLink()->setAverage_window(m_ave_setting,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLPowerMeter::set_range(const uint16_t range, json &resp)
  {
    bool success = true;
    std::ostringstream msg("");
    const std::string label = "set_range";
   if (m_status == sOffline)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str(),"Power Meter is offline. Can't communicate.");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
    }
    if (m_ranges.count(range) == 0)
    {
      msg << log_e(label.c_str()," ") << "Can't find selected range in available options : " << range;
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    bool got_exception = false;
    try
    {
      const std::lock_guard<std::mutex> lock(m_serial_mutex);
      m_pm->write_range(range, success);
    }
    catch(serial::PortNotOpenedException &e)
    {
      // port is not open. Keep status as offline
      // don't commit any assignments
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Exception: Port not open [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
     msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught a serial exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an STL exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(...)
    {
      // caught something completely unexpected. Just treat it as something went really wrong.
      // Assume one is offline
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an unknown exception.";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    if (got_exception)
    {
      // do not attempt any deallocations
      // just nullify the pointer
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      // the return value is actually not very relevant
      // one does not call terminate checking its result
      return OpcUa_Bad;
    }
    if (!success)
    {
      msg << log_e(label.c_str()," ") << "Failed to select range " << range;
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      getAddressSpaceLink()->setRange_selected(m_sel_range,OpcUa_Bad);
      LOG(Log::ERR) << msg.str();
      return OpcUa_Bad;
    }
    m_sel_range = range;
    getAddressSpaceLink()->setRange_selected(m_sel_range,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLPowerMeter::set_pwidth(const uint16_t pwidth, json &resp)
  {
    const std::string label = "set_pwidth";
    uint16_t u16;
    std::ostringstream msg("");

    if (m_status == sOffline)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str(),"Power Meter is offline. Can't communicate.");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
    }
    if (m_pulse_widths.count(pwidth) == 0)
    {
      msg << log_e(label.c_str()," ") << "Can't find selected option in available options : " << pwidth;
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    bool got_exception = false;
    try
    {
      const std::lock_guard<std::mutex> lock(m_serial_mutex);
      m_pm->pulse_length(pwidth, u16);
    }
    catch(serial::PortNotOpenedException &e)
    {
      // port is not open. Keep status as offline
      // don't commit any assignments
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Exception: Port not open [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught a serial exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an STL exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(...)
    {
      // caught something completely unexpected. Just treat it as something went really wrong.
      // Assume one is offline
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an unknown exception.";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    if (got_exception)
    {
      // do not attempt any deallocations
      // just nullify the pointer
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      LOG(Log::ERR) << msg.str();
      // the return value is actually not very relevant
      // one does not call terminate checking its result
      return OpcUa_Bad;
    }
    if (u16 != pwidth)
    {
      msg << log_e("set_pwidth"," ") << "Failed to select pulse width " << pwidth;
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      LOG(Log::ERR) << msg.str();
      getAddressSpaceLink()->setPulse_width(u16,OpcUa_Bad);
      return OpcUa_Bad;
    }
    m_pulse_width = pwidth;
    getAddressSpaceLink()->setPulse_width(m_pulse_width,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLPowerMeter::set_thresh(const uint16_t thresh, json &resp)
  {
    uint16_t current, min, max, u16;
    bool got_exception = false;
    const std::string label = "set_thresh";
    std::ostringstream msg("");
    if (m_status == sOffline)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str(),"Power Meter is offline. Can't communicate.");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      LOG(Log::ERR) << msg.str();
      return OpcUa_BadInvalidState;
    }
    try
    {
      {
        const std::lock_guard<std::mutex> lock(m_serial_mutex);
        m_pm->query_user_threshold(current, min, max);
      }
      m_threshold_limits.first = min;
      m_threshold_limits.second = max;

      if (current != thresh)
      {
        {
          const std::lock_guard<std::mutex> lock(m_serial_mutex);
          m_pm->user_threshold(thresh, u16);
        }
          if (u16 != thresh)
          {
            msg << log_e(label.c_str(), " ") << " Failed to set energy threshold to " << thresh;
            resp["status"] = "ERROR";
            resp["messages"].push_back(msg.str());
            resp["statuscode"] = OpcUa_Bad;
            LOG(Log::ERR) << msg.str();
            getAddressSpaceLink()->setTrigger_threshold(u16, OpcUa_Bad);
            return OpcUa_Bad;
          }
          m_e_threshold = thresh;
          getAddressSpaceLink()->setTrigger_threshold(m_e_threshold, OpcUa_Good);
          return OpcUa_Good;
        }
    }
    catch(serial::PortNotOpenedException &e)
    {
      // port is not open. Keep status as offline
      // don't commit any assignments
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Exception: Port not open [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught a serial exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an STL exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(...)
    {
      // caught something completely unexpected. Just treat it as something went really wrong.
      // Assume one is offline
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an unknown exception.";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    if (got_exception)
    {
      // do not attempt any deallocations
      // just nullify the pointer
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      // the return value is actually not very relevant
      // one does not call terminate checking its result
      return OpcUa_Bad;
    }

    return OpcUa_Good;
  }
  UaStatus DIoLPowerMeter::set_lambda(const uint16_t lambda, json &resp)
  {
    // this one has no options, so we just need to check for success
    bool success;
    bool got_exception = false;
    std::ostringstream msg("");
    const std::string label = "set_lambda";
    if (m_status == sOffline)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str(),"Power Meter is offline. Can't communicate.");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      LOG(Log::ERR) << msg.str();
      return OpcUa_BadInvalidState;
    }
    try
    {
      const std::lock_guard<std::mutex> lock(m_serial_mutex);
      m_pm->wavelength(lambda, success);
    }
    catch(serial::PortNotOpenedException &e)
    {
      // port is not open. Keep status as offline
      // don't commit any assignments
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Exception: Port not open [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught a serial exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an STL exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(...)
    {
      // caught something completely unexpected. Just treat it as something went really wrong.
      // Assume one is offline
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an unknown exception.";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    if (got_exception)
    {
      // do not attempt any deallocations
      // just nullify the pointer
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      // the return value is actually not very relevant
      // one does not call terminate checking its result
      return OpcUa_Bad;
    }
    if (!success)
    {
      msg << log_e(label.c_str()," ") << "Failed to set wavelength to " << lambda;
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      LOG(Log::ERR) << msg.str();
      getAddressSpaceLink()->setWavelength(m_wavelength,OpcUa_Bad);
      return OpcUa_Bad;
    }
    m_wavelength = lambda;
    getAddressSpaceLink()->setWavelength(m_wavelength,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLPowerMeter::set_mmode(const uint16_t mmode, json &resp)
  {
    // check if the configured measurement mode is valid
    // for the device, otherwise set to passive
    uint16_t local_mode;
    UaStatus st = OpcUa_Good;
    std::ostringstream msg("");
    const std::string label = "set_mmode";
    if (m_status == sOffline)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str(),"Power Meter is offline. Can't communicate.");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      LOG(Log::ERR) << msg.str();
      return OpcUa_BadInvalidState;
    }
    if (m_measurement_modes.count(mmode))
    {
      local_mode = mmode;
    }
    else
    {
      // this means to query what is currently set
      local_mode = 1;
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_e(label.c_str(),"Selected measurement mode is not available. Check variable for valid options.");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
      LOG(Log::ERR) << msg.str();
      // remain online, but unconfigured
      // in this case update the local variable with whatever is set in the hardware
      st = OpcUa_Bad;
    }
    // it is a valid mode
    // set it as the operating mode
    uint16_t mm;
    bool got_exception = false;
    try
    {
      const std::lock_guard<std::mutex> lock(m_serial_mutex);
      m_pm->measurement_mode(local_mode,mm);
    }
    catch(serial::PortNotOpenedException &e)
    {
      // port is not open. Keep status as offline
      // don't commit any assignments
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Exception: Port not open [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(serial::SerialException &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught a serial exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an STL exception : [" << e.what() << "].";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    catch(...)
    {
      // caught something completely unexpected. Just treat it as something went really wrong.
      // Assume one is offline
      msg.clear(); msg.str("");
      msg << log_e(label.c_str()," ") << "Caught an unknown exception.";
      LOG(Log::ERR) << msg.str();
      got_exception = true;
    }
    if (got_exception)
    {
      m_serial_busy.store(false);
      // do not attempt any deallocations
      // just nullify the pointer
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      LOG(Log::ERR) << msg.str();
      // the return value is actually not very relevant
      // one does not call terminate checking its result
      return OpcUa_Bad;
    }

    getAddressSpaceLink()->setMeasurement_mode(mm, OpcUa_Good);
    return st;
  }
  bool DIoLPowerMeter::validate_config_fragment(json &c, json &r)
  {
    // this is just a validation check for the available keys.
    // it will only check the mandatory keys.
    std::vector<std::string> keys = {"name","port","serial_number","baud_rate",
        "measurement_mode", "select_range", "wavelength", "energy_threshold",
        "average_setting","pulse_width", "measurement_interval_ms"};
    // actually, check for all entries and report all missing ones
    std::vector<std::string> missing;
    std::ostringstream msg("");
    const std::string label = "valid_config";
   for (auto entry: keys)
    {
      if (!c.contains(entry))
      {
        missing.push_back(entry);
      }
    }
    if (missing.size() > 0)
    {
      msg.clear(); msg.str("");
      msg << log_e(label.c_str(),"Missing entries in Power Meter config fragment [");
      for (auto e : missing)
      {
        msg << "(" <<  e << "),";
      }
      msg << "]";
      r["status"] = "ERROR";
      r["messages"].push_back(msg.str());
      r["statuscode"] = OpcUa_BadInvalidArgument;
      return false;
    }
    // all good, return true
    return true;
  }
  UaStatus DIoLPowerMeter::set_id(const std::string &id)
  {
    m_id = id;
    return OpcUa_Good;
  }
  UaStatus DIoLPowerMeter::check_offline_state(json &resp)
  {
    const std::string lbl = "check_offline";
    if (m_status == sOffline)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Power Meter is offline. No operation possible.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
    }
    else
    {
      return OpcUa_Good;
    }
  }

} // namespace Device
