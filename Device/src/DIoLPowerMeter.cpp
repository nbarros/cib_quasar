
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.

    The stub of this file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.


 */


#include <Configuration.hxx> // TODO; should go away, is already in Base class for ages

#include <DIoLPowerMeter.h>
#include <ASIoLPowerMeter.h>

#include <PowerMeter.hh>
#include <utilities.hh>
#include <sstream>


#include <chrono>
#include <thread>
#include <functional>
#include <string>
#include <random>

#define log_msg(s,met,msg) "[" << s << "]::" << met << " : " << msg

#define log_e(m,s) log_msg("ERROR",m,s)
#define log_w(m,s) log_msg("WARN",m,s)
#define log_i(m,s) log_msg("INFO",m,s)

using std::ostringstream;

namespace Device
{
// 1111111111111111111111111111111111111111111111111111111111111111111111111
// 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
// 1     Users don't modify this code!!!!                                  1
// 1     If you modify this code you may start a fire or a flood somewhere,1
// 1     and some human being may possible cease to exist. You don't want  1
// 1     to be charged with that!                                          1
// 1111111111111111111111111111111111111111111111111111111111111111111111111






// 2222222222222222222222222222222222222222222222222222222222222222222222222
// 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
// 2     (code for which only stubs were generated automatically)          2
// 2     You should add the implementation but dont alter the headers      2
// 2     (apart from constructor, in which you should complete initializati2
// 2     on list)                                                          2
// 2222222222222222222222222222222222222222222222222222222222222222222222222

/* sample ctr */
DIoLPowerMeter::DIoLPowerMeter (
    const Configuration::IoLPowerMeter& config,
    Parent_DIoLPowerMeter* parent
):
    Base_DIoLPowerMeter( config, parent)

    /* fill up constructor initialization list here */
    ,m_pm(nullptr)
{
    /* fill up constructor body here */
    // first probe the for the port that this meter is attached to

    m_comport = util::find_port(config.id());
    if (m_comport.size() == 0)
    {
      throw std::runtime_error("Couldn't find device port");
    }
    // now one can initate the object
    try
    {
      m_pm = new device::PowerMeter(m_comport,getBaudRate());
    }
    catch(std::exception &e)
    {
      LOG(Log::ERR) << "DIoLPowerMeter::DIoLPowerMeter : Failed to initialize the connection to the device";
      LOG(Log::ERR) << "DIoLPowerMeter::DIoLPowerMeter : Setting object in an unitialized state";

    }

}

/* sample dtr */
DIoLPowerMeter::~DIoLPowerMeter ()
{
  if (m_pm) delete m_pm;
}

/* delegates for cachevariables */



/* delegators for methods */
UaStatus DIoLPowerMeter::callSet_average (
    OpcUa_UInt16 target_value,
    UaString& response
)
{
    return OpcUa_BadNotImplemented;
}
UaStatus DIoLPowerMeter::callSet_range (
    OpcUa_Int16 target_value,
    UaString& response
)
{
    return OpcUa_BadNotImplemented;
}
UaStatus DIoLPowerMeter::callSet_pulse_width (
    OpcUa_UInt16 target_value,
    UaString& response
)
{
    return OpcUa_BadNotImplemented;
}
UaStatus DIoLPowerMeter::callSet_threshold (
    OpcUa_UInt16 target_value,
    UaString& response
)
{
    return OpcUa_BadNotImplemented;
}
UaStatus DIoLPowerMeter::callSet_wavelength (
    OpcUa_UInt16 target_value,
    UaString& response
)
{
    return OpcUa_BadNotImplemented;
}
UaStatus DIoLPowerMeter::callSet_measurement_mode (
    OpcUa_UInt16 target_value,
    UaString& response
)
{
    return OpcUa_BadNotImplemented;
}
UaStatus DIoLPowerMeter::callReset (

)
{
    return OpcUa_BadNotImplemented;
}

// 3333333333333333333333333333333333333333333333333333333333333333333333333
// 3     FULLY CUSTOM CODE STARTS HERE                                     3
// 3     Below you put bodies for custom methods defined for this class.   3
// 3     You can do whatever you want, but please be decent.               3
// 3333333333333333333333333333333333333333333333333333333333333333333333333

void DIoLPowerMeter::update()
{
  OpcUa_StatusCode status= OpcUa_Good;
  uint16_t range;
  m_pm->get_range_fast(range);
  getAddressSpaceLink()->setRange_selected(range, status);
}
}