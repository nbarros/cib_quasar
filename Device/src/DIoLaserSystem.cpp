
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.

    The stub of this file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.


 */


#include <Configuration.hxx> // TODO; should go away, is already in Base class for ages

#include <DIoLaserSystem.h>
#include <ASIoLaserSystem.h>

#include <DIoLLaserUnit.h>
#include <DIoLMotor.h>
#include <DIoLAttenuator.h>
#include <DIoLPowerMeter.h>
#include <DIoLCIB.h>
#include <thread>
#include <string>
#include <chrono>
#include <deque>

#define log_msg(s,met,dev,msg) "[" << s << "]::" << dev << ":" << met << " : " << msg

#define log_e(m,s) log_msg("ERROR","iols",m,s)
#define log_w(m,s) log_msg("WARN","iols",m,s)
#define log_i(m,s) log_msg("INFO","iols",m,s)

using std::ostringstream;

namespace Device
{
// 1111111111111111111111111111111111111111111111111111111111111111111111111
// 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
// 1     Users don't modify this code!!!!                                  1
// 1     If you modify this code you may start a fire or a flood somewhere,1
// 1     and some human being may possible cease to exist. You don't want  1
// 1     to be charged with that!                                          1
// 1111111111111111111111111111111111111111111111111111111111111111111111111






// 2222222222222222222222222222222222222222222222222222222222222222222222222
// 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
// 2     (code for which only stubs were generated automatically)          2
// 2     You should add the implementation but dont alter the headers      2
// 2     (apart from constructor, in which you should complete initializati2
// 2     on list)                                                          2
// 2222222222222222222222222222222222222222222222222222222222222222222222222

/* sample ctr */
DIoLaserSystem::DIoLaserSystem (
    const Configuration::IoLaserSystem& config,
    Parent_DIoLaserSystem* parent
):
    Base_DIoLaserSystem( config, parent)

    /* fill up constructor initialization list here */
        ,m_state(sOffline)
{
    /* fill up constructor body here */
    // this had to be in the constructor

    m_state_map.insert({sOffline,"offline"});
    //m_state_map.insert({sGood,"good"});
    m_state_map.insert({sReady,"ready"});
    m_state_map.insert({sBusy, "busy"});
    // m_state_map.insert({sWarmup,"warmup"});
    // m_state_map.insert({sPause,"pause"});
    // m_state_map.insert({sStandby,"standby"});
    // m_state_map.insert({sOperating,"operating"});
    m_state_map.insert({sError,"sError"});


      
}

/* sample dtr */
DIoLaserSystem::~DIoLaserSystem ()
{
}

/* delegates for cachevariables */



/* delegators for methods */
UaStatus DIoLaserSystem::callLoad_config (
    const UaString&  conf,
    UaString& response
)
{
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      json cfrag = json::parse(conf.toUtf8());
      st = config(cfrag,resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        msg << log_e("config","Configuration failed. See previous messages");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        if (!resp.contains("statuscode"))
        {
          resp["statuscode"] = OpcUa_BadInvalidArgument;
        }
      }
      else
      {
        msg << log_i("config","System configured.");
        resp["messages"].push_back(msg.str());
        resp["status"] = "OK";
        resp["statuscode"] = OpcUa_Good;
      }
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callCheck_ready (
    OpcUa_Boolean& ready
)
{
    // check the states of all systems
    // check all associated subsystems if they're ready
    bool rdy = true;
    for (Device::DIoLLaserUnit* lunit : iollaserunits())
    {
      rdy = lunit->is_ready();
      if (!rdy)
      {
        ready = false;
        return OpcUa_Good;
      }
    }
    for (Device::DIoLCIB* lcib : iolcibs())
    {
      rdy = lcib->is_ready();
      if (!rdy)
      {
        ready = false;
        return OpcUa_Good;
      }
    }
    for (Device::DIoLMotor* lmotor : iolmotors ())
    {
      rdy = lmotor->is_ready();
      if (!rdy)
      {
        ready = false;
        return OpcUa_Good;
      }
    }
    for (Device::DIoLAttenuator* latt : iolattenuators ())
    {
      rdy = latt->is_ready();
      if (!rdy)
      {
        ready = false;
        return OpcUa_Good;
      }
    }
    for (Device::DIoLPowerMeter *lpm : iolpowermeters())
    {
      rdy = lpm->is_ready();
      if (!rdy)
      {
        ready = false;
        return OpcUa_Good;
      }
    }
    ready = rdy;
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callStop (
    UaString& response
)
{
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = stop(resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    //response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callFire_at_position (
    const UaString&  arguments,
    UaString& answer
)
{
    const std::string lbl = "fire_at_pos";
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      std::vector<int32_t> target_pos;
      std::string approach;
      uint32_t num_pulses;
      bool lbls;
      resp["messages"] = json::array();
      if (!process_fap_arguments(arguments,target_pos,approach,num_pulses,lbls,resp))
      {
        reset(msg);
        msg << log_e(lbl.c_str(),"Failed to parse arguments");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        answer = UaString(resp.dump().c_str());
        return OpcUa_Good;
      }
      //FIXME: Implement the lbls part (not setting it yet)
      st = fire_at_position(target_pos,approach,num_pulses,resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught internal error : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught STD exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    answer = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callFire_segment (
    const UaString&  arguments,
    UaString& answer
)
{
    const std::string lbl = "fire_segment";
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      // parse the json here
      json config= json::parse(arguments.toUtf8());
      std::vector<int32_t> start_pos, end_pos;

      if (!config.contains("start_position"))
      {
        msg.clear(); msg.str("");
        msg << log_e(lbl.c_str(),"Missing mandatory field 'start_position'");
        throw std::runtime_error(msg.str());
      }
      else
      {
        start_pos = config.at("start_position").get<std::vector<int32_t>>();
        if (start_pos.size() != 3)
        {
          msg.clear(); msg.str("");
          msg << log_e(lbl.c_str(),"Malformed start position. Three coordinates are expected (got ") << start_pos.size() << ")";
          throw std::runtime_error(msg.str());
        }
      }
      if (!config.contains("end_position"))
      {
        msg.clear(); msg.str("");
        msg << log_e(lbl.c_str(),"Missing mandatory field 'end_position'");
        throw std::runtime_error(msg.str());
      }
      else
      {
        end_pos = config.at("end_position").get<std::vector<int32_t>>();
        if (end_pos.size() != 3)
        {
          msg.clear(); msg.str("");
          msg << log_e(lbl.c_str(),"Malformed end position. Three coordinates are expected (got ") << end_pos.size() << ")";
          throw std::runtime_error(msg.str());
        }
      }
      st = fire_segment(start_pos,end_pos,resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("fire_segment","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("fire_segment","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("fire_segment","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      LOG(Log::ERR) << msg.str();
      resp["statuscode"] = OpcUa_Bad;
    }
    answer = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callExecute_scan (
    const UaString&  plan,
    UaString& answer
)
{
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;

    UaStatus st;
    try
    {
      json scan = json::parse(plan.toUtf8());
      st = execute_scan(scan,resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("execute_scan","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("execute_scan","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("execute_scan","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      LOG(Log::ERR) << msg.str();
    }
    answer = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callExecute_grid_scan (
    const UaString&  plan,
    UaString& answer
)
{
  std::ostringstream msg("");
  bool got_exception = false;
  json resp;
  if (!resp.contains("messages"))
  {
    resp["messages"] = json::array();
  }
  UaStatus st;
  try
  {
    json scan = json::parse(plan.toUtf8());
    st = execute_grid_scan(scan, resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      msg << log_e("grid_scan", "Failed to initiate grid scan. See previous messages");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
    }
    else
    {
      msg << log_i("grid_scan", "Grid scan initiated successfully.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
  }
  catch (json::exception &e)
  {
    msg.clear();
    msg.str("");
    msg << log_e("grid_scan", "Caught JSON exception : ") << e.what();
    got_exception = true;
  }
  catch (std::exception &e)
  {
    msg.clear();
    msg.str("");
    msg << log_e("grid_scan", "Caught JSON exception : ") << e.what();
    got_exception = true;
  }
  catch (...)
  {
    msg.clear();
    msg.str("");
    msg << log_e("grid_scan", "Caught an unknown exception");
    got_exception = true;
  }
  if (got_exception)
  {
    resp["status"] = "ERROR";
    resp["messages"].push_back(msg.str());
    resp["statuscode"] = OpcUa_Bad;
    LOG(Log::ERR) << msg.str();
  }
  answer = UaString(resp.dump().c_str());
  return OpcUa_Good;
}
UaStatus DIoLaserSystem::callPause (
    UaString& answer
)
{
    const std::string lbl = "pause";
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = pause(resp);
    }
    catch (json::exception &e)
    {
      msg.clear();
      msg.str("");
      msg << log_e(lbl.c_str(), "Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch (std::exception &e)
    {
      msg.clear();
      msg.str("");
      msg << log_e(lbl.c_str(), "Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch (...)
    {
      msg.clear();
      msg.str("");
      msg << log_e(lbl.c_str(), "Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    answer = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callStandby (
    UaString& answer
)
{
    const std::string lbl = "standby";
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = standby(resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    answer = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callResume (
    UaString& response
)
{
    const std::string lbl = "resume";
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = resume(resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught an unknown exception");
      got_exception = true;
    } if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callWarmup_laser (
    UaString& response
)
{
    const std::string lbl = "warmup";
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = warmup(resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good; 
}
UaStatus DIoLaserSystem::callShutdown (
    UaString& response
)
{
    std::ostringstream msg("");
    const std::string lbl = "shutdown";
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = shutdown(resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    response = UaString(resp.dump().c_str()); return OpcUa_Good;
}
UaStatus DIoLaserSystem::callMove_to_pos (
    const UaString&  arguments,
    UaString& response
)
{
    const std::string lbl = "move_to_pos";
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    // Validate and parse the input arguments
    std::vector<int32_t> target_pos;
    std::string approach;
    try
    {
      if (!process_move_arguments(arguments, target_pos, approach, resp))
      {
        response = UaString(resp.dump().c_str());
        return OpcUa_BadInvalidArgument;
      }
      LOG(Log::INF) << log_i("move_to_pos","Moving to position " << target_pos[0] << "," << target_pos[1] << "," << target_pos[2] << " with approach " << approach);
      st = move_to_pos(target_pos, approach, resp); // convert to an array that //std::string appr(approach.toUtf8()); st = move_to_pos(target_pos,approach,resp);  catch(json::exception &e)
    }
    catch (json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught an unknown exception");
      got_exception = true; 
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callClear_error (
    UaString& response
)
{
  const std::string lbl = "clear_error";
  std::ostringstream msg("");
  bool got_exception = false;
  json resp;
  UaStatus st;
  // Validate and parse the input arguments
  std::vector<int32_t> target_pos;
  std::string approach;
  try
  {
    st = clear_error(resp); // convert to an array that //std::string appr(approach.toUtf8()); st = move_to_pos(target_pos,approach,resp);  catch(json::exception &e)
  }
  catch (json::exception &e)
  {
    msg.clear();
    msg.str("");
    msg << log_e(lbl.c_str(), "Caught JSON exception : ") << e.what();
    got_exception = true;
  }
  catch (std::exception &e)
  {
    msg.clear();
    msg.str("");
    msg << log_e(lbl.c_str(), "Caught JSON exception : ") << e.what();
    got_exception = true;
  }
  catch (...)
  {
    msg.clear();
    msg.str("");
    msg << log_e(lbl.c_str(), "Caught an unknown exception");
    got_exception = true;
  }
  if (got_exception)
  {
    resp["status"] = "ERROR";
    resp["messages"].push_back(msg.str());
    resp["statuscode"] = OpcUa_Bad;
  }
  response = UaString(resp.dump().c_str());
  return OpcUa_Good;
}

// 3333333333333333333333333333333333333333333333333333333333333333333333333
// 3     FULLY CUSTOM CODE STARTS HERE                                     3
// 3     Below you put bodies for custom methods defined for this class.   3
// 3     You can do whatever you want, but please be decent.               3
// 3333333333333333333333333333333333333333333333333333333333333333333333333
  UaStatus DIoLaserSystem::config(json &conf, json &resp)
    {
      const std::string lbl = "config";
      UaStatus st;
      std::ostringstream msg("");
      bool got_exception = false;
      try
      {
        // Check if "messages" key already exists in the response
        if (!resp.contains("messages") || !resp["messages"].is_array())
        {
          resp["messages"] = json::array();
        }
        // first thing is to check that we are in offline state
        // configure should never be called in any other situation
        if ((m_state != sOffline))
        {
          reset(msg);
          msg << log_e(lbl.c_str(),"System is operating. Can only configure when stopped.");
          resp["status"] = "ERROR";
          resp["messages"].push_back(msg.str());
          resp["statuscode"] = OpcUa_BadInvalidState;
          LOG(Log::ERR) << msg.str();
          return OpcUa_BadInvalidState;
        }
        // validate the config fragment
        if (!validate_config_fragment(conf,resp))
        {
          reset(msg);
          msg << log_e(lbl.c_str(),"Failed to validate configuration fragment. See previous messages");
          resp["status"] = "ERROR";
          resp["messages"].push_back(msg.str());
          if (!resp.contains("statuscode"))
          {
            resp["statuscode"] = OpcUa_BadInvalidArgument;
          }
          return OpcUa_BadInvalidArgument;
        }
        // validation passed. Loop over the parts and pass the corresponding configuration
        // fragment
        // NOTE: Is the order relevant?
        for (json::iterator it = conf.begin(); it != conf.end(); ++it)
        {
          LOG(Log::INF) << "Processing " << it.key() << " : " << it.value() << "\n";
          //
          if (it.key() == "motors")
          {
            // there are up to three motors.
            // start by checking that
            json mconf = it.value();
            if (mconf.size() != iolmotors().size())
            {
              reset(msg);
              msg << log_e(lbl.c_str(),"Malformed configuration. Have ") << iolmotors().size()
                                                          << " motors, but configuration shows " << it.value().size();
              resp["status"] = "ERROR";
              resp["messages"].push_back(msg.str());
              resp["statuscode"] = OpcUa_BadInvalidArgument;
              return OpcUa_BadInvalidArgument;
            }
            // we have matching sizes, configure them in order
            for (size_t i = 0; i < mconf.size(); ++i)
            {
              json mfrag = mconf.at(i);
              for (size_t j = 0; j < iolmotors().size(); ++j)
              {
                if (iolmotors().at(j)->id() == mfrag.at("id").get<std::string>())
                {
                  st = iolmotors().at(j)->config(mfrag,resp);
                  if (st != OpcUa_Good)
                  {
                    reset(msg);
                    resp["status"] = "ERROR";
                    resp["messages"].push_back(msg.str());
                    if (!resp.contains("statuscode"))
                    {
                      resp["statuscode"] = OpcUa_BadInvalidArgument;
                    }
                    return OpcUa_BadInvalidArgument;
                  }
                  // if it configured well, add the entry to the coordinate map
                  m_map_motor_coordinates.insert(std::pair<size_t,size_t>(iolmotors().at(j)->get_coordinate_index(),j));
                }
                // if not, continue the loop
              }
            }
            // if we reached this point, all motors are configured
          }
          if (it.key() == "laser")
          {
            // there is only 1 laser
            json lconf = it.value();
            st = iollaserunit()->config(lconf,resp);
            if (st != OpcUa_Good)
            {
              reset(msg);
              msg << log_e(lbl.c_str(),"Failed to configure laser.");
              resp["status"] = "ERROR";
              resp["messages"].push_back(msg.str());
              if (!resp.contains("statuscode"))
              {
                resp["statuscode"] = OpcUa_BadInvalidArgument;
              }
              return OpcUa_BadInvalidArgument;
            }
          }
          if (it.key() == "attenuator")
          {
            // there is only 1 attenuator
            json aconf = it.value();
            st = iolattenuator()->config(aconf,resp);
            if (st != OpcUa_Good)
            {
              reset(msg);
              msg << log_e(lbl.c_str(),"Failed to configure attenuator.");
              resp["status"] = "ERROR";
              resp["messages"].push_back(msg.str());
              if (!resp.contains("statuscode"))
              {
                resp["statuscode"] = OpcUa_BadInvalidArgument;
              }
              return OpcUa_BadInvalidArgument;
            }
          }
          // For now there is no configuration necessary for the CIB
          if (it.key() == "cib")
          {
            json aconf = it.value();
            st = iolcib()->config(aconf,resp);
            if (st != OpcUa_Good)
            {
              reset(msg);
              msg << log_e(lbl.c_str(),"Failed to configure CIB.");
              resp["status"] = "ERROR";
              resp["messages"].push_back(msg.str());
              if (!resp.contains("statuscode"))
              {
                resp["statuscode"] = OpcUa_BadInvalidArgument;
              }
              return OpcUa_BadInvalidArgument;
            }
          }
          // ------------------
          // power meter : one unit
          //----------------------------------
          if (it.key() == "power_meter")
          {
            // there is only 1
            json pconf = it.value();
            st = iolpowermeter()->config(pconf,resp);
            if (st != OpcUa_Good)
            {
              reset(msg);
              msg << log_e(lbl.c_str(),"Failed to configure power meter.");
              resp["status"] = "ERROR";
              resp["messages"].push_back(msg.str());
              if (!resp.contains("statuscode"))
              {
                resp["statuscode"] = OpcUa_BadInvalidArgument;
              }
              return OpcUa_BadInvalidArgument;
            }
          }
        } // loop json
        // if we reached this point, the configurations are all good
        //update_state(sReady);
      }
      catch(json::exception &e)
      {
        msg.clear(); msg.str("");
        msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
        got_exception = true;
      }
      catch(std::runtime_error &e)
      {
        msg.clear(); msg.str("");
        msg << log_e(lbl.c_str(),"Caught runtime error : ") << e.what();
        got_exception = true;
      }
      catch(std::exception &e)
      {
        msg.clear(); msg.str("");
        msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
        got_exception = true;
      }
      catch(...)
      {
        msg.clear(); msg.str("");
        msg << log_e(lbl.c_str(),"Caught an unknown exception");
        got_exception = true;
      }
      if (got_exception)
      {
        reset(msg);
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_Bad;
        LOG(Log::ERR) << msg.str();
        return OpcUa_Bad;
      }
      else
      {
        reset(msg);
        msg << log_i(lbl.c_str(),"IoLS configured.");
        resp["status"] = "OK";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_Good;
      }
      // set state back to ready for commands
      if (m_state != sError)
      {
        update_state(sReady);
      }
      return OpcUa_Good;
    }
  UaStatus DIoLaserSystem::check_ready(bool &ready)
  {
    ready = is_ready();
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::stop(json &resp)
  {
    UaStatus st;
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // first thing to be stopped is the laser
      // this should only fail if something is not configured
      //st = iollaserunit()->stop(resp);
      st = iollaserunit()->stop(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        msg << log_e("stop","Failed to stop laser unit. See previous messages");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        if (!resp.contains("statuscode"))
        {
          resp["statuscode"] = OpcUa_Bad;
        }
        return st;
      }
      // next stop the motors
      for (Device::DIoLMotor* lmotor : iolmotors ())
      {
        st = lmotor->motor_stop(resp);
        if (st != OpcUa_Good)
        {
          reset(msg);
          msg << log_e("stop","Failed to stop motor ") << lmotor->id() << ". See previous messages.";
          resp["status"] = "ERROR";
          resp["messages"].push_back(msg.str());
          if (!resp.contains("statuscode"))
          {
            resp["statuscode"] = OpcUa_Bad;
          }
          return st;
        }
      }
      // none of the other systems are actually critical
      // however, if we stop the laser, there is little point in
      // keeping the power meter reading
      st = iolpowermeter()->stop_readings(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        msg << log_e("stop","Failed to stop power meter ") << iolpowermeter()->getFullName() << ". See previous messages.";
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        if (!resp.contains("statuscode"))
        {
          resp["statuscode"] = OpcUa_Bad;
        }
        return st;
      }
      // in this case we should not go back to ready, or we 
      // will have to warmup again
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught runtime error : ") << e.what();
      got_exception = true;

    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught an unknown exception");
      got_exception = true;
    }
    // reset the state back tp ready (or error, if that was the case)
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      LOG(Log::ERR) << msg.str();
      return OpcUa_Bad;
    }
    else
    {
      reset(msg);
      msg << log_i("stop","IoLS system stopped.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::fire_at_position(const std::vector<int32_t>&  target_pos, const std::string &approach, uint32_t num_pulses, json &resp)
  {
    const std::string lbl = "fire_at_position";
    UaStatus st;
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // first check that the whole system is in a state that could be considered as valid
      // the tricky part here is that this definition depends on many things
      /**
       * For example, the laser can be considered ready if it is in sLasing, sReady or sStandby states
       * The motor is ready if it is not moving and has a speed defined
       * The power meter is always ready, as far as it is configured
       * The attenuator is always ready
       */
      if (!is_ready())
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e(lbl.c_str(),"System is not ready to operate. Check the status of the various subsystems.");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }
      // step 0: Check if the laser is in a valid operating state
      // these are sLasing, sPause and sStandby
      // any other state requires extra stuff to operate
      if (!iollaserunit()->good_for_operation())
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e(lbl.c_str(),"Laser is not in the right state.");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }
      // if it is ready, pass on the information to the respective subsystems
      //
      // in this case the laser is not going to just start firing, but simply fire a discrete number of pulses
      // there is a specific callfor that under the IOLaser device
      // -- the motors are identified, so each entry refers to a motor
      // do a check on the order of position and number of motors
      if (target_pos.size()!= iolmotors().size())
      {
        // different number of position coordinates and motors
        resp["status"] = "ERROR";
        reset(msg);
        msg << log_e(lbl.c_str(),"Different number of coordinates (")
                                                              << target_pos.size() << ") and available motors ("
                                                              << iolmotors().size() << "). Refusing to operate.";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      // validation of approach has already been done
      //
      if (num_pulses < 1)
      {
        resp["status"] = "ERROR";
        std::ostringstream msg("");
        msg << log_e(lbl.c_str(),"Invalid number of pulses (")
                                                              << num_pulses << "). Value must be at least 1.";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      //
      // ready to operate
      // below this point this becomes a separate thread, as the motors will be moving
      //update_state(sOperating);
      init_fire_point_task(target_pos,approach,num_pulses);
    }
    catch(json::exception &e)
    {
      reset(msg);
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      reset(msg);
      msg << log_e("stop","Caught runtime error : ") << e.what();
      got_exception = true;

    }
    catch(std::exception &e)
    {
      reset(msg);
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      reset(msg);
      msg << log_e("stop","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      LOG(Log::ERR) << msg.str();
      return OpcUa_Bad;
    }
    else
    {
      reset(msg);
      msg << log_i("stop","Command successful.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::fire_segment(
      const std::vector<OpcUa_Int32>&  spos,
      const std::vector<OpcUa_Int32>&  lpos,
      json& resp
  )
  {
    UaStatus st;
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // first check that the whole system is in a state that could be considered as valid
      // the tricky part here is that this definition depends on many things
      /**
       * For example, the laser can be considered ready if it is in sLasing, sReady or sStandby states
       * The motor is ready if it is not moving and has a speed defined
       * The power meter is always ready, as far as it is configured
       * The attenuator is always ready
       */
      if (!is_ready())
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("fire_segment","System is not ready to operate. Check the status of the various subsystems.");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }
      // step 0: Check if the laser is in a valid operating state
      // these are sLasing, sPause and sStandby
      // any other state requires extra stuff to operate
      if (!iollaserunit()->good_for_operation())
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("fire_segment","Laser is not in the right state.");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }

      //
      // Operation sequence
      //
      // 1. set target destination for all motors
      // 2. move motors into start point
      // 3. set inital fire position
      // 5. initiate movement
      // 6. open iris
      // 7. When reaching destination, close iris

      // if it is ready, pass on the information to the respective subsystems
      //
      // in this case the laser is not going to just start firing, but simply fire a discrete number of pulses
      // there is a specific callfor that under the IOLaser device
      // -- the motors are identified, so each entry refers to a motor
      // do a check on the order of position and number of motors
      if (spos.size()!= iolmotors().size())
      {
        // different number of position coordinates and motors
        resp["status"] = "ERROR";
        reset(msg);
        msg << log_e("fire_segment","Different number of start coordinates (")
                                                              << spos.size() << ") and available motors ("
                                                              << iolmotors().size() << "). Refusing to operate.";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      // do the same for the target
      if (lpos.size()!= iolmotors().size())
      {
        // different number of position coordinates and motors
        resp["status"] = "ERROR";
        reset(msg);
        msg << log_e("fire_segment","Different number of end coordinates (")
                                                              << spos.size() << ") and available motors ("
                                                              << iolmotors().size() << "). Refusing to operate.";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      // second check. Only one of the motors should be moving,
      // or we're in for a world of pain
      int n_moving_motors = 0;
      for (size_t i = 0; i < spos.size(); ++i)
      {
        if (spos.at(i) != lpos.at(i))
        {
          n_moving_motors++;
        }
      }
      if (n_moving_motors != 1)
      {
        resp["status"] = "ERROR";
        reset(msg);
        msg << log_e("fire_segment","More than one motor moving. (")
                                                              << n_moving_motors << "). Expected 1. Refusing to operate.";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      // all conditions are checked. Now start the operation
      // the status is set to sOperating and a separate thread is ran to process it
      // however, during this time, nothing else can be done with the system
      // update_state(sOperating);
      init_segment_task(spos,lpos);
      // this is the poor mans equivalent of an async method
      // for now consider the task done
    }
    catch(json::exception &e)
    {
      reset(msg);
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      reset(msg);
      msg << log_e("stop","Caught runtime error : ") << e.what();
      got_exception = true;

    }
    catch(std::exception &e)
    {
      reset(msg);
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      reset(msg);
      msg << log_e("stop","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      LOG(Log::ERR) << msg.str();
      return OpcUa_Bad;
    }
    else
    {
      reset(msg);
      msg << log_i("stop","Command successful.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }
  void DIoLaserSystem::init_segment_task(const std::vector<OpcUa_Int32>&  spos,
                                         const std::vector<OpcUa_Int32>&  lpos
  )
  {
    // this task runs on a separate thread
    // since there is no return to the user space
    // messages are queued in a separate variable that can then be queried
    // also keep in mind that at this stage all verifications have been performed, so
    // the task does not need base checks
    std::thread([this, spos, lpos]()
                {
      std::ostringstream msg;
      if (m_state != sError)
      {
        update_state(sBusy);
      }
      else
      {
        // if we are in error state don't do anything
        json resp;
        reset(msg);
        msg << log_e("segment_task", "System is in error state. Aborting.");
        resp["status"] = "ERROR";
        resp["messages"] = msg.str();
        resp["statuscode"] = OpcUa_BadInvalidState;
        update_task_message_queue(resp);
        return;
      }
                  update_state(sBusy);
      segment_task(spos,lpos);
      // once the task is done check if there is an error
      if (m_state == sError)
      {
        LOG(Log::ERR) << log_e("segment_task","Bugger. Segment failed.");
      }
      else
      {
        // we should update state back to sPause
        std::ostringstream msg("");
        reset(msg);
        if (!m_task_message_queue.contains("status"))
        {
          m_task_message_queue["status"] = "OK";
        }
        msg << log_e("fire_segment","Operation was successful.");
        m_task_message_queue["messages"].push_back(msg.str());
        if (!m_task_message_queue.contains("statuscode"))
        {
          m_task_message_queue["statuscode"] = OpcUa_Good;
        }
        if (m_state != sError)
        {
          update_state(sReady);
        }
      } })
        .detach();
  }
  void DIoLaserSystem::segment_task(const std::vector<OpcUa_Int32>&  spos,
                                    const std::vector<OpcUa_Int32>&  lpos
  )
  {
    const std::string lbl("segment_task");
    UaStatus st;
    std::ostringstream msg("");
    json resp;
    if (!resp.contains("messages"))
    {
      resp["messages"] = json::array();
    }
    //
    // ready to operate
    // -- be sure to set the shutter closed until destination is reached
    // the logic is the following
    // 0. Make sure that the laser is in Pause state
    // 1. Call each of the the motors to move to the starting position
    // 2. Set the target position for each motor
    // 3. Initiate movement
    // 4. call resume (switch to sLasing)
    // 5. Wait for motors to report end of travel
    // 6. switch back to pause
    // 7. Assess success
    //
    // step 0: before we even start doing anything
    // force the laser into a pause state
    st = pause(resp);
    //st = iollaserunit()->pause(resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      msg << log_e(lbl.c_str(),"Failed to set laser into Pause state");;
      resp["messages"].push_back(msg.str());
      resp["status"] = "ERROR";
      LOG(Log::ERR) << msg.str();
      resp["statuscode"] = static_cast<uint32_t>(st);
      // nothing is being done, so just terminate this task
      // update the state to error
      // -- if we cannot go into pause, force a shutdown
      standby(resp);
      update_task_message_queue(resp);
      update_state(sError);
      return;
    }
    // step 1
    // we can initiate the movement
    st = move_motor(spos,resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      msg << log_e(lbl.c_str(), "Failed to move to start position");
      ;
      resp["messages"].push_back(msg.str());
      resp["status"] = "ERROR";
      resp["statuscode"] = static_cast<uint32_t>(st);
      LOG(Log::ERR) << msg.str();
      update_task_message_queue(resp);
      // nothing is being done, so just terminate this task
      // update the state to error
      update_state(sError);
      return;
    }
    // step 1.2: wait until motors are in place
    // since this is a separate task, we *must* wait for things to be ready
    wait_for_motors(spos);
    // bool is_moving = true;
    // while (is_moving)
    // {
    //   is_moving = false;
    //   for (Device::DIoLMotor* lmotor : iolmotors ())
    //   {
    //     is_moving |= lmotor->is_moving();
    //   }
    //   std::this_thread::sleep_for(std::chrono::milliseconds(50));
    // }
    //
    //
    // we have reached the destination
    // step 2: set target position
    st = move_motor(lpos,resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      msg << log_e(lbl.c_str(), "Failed to initiate movement to destination");
      ;
      resp["messages"].push_back(msg.str());
      resp["status"] = "ERROR";
      resp["statuscode"] = static_cast<uint32_t>(st);
      update_task_message_queue(resp);
      LOG(Log::ERR) << msg.str();
      // nothing is being done, so just terminate this task
      // update the state to error
      update_state(sError);
      return;
    }
    //
    // step 3: initiate movement (already done)
    //
    //
    // step 2.0 : start power meter readings
    for (Device::DIoLPowerMeter* lmeter : iolpowermeters())
    {
      // this may or not fail, since the power meter 
      // may or may not be already taking data
      st = lmeter->start_readings(resp);
    }

    // step 4: tell laser to get into business
    //
    st = resume(resp);
    // st = iollaserunit()->resume(resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      resp["status"] = "ERROR";
      msg << log_e(lbl.c_str(), "Failed to activate laser. Check previous messages.");
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = static_cast<uint32_t>(st);
      LOG(Log::ERR) << msg.str();
      // force a pause (again)
      pause(resp);
      // iollaserunit()->pause(resp);
      update_task_message_queue(resp);
      update_state(sError);
      return;
    }
    // step 5: wait for motors to report stopped
    wait_for_motors(lpos);
    // step 6: switch back to pause
    // st = iollaserunit()->pause(resp);
    st = pause(resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      resp["status"] = "ERROR";
      msg << log_e(lbl.c_str(),"Failed to pase laser at the end. Check previous messages.");
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = static_cast<uint32_t>(st);
      LOG(Log::ERR) << msg.str();
      // force a pause (again)
      iollaserunit()->pause(resp);
      update_task_message_queue(resp);
      update_state(sError);
      return;
    }
    // if it reached this point, just update the queue
    update_task_message_queue(resp);
  }


  UaStatus DIoLaserSystem::move_motor(
      const std::vector<OpcUa_Int32>&  position,
      json &resp)
  {
    std::ostringstream msg("");
    UaStatus st;

    for (std::vector<OpcUa_Int32>::size_type idx = 0; idx < position.size(); idx++)
    {
      Device::DIoLMotor* lmotor = iolmotors().at(m_map_motor_coordinates.at(idx));
      st = lmotor->move_wrapper(position.at(idx),resp);
      if (st != OpcUa_Good)
      {
        resp["status"] = "ERROR";
        reset(msg);
        msg << log_e("move_motor","Failed to set target position for motor (id : ")
                                                        << lmotor->get_id() << ").";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = static_cast<uint32_t>(st);
        // nothing is being done, so just terminate this task
        return st;
      }
    }
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::execute_scan(json &plan, json &resp)
  {
    // this one is a hell of a tricky one
    // it is in many ways similar to fire segment, with a few caveats
    UaStatus st;
    std::ostringstream msg("");
    bool got_exception = false;
    const std::string lbl = "execute_scan";
    try
    {
      // first check that the whole system is in a state that could be considered as valid
      // the tricky part here is that this definition depends on many things
      /**
       * For example, the laser can be considered ready if it is in sLasing, sReady or sStandby states
       * The motor is ready if it is not moving and has a speed defined
       * The power meter is always ready, as far as it is configured
       * The attenuator is always ready
       */
      if (!is_ready())
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e(lbl.c_str(),"System is not ready to operate. Check the status of the various subsystems.");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }
      // step 0: Check if the laser is in a valid operating state
      // these are sLasing, sPause and sStandby
      // any other state requires extra stuff to operate
      if (!iollaserunit()->good_for_operation())
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e(lbl.c_str(),"Laser is not in the right state.");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }
      if (!plan.contains("scan_plan"))
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e(lbl.c_str(), "Malformed configuration fragment. Missing entry \"scan_plan\"");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidArgument;
      }
      if (!validate_scan_plan(plan,resp))
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e(lbl.c_str(), "Invalid scan plan. Check previous messages.");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidArgument;
      }
      // all is good. Let's sell ketchup
      // the operation itself will run on a detached thread
      // update_state(sOperating);
      init_scan_task(plan);
    }
    catch(json::exception &e)
    {
      reset(msg);
      msg << log_e(lbl.c_str(), "Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      reset(msg);
      msg << log_e(lbl.c_str(), "Caught runtime error : ") << e.what();
      got_exception = true;

    }
    catch(std::exception &e)
    {
      reset(msg);
      msg << log_e(lbl.c_str(), "Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      reset(msg);
      msg << log_e(lbl.c_str(), "Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      LOG(Log::ERR) << msg.str();
      return OpcUa_Bad;
    }
    else
    {
      reset(msg);
      msg << log_i(lbl.c_str(), "Command successful.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }
  void DIoLaserSystem::init_scan_task(json &fragments)
  {
    // this task runs on a separate thread
    // since there is no return to the user space
    // messages are queued in a separate variable that can then be queried
    // also keep in mind that at this stage all verifications have been performed, so
    // the task does not need base checks
    std::thread([this,fragments]()
                {
      UaStatus st;
      std::ostringstream msg("");
      json resp;
      if (m_state != sError)
      {
        update_state(sBusy);
      }
      else
      {
        // if we are in error state don't do anything
        json resp;
        reset(msg);
        msg << log_e("scan_task", "System is in error state. Aborting.");
        resp["status"] = "ERROR";
        resp["messages"] = msg.str();
        resp["statuscode"] = OpcUa_BadInvalidState;
        update_task_message_queue(resp);
        return;
      }
      //
      // ready to operate
      // -- be sure to set the shutter is closed in all interim moments
      // the logic is the following
      // Operation sequence
      //
      // 0. Make sure that the laser is in Pause state
      // 1. grab the first segment [start : end]
      // 2. call fire_segment
      // 3. move to beginning of next segment
      // 5. repeat

      // 1. Call each of the the motors to move to the starting position
      // 2. Set the target position for each motor
      // 3. Initiate movement
      // 4. call resume (switch to sLasing)
      // 5. Wait for motors to report end of travel
      // 6. switch back to pause
      // 7. Assess success
      //
      // step 0: before we even start doing anything
      // force the laser into a pause state
      // st = iollaserunit()->pause(resp);
      const std::string lbl("scan_task");
      st = pause(resp);
      if (st != OpcUa_Good)
      {
        update_task_message_queue(resp);
        update_state(sError);
        return;
      }
      int i = 0;
      // 1. grab segment
      for (auto item: fragments.at("scan_plan"))
      {
        std::vector<int32_t> spos = item.at("start");
        std::vector<int32_t> epos = item.at("end");
        // we have the positions. So all we need is to move the segment
        // lauch a whole new thread for this segment
        segment_task(spos,epos);
        if (m_state == sError)
        {
          // the task failed
          // switch to pause and return
          reset(msg);
          msg << log_e(lbl.c_str(), "Segment failed to process. Entry ") << i;
          if (!m_task_message_queue.contains("status"))
          {
            m_task_message_queue["status"] = "ERROR";
          }
          m_task_message_queue["messages"].push_back(msg.str());
          if (!m_task_message_queue.contains("statuscode"))
          {
            m_task_message_queue["statuscode"] = OpcUa_Bad;
          }
          return;
        }
        // increment entry
        i++;
      }
      // If we reached this stage, the scan seems to have completed
      // tell the laser to pause
      // st = iollaserunit()->pause(resp);
      st = pause(resp);
      if (st != OpcUa_Good)
      {
        update_task_message_queue(resp);
        reset(msg);
        msg << log_e(lbl.c_str(), "Failed to pause laser at the end. Check previous messages.");
        if (!m_task_message_queue.contains("status"))
        {
          m_task_message_queue["status"] = "ERROR";
        }
        m_task_message_queue["messages"].push_back(msg.str());
        if (!m_task_message_queue.contains("statuscode"))
        {
          m_task_message_queue["statuscode"] = OpcUa_Bad;
        }
        update_state(sError);
        return;
      }
      // if it reached this stage, all is well and we should update the state back to
      // sPause
      pause(resp);
      update_task_message_queue(resp);
      reset(msg);
      msg << log_i(lbl.c_str(), "Operation was successful.");
      if (!m_task_message_queue.contains("status"))
      {
        m_task_message_queue["status"] = "OK";
      }
      m_task_message_queue["messages"].push_back(msg.str());
      if (!m_task_message_queue.contains("statuscode"))
      {
        m_task_message_queue["statuscode"] = OpcUa_Good;
      }
      if (m_state != sError)
      {
        update_state(sReady);
      }
                }
    ).detach();
  }
  UaStatus DIoLaserSystem::pause(json &resp)
  {
    // this is largely aimed at the laser
    const std::string lbl("pause");
    UaStatus st;
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // first check that the whole system is in a state that could be considered as valid
      // the tricky part here is that this definition depends on many things
      /**
       * For example, the laser can be considered ready if it is in sLasing, sReady or sStandby states
       * The motor is ready if it is not moving and has a speed defined
       * The power meter is always ready, as far as it is configured
       * The attenuator is always ready
       */
      // if (m_state == sOffline)
      // {
      //   // system is not even configured. Nothing to be done
      //   reset(msg);
      //   resp["status"] = "ERROR";
      //   msg << log_e(lbl.c_str(),"System is not ready to operate. Check the status of the various subsystems.");
      //   resp["messages"].push_back(msg.str());
      //   resp["statuscode"] = OpcUa_BadInvalidState;
      //   LOG(Log::ERR) << msg.str();
      //   return OpcUa_BadInvalidState;
      // }
      st= iollaserunit()->pause(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e(lbl.c_str(), "Laser failed to pause. Check previous messages.");
        resp["messages"].push_back(msg.str());
        if (!resp.contains("statuscode"))
        {
          resp["statuscode"] = OpcUa_BadInvalidState;
        }
        return OpcUa_BadInvalidState;
      }
      // update_state(sPause);
    }
    catch(json::exception &e)
    {
      reset(msg);
      msg << log_e("pause","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      reset(msg);
      msg << log_e("pause","Caught runtime error : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      reset(msg);
      msg << log_e("pause","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      reset(msg);
      msg << log_e("pause","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      LOG(Log::ERR) << msg.str();
      return OpcUa_Bad;
    }
    else
    {
      reset(msg);
      msg << log_i("pause","Command successful.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::standby(json &resp)
  {
    // this is largely aimed at the laser
    const std::string lbl("standby");
    UaStatus st;
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // first check that the whole system is in a state that could be considered as valid
      // the tricky part here is that this definition depends on many things
      /**
       * For example, the laser can be considered ready if it is in sLasing, sReady or sStandby states
       * The motor is ready if it is not moving and has a speed defined
       * The power meter is always ready, as far as it is configured
       * The attenuator is always ready
       */
      // if (m_state == sOffline)
      // {
      //   // system is not even configured. Nothing to be done
      //   reset(msg);
      //   resp["status"] = "ERROR";
      //   msg << log_e(lbl.c_str(),"System is not ready to operate. Check the status of the various subsystems.");
      //   resp["messages"].push_back(msg.str());
      //   resp["statuscode"] = OpcUa_BadInvalidState;
      //   LOG(Log::ERR) << msg.str();
      //   return OpcUa_BadInvalidState;
      // }
      st= iollaserunit()->standby(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e(lbl.c_str(),"Laser failed to pause. Check previous messages.");
        resp["messages"].push_back(msg.str());
        if (!resp.contains("statuscode"))
        {
          resp["statuscode"] = OpcUa_BadInvalidState;
        }
        return OpcUa_BadInvalidState;
      }
      // update_state(sStandby);
    }
    catch(json::exception &e)
    {
      reset(msg);
      msg << log_e("standby","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      reset(msg);
      msg << log_e("standby","Caught runtime error : ") << e.what();
      got_exception = true;

    }
    catch(std::exception &e)
    {
      reset(msg);
      msg << log_e("standby","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      reset(msg);
      msg << log_e("standby","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      LOG(Log::ERR) << msg.str();
      return OpcUa_Bad;
    }
    else
    {
      reset(msg);
      msg << log_i(lbl.c_str(),"Command successful.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::resume(json &resp)
  {
    // this is largely aimed at the laser
    UaStatus st;
    std::ostringstream msg("");
    const std::string lbl("resume");
    // once again, this is primarily aimed at the laser
    // also, make sure to activate the
    Device::DIoLLaserUnit::Status sl = iollaserunit()->get_state();
    if ((sl != DIoLLaserUnit::sLasing) && (sl != DIoLLaserUnit::sPause) && (sl != DIoLLaserUnit::sStandby))
 {
      // system is not in a state that can be resumed from
      reset(msg);
      resp["status"] = "ERROR";
      msg << log_e(lbl.c_str(), "System is neither in sPause, sLansing or sStandby. Current state :") 
          << iollaserunit()->get_state_description();
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      LOG(Log::ERR) << msg.str();
      return OpcUa_BadInvalidState;
    }
    st= iollaserunit()->resume(resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      resp["status"] = "ERROR";
      msg << log_e(lbl.c_str(), "Laser failed to resume. Check previous messages.");
      resp["messages"].push_back(msg.str());
      if (!resp.contains("statuscode"))
      {
        resp["statuscode"] = OpcUa_BadInvalidState;
      }
      LOG(Log::ERR) << msg.str();
      return OpcUa_Bad;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::warmup(json &resp)
  {
    // warmup is a special command. This is the command that initiates the laser itself
    // the best way is to check whether the laser itself is firing already
    const std::string lbl("warmup");
    std::ostringstream msg("");
    UaStatus st;
    if (iollaserunit()->get_state() != DIoLLaserUnit::sReady)
    {
      // system is not even configured. Nothing to be done
      reset(msg);
      resp["status"] = "ERROR";
      msg << log_e(lbl.c_str(),"Laser system is not in ready state, as it should.");
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      LOG(Log::ERR) << msg.str();
      return OpcUa_BadInvalidState;
    }
    st = iollaserunit()->start_cib(resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      resp["status"] = "ERROR";
      msg << log_e(lbl.c_str(), "Laser system failed to start. Check previous messages.");
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      LOG(Log::ERR) << msg.str();
      return OpcUa_Bad;
    }
    // confirm that the laser is in warmup state
    if (iollaserunit()->get_state() != DIoLLaserUnit::sWarmup)
    {
      reset(msg);
      resp["status"] = "ERROR";
      msg << log_e(lbl.c_str(), "Laser system not in expected sWarmup state. Got ") << iollaserunit()->get_state()
          << " (expected " << DIoLLaserUnit::sWarmup << ")";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      LOG(Log::ERR) << msg.str();
      return OpcUa_Bad;
    }
    // if it reached this point, we are now in warmup state.
    // update the local state
    // during this time, no laser related commands are accepted
    //update_state(sWarmup);
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::shutdown(json &resp)
  {
    // shutdown is meant to close all connectivity, leaving the system in a completely clean state
    const std::string lbl("shutdown");
    UaStatus st;
    std::ostringstream msg("");
    st = iollaserunit()->terminate(resp);
    bool trouble = false;
    if (st != OpcUa_Good)
    {
      reset(msg);
      resp["status"] = "ERROR";
      msg << log_e(lbl.c_str(),"Something weird happened with the laser unit.");
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = static_cast<uint32_t>(st);
      trouble = true;
      // do not return
      // the terminate should propagate everywhere
    }
    // call update over all daughters
    for (Device::DIoLMotor* lmotor : iolmotors ())
    {
      st = lmotor->terminate(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e(lbl.c_str(), "Motor ") << lmotor->get_id() << " didn't terminate cleanly. Please check.";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = static_cast<uint32_t>(st);
        trouble = true;
      }
    }
    for (Device::DIoLAttenuator* latt : iolattenuators ())
    {
      st = latt->terminate(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e(lbl.c_str(), "Attenuator ") << latt->get_id() << " didn't terminate cleanly. Please check.";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = static_cast<uint32_t>(st);
        trouble = true;
      }
    }
    for (Device::DIoLPowerMeter* lmeter : iolpowermeters())
    {
      st = lmeter->terminate(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e(lbl.c_str(), "Attenuator ") << lmeter->get_id() << " didn't terminate cleanly. Please check.";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = static_cast<uint32_t>(st);
        trouble = true;
      }
    }
    // CIB never terminates. It lives forever...
    //    for (Device::DIoLCIB* lcib : iolcibs())
    //    {
    //      st = lcib->terminate(resp);
    //      if (st != OpcUa_Good)
    //      {
    //        reset(msg);
    //        resp["status"] = "ERROR";
    //        msg << log_e("shutdown","CIB ") << lcib->get_id() << " didn't terminate cleanly. Please check.";
    //        resp["messages"].push_back(msg.str());
    //        resp["statuscode"] = static_cast<uint32_t>(st);
    //        trouble = true;
    //      }
    //    }
    update_state(sOffline);
    if (trouble)
    {
      return OpcUa_Bad;
    }
    else
    {
      return OpcUa_Good;
    }
  }

  void DIoLaserSystem::move_task(const std::vector<OpcUa_Int32> position, const std::string approach)
  {
    const uint32_t overstep = 200;
    std::ostringstream msg("");
    const std::string lbl = "move_task";
    UaStatus st;
    json resp;
    resp["messages"] = json::array();
    // -- Validations passed. Starting the work
    for (std::vector<OpcUa_Int32>::size_type idx = 0; idx < position.size(); idx++)
    {
      // get the motor that is responsible for this coordinate
      Device::DIoLMotor *lmotor = iolmotors().at(m_map_motor_coordinates.at(idx));
      // get its current position
      int32_t c_pos;
      st = lmotor->get_position_motor(c_pos, resp);
      if (st != OpcUa_Good)
      {
        update_task_message_queue(resp);
        update_state(sError);
        return;
      }
      int32_t interim_target = c_pos;
      //
      // we have the current position, decide whether the approach is good or requires some overstepping
      if (c_pos < position.at(idx))
      {
        // current position is "below" the target, only 'd' requires overstepping
        if (approach.at(idx) == 'd')
        {
          interim_target = position.at(idx) + overstep;
          reset(msg);
          msg << log_i(lbl.c_str(), "Setting overstep position for motor (id : ")
              << lmotor->get_id() << ") : " << interim_target;
          LOG(Log::INF) << msg.str();
          resp["messages"].push_back(msg.str());
          st = lmotor->move_wrapper(interim_target, resp);
          if (st != OpcUa_Good)
          {
            resp["status"] = "ERROR";
            reset(msg);
            msg << log_e(lbl.c_str(), "Failed to set overstep position for motor (id : ")
                << lmotor->get_id() << ").";
            resp["messages"].push_back(msg.str());
            resp["statuscode"] = static_cast<uint32_t>(st);
            LOG(Log::ERR) << msg.str();
            // nothing is being done, so just terminate this task
            update_task_message_queue(resp);
            update_state(sError);
            return;
          }
        }
        // now we can move to the *real* target position
      }
      else if (c_pos > position.at(idx))
      {
        // we are above. If approach is 'u', we have to overstep
        // current position is "below" the target, only 'u' requires overstepping
        if (approach.at(idx) == 'u')
        {
          interim_target = position.at(idx) - overstep;
          st = lmotor->move_wrapper(interim_target, resp);
          if (st != OpcUa_Good)
          {
            resp["status"] = "ERROR";
            reset(msg);
            msg << log_e(lbl.c_str(), "Failed to set overstep position for motor (id : ")
                << lmotor->get_id() << ").";
            resp["messages"].push_back(msg.str());
            resp["statuscode"] = static_cast<uint32_t>(st);
            LOG(Log::ERR) << msg.str();
            update_task_message_queue(resp);
            update_state(sError);
            return;
          }
        }
      }
      // if the motor was ordered to overstep, we have to wait for the movement to complete
      wait_for_motor(lmotor,interim_target);
      lmotor->get_position_motor(c_pos, resp);
      reset(msg);
      msg << log_i(lbl.c_str(), "Interim position for motor (id : ")
          << lmotor->get_id() << ") : " << c_pos;
      LOG(Log::INF) << msg.str();

      reset(msg);
      msg << log_i(lbl.c_str(), "Now reaching for target position for motor (id : ")
          << lmotor->get_id() << ") : " << position.at(idx);
      LOG(Log::INF) << msg.str();

      // if we reached this point, we are ready to go to the *real* target position
      st = lmotor->move_wrapper(position.at(idx), resp);
      if (st != OpcUa_Good)
      {
        resp["status"] = "ERROR";
        reset(msg);
        msg << log_e(lbl.c_str(), "Failed to set target position for motor (id : ")
            << lmotor->get_id() << ").";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = static_cast<uint32_t>(st);
        LOG(Log::ERR) << msg.str();
        update_task_message_queue(resp);
        update_state(sError);
        return;
      }
    }
    update_task_message_queue(resp);
    // nothin failed so far...we should be where we want.
    reset(msg);
    msg << log_i(lbl.c_str(), "Task done");
    LOG(Log::INF) << msg.str();
  }

UaStatus DIoLaserSystem::move_to_pos(
          const std::vector<OpcUa_Int32> &position, const std::string approach, json &resp)
  {
 
    // actually, this should run asynchronously, since with the overstep we 
    // may have to wait for the motors for a long time
    std::thread([this, position, approach]()
                {
      std::ostringstream msg;
      if (m_state != sError)
      {
        update_state(sBusy);
      }
      else
      {
        // if we are in error state don't do anything
        json resp;
        reset(msg);
        msg << log_e("move_task", "System is in error state. Aborting.");
        resp["status"] = "ERROR";
        resp["messages"] = msg.str();
        resp["statuscode"] = OpcUa_BadInvalidState;
        update_task_message_queue(resp);
        return;
      }
      LOG(Log::INF) << log_i("move_to_pos","Starting movement task");
      move_task(position,approach);
      // once the task is done check if there is an error
      if (m_state == sError)
      {
        LOG(Log::ERR) << log_e("move_task","Bugger. Movement failed with movement [")
        << position.at(0) << "," << position.at(1) << "," << position.at(2)
        << " approach " << approach;
      }
      else
      {
        // we should update state back to sPause
        std::ostringstream msg("");
        reset(msg);
        if (!m_task_message_queue.contains("status"))
        {
          m_task_message_queue["status"] = "OK";
        }
        msg << log_i("move_to_pos","Operation was successful.");
        if (!m_task_message_queue.contains("messages"))
        {
          m_task_message_queue["messages"] = json::array();
        }
        m_task_message_queue["messages"].push_back(msg.str());
        if (!m_task_message_queue.contains("statuscode"))
        {
          m_task_message_queue["statuscode"] = OpcUa_Good;
        }
      } 
      if (m_state != sError)
      {
        update_state(sReady);
      }      
      }).detach();

    // don't implement this yet
    return OpcUa_Good;
  }
  bool DIoLaserSystem::validate_config_fragment(json &frag, json &resp)
  {
    // check that a series of parameters are set
    // also check that this fragment has the ID that is corresponding to this specific laser system
    // this is just a validation check for the available keys.
    // it will only check the mandatory keys.
    const std::string lbl = "validate_config";
    std::ostringstream msg("");
    std::vector<std::string> keys = {"id","motors","attenuator","laser",
        "power_meter", "cib"
    };
    // Check if "messages" key already exists in the response
    if (!resp.contains("messages") || !resp["messages"].is_array())
    {
      resp["messages"] = json::array();
    }
    // actually, check for all entries and report all missing ones
    std::vector<std::string> missing;
    for (auto entry: keys)
    {
      if (!frag.contains(entry))
      {
        missing.push_back(entry);
      }
    }
    if (missing.size() > 0)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Missing entries in IoLS config fragment [");
      for (auto e : missing)
      {
        msg << "(" <<  e << "),";
      }
      msg << "]";
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return false;
    }
    // if it reaches here, all keys are there. check that the ID is correct
    if (frag.at("id").get<std::string>() != id())
    {
      reset(msg);
      msg << log_e(lbl.c_str(), "Configuration fragment has a mismatched ID. Expected ") << id();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return false;
    }

    // all good, return true
    return true;
  }
  void DIoLaserSystem::update()
  {
    update_state(m_state);
    // first update the local variables
    // NFB: this method does not do what the call suggests
    //update_state(m_state);
    // check the state of all systems and update the state accordingly
    // if any of the systems is in an error state, the whole system is in error
    // if any of the systems is in a warmup state, the whole system is in warmup
    // this is to check if one of the systems went belly up
    //refresh_state();
    // call update over all daughters
    for (Device::DIoLLaserUnit* lunit : iollaserunits())
    {
      lunit->update();
    }
    for (Device::DIoLMotor* lmotor : iolmotors ())
    {
      lmotor->update();
    }
    for (Device::DIoLAttenuator* latt : iolattenuators ())
    {
      latt->update();
    }
    for (Device::DIoLPowerMeter* lmeter : iolpowermeters())
    {
      lmeter->update();
    }
    for (Device::DIoLCIB* lcib : iolcibs())
    {
      lcib->update();
    }
  }
  bool DIoLaserSystem::is_ready()
  {
    for (Device::DIoLLaserUnit* lunit : iollaserunits())
    {
      if (!lunit->is_ready())
      {
        return false;
      }
    }
    for (Device::DIoLMotor* lmotor : iolmotors ())
    {
      if (!lmotor->is_ready())
      {
        return false;
      }
    }
    for (Device::DIoLAttenuator* latt : iolattenuators ())
    {
      if (!latt->is_ready())
      {
        return false;
      }
    }
    for (Device::DIoLPowerMeter* lmeter : iolpowermeters())
    {
      if (!lmeter->is_ready())
      {
        return false;
      }
    }
    for (Device::DIoLCIB* lcib : iolcibs())
    {
      if (!lcib->is_ready())
      {
        return false;
      }
    }
    return true;
  }
  void DIoLaserSystem::reset(std::ostringstream &s)
  {
    s.clear();
    s.str("");
  }
  void DIoLaserSystem::update_state(State s)
  {
    static bool first = true;
    if (first)
    {
      UaString ss(m_state_map.at(m_state).c_str());
      getAddressSpaceLink()->setState(ss, OpcUa_Good);
      first = false;
    }
    if (m_state == s)
    {
      // nothing to be done
      return;
    }
    m_state = s;
    UaString ss(m_state_map.at(m_state).c_str());
    getAddressSpaceLink()->setState(ss,OpcUa_Good);
  }
  void DIoLaserSystem::get_message_queue(json &resp, bool clear)
  {
    resp = m_task_message_queue;
    if (clear)
    {
      m_task_message_queue.clear();
    }
  }
  bool DIoLaserSystem::validate_scan_plan(json &plan, json &resp)
  {
    const std::string lbl("validate_scan");
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // the structure for a scan plan is rather simple
      // it is basically just an array of tuples, but we also need to check that the tuples themselves make sense
      // since we do not want things to go belly up halfway through the scan
      // Things to check for:
      // 1. the structure is correct
      // 2. The positions have the appropriate number of entries
      // 3. Each position remains within the range of the corresponding motor
      // step one. Check that the "scan_plan" key exists and that the corresponding entry can be cast into a vector
      // containing a "start" and "end" structure
      if (!plan.contains("scan_plan"))
      {
        reset(msg);
        msg << log_e(lbl.c_str(),"Missing \"scan_plan\" key.");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        return false;
      }
      std::vector<std::string> entries = {"start","end"};
      for (auto item: plan.at("scan_plan"))
      {
        for (auto entry : entries)
        {
          if (!item.contains(entry))
          {
            reset(msg);
            msg << log_e(lbl.c_str(), "Missing key ") << entry << " in segment " << item.dump();
            resp["status"] = "ERROR";
            resp["messages"].push_back(msg.str());
            resp["statuscode"] = OpcUa_BadInvalidArgument;
            return false;
          }
          // 2. check entries for positions
          std::vector<int32_t> v = item.at(entry).get<std::vector<int32_t>>();
          if (v.size() != iolmotors().size())
          {
            reset(msg);
            msg << log_e(lbl.c_str(), "Wrong number of coordinates in key ")
                << entry << " of segment " << item.dump() << ". Expected " << iolmotors().size();
            resp["status"] = "ERROR";
            resp["messages"].push_back(msg.str());
            resp["statuscode"] = OpcUa_BadInvalidArgument;
            return false;
          }
          // 3. check each coordinate to be in range
          for (size_t i = 0; i < v.size(); i++)
          {
            if (!iolmotors().at(m_map_motor_coordinates.at(i))->is_in_range(v.at(i)))
            {
              reset(msg);
              msg << log_e(lbl.c_str(), "Coordinate out of range.")
                  << " Entry " << i << " position " << entry << " of segment " << item.dump()
                  << ". Range: [" << iolmotors().at(m_map_motor_coordinates.at(i))->get_range_min()
                  << ", " << iolmotors().at(m_map_motor_coordinates.at(i))->get_range_max() << "]";
              resp["status"] = "ERROR";
              resp["messages"].push_back(msg.str());
              resp["statuscode"] = OpcUa_BadInvalidArgument;
              return false;
            }
          }
        }
      }
      // if we reached this stage, all it good
    }
    catch(json::exception &e)
    {
      reset(msg);
      msg << log_e(lbl.c_str(), "Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      reset(msg);
      msg << log_e(lbl.c_str(), "Caught runtime error : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      reset(msg);
      msg << log_e(lbl.c_str(), "Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      reset(msg);
      msg << log_e(lbl.c_str(), "Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return false;
    }
    else
    {
      reset(msg);
      msg << log_i(lbl.c_str(), "Configuration validated.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    return true;
  }

  void DIoLaserSystem::refresh_state()
  {
    // this is no longer needed
    return;
    /**
    * A few edges cases. 
    *  - If all devices are offline, the system is offline
    *  - If any device is in error, the system is in error
    *  - If one device is offline and the others are in other states, the system is in error
    *  
    */
    // // this is the one that actually dictates the state of the whole system
    // Device::DIoLLaserUnit::Status sl = iollaserunit()->get_state();
    // Device::DIoLAttenuator::Status sa =iolattenuator()->get_state();
    // Device::DIoLPowerMeter::Status sp = iolpowermeter()->get_state();
    // Device::DIoLCIB::Status sc = iolcib()->get_state();
    // Device::DIoLMotor::Status sm = DIoLMotor::sReady;

    // for (auto m: iolmotors())
    // {
    //   sm = Device::DIoLMotor::Status::sReady;
    //   if (m->get_state() == DIoLMotor::sError)
    //   {
    //     update_state(sError);
    //     return;
    //   }
    //   if (m->get_state() == DIoLMotor::sOffline)
    //   {
    //     sm = DIoLMotor::sOffline;
    //   }
    // }
    // // now the logic
    // // if any is in error, the system itself is in error
    // if (sl == DIoLLaserUnit::sError)
    // {
    //   update_state(sError);
    //   return;
    // }
    // if (sc == DIoLCIB::sError)
    // {
    //   update_state(sError);
    //   return;
    // }
    // if (sa == DIoLAttenuator::sError)
    // {
    //   update_state(sError);
    //   return;
    // }

    // // if all are offline the system is offline
    // if ((sl == DIoLLaserUnit::sOffline) && (sc == DIoLCIB::sOffline) && (sa == DIoLAttenuator::sOffline) && (sp == DIoLPowerMeter::sOffline) && (sm == DIoLMotor::sOffline))
    // {
    //   update_state(sOffline);
    //   return;
    // }
    // // the power meter is ignored specifically because it can be in operating state even if the laser is not
    // else if ((sl == DIoLLaserUnit::sReady) && (sc == DIoLCIB::sReady) && (sa == DIoLAttenuator::sReady) && (sm == DIoLMotor::sReady))
    // {
    //   update_state(sReady);
    //   return;
    // }
    // else // neither all are ready neither all are offline
    // {
    //   if ((sc == DIoLCIB::sReady) && (sa == DIoLAttenuator::sReady))
    //   {
    //     // in this case the state will depend on the laser
    //     if (sl == DIoLLaserUnit::sWarmup)
    //     {
    //       update_state(sWarmup);
    //       return;
    //     }
    //     else if (sl == DIoLLaserUnit::sLasing)
    //     {
    //       update_state(sOperating);
    //       return;
    //     }
    //     else if (sl == DIoLLaserUnit::sPause)
    //     {
    //       update_state(sPause);
    //       return;
    //     }
    //     else if (sl == DIoLLaserUnit::sStandby)
    //     {
    //       update_state(sStandby);
    //       return;
    //     }
    //     else
    //     {
    //       // someone is not ready. Error state
    //       update_state(sError);
    //       return;
    //     }
    //   }
    // }
  }
  bool DIoLaserSystem::process_move_arguments(const UaString &arguments, std::vector<int32_t> &target_pos, std::string &approach, json &response)
  {
    try
    {
      response["messages"] = json::array();

      // Convert UaString to std::string
      std::string args = arguments.toUtf8();

      // Parse the arguments as a JSON structure
      json jargs = json::parse(args);

      // Extract target position
      if (jargs.contains("target") && jargs["target"].is_array() && jargs["target"].size() == 3)
      {
        target_pos = {jargs["target"][0].get<int32_t>(), jargs["target"][1].get<int32_t>(), jargs["target"][2].get<int32_t>()};
      }
      else
      {
        LOG(Log::ERR) << log_e("process_move_arguments", "Invalid or missing 'target' key.");
        response["messages"].push_back("Invalid or missing 'target' key.");
        return false;
      }

      // Extract approach
      if (jargs.contains("approach") && jargs["approach"].is_string())
      {
        approach = jargs["approach"].get<std::string>();
        if (approach.size() != 3 || !std::all_of(approach.begin(), approach.end(), [](char c)
                                                { return c == 'u' || c == 'd' || c == '-'; }))
        {
          response["messages"].push_back("Invalid approach format: " + approach);
          return false;
        }
      }
      else
      {
        LOG(Log::ERR) << log_e("process_move_arguments", "Invalid or missing 'target' key.");
        response["messages"].push_back("Invalid or missing 'approach' key.");
        return false;
      }
      LOG(Log::INF) << log_i("process_move_arguments", "Move arguments processed successfully.");
      response["messages"].push_back("Move arguments processed successfully.");
      return true;
    }
    catch (const json::exception &e)
    {
      response["messages"].push_back(std::string("JSON exception in process_move_arguments: ") + e.what());
      LOG(Log::ERR) << log_e("process_move_arguments", "JSON exception in process_move_arguments: ") << e.what();

      return false;
    }
    catch (const std::exception &e)
    {
      response["messages"].push_back(std::string("Exception in process_move_arguments: ") + e.what());
      LOG(Log::ERR) << log_e("process_move_arguments", "Exception in process_move_arguments: ") << e.what();

      return false;
    }
    catch (...)
    {
      response["messages"].push_back("Unknown exception in process_move_arguments");
      return false;
    }
  }
  bool DIoLaserSystem::process_fap_arguments(const UaString &arguments, std::vector<int32_t> &target_pos, std::string &approach, uint32_t &num_pulses, bool &lbls, json &response)
  {
    try
    {
      if (!response.contains("messages"))
      {
        response["messages"] = json::array();
      }
      // Convert UaString to std::string
      std::string args = arguments.toUtf8();

      // Parse the arguments as a JSON structure
      json jargs = json::parse(args);

      // Extract target position
      if (jargs.contains("target") && jargs["target"].is_array() && jargs["target"].size() == 3)
      {
        target_pos = {jargs["target"][0].get<int32_t>(), jargs["target"][1].get<int32_t>(), jargs["target"][2].get<int32_t>()};
      }
      else
      {
        response["messages"].push_back("Invalid or missing 'target' key.");
        return false;
      }
      // Extract approach
      if (jargs.contains("approach") && jargs["approach"].is_string())
      {
        approach = jargs["approach"].get<std::string>();
        if (approach.size() != 3 || !std::all_of(approach.begin(), approach.end(), [](char c)
                                                 { return c == 'u' || c == 'd' || c == '-'; }))
        {
          response["messages"].push_back("Invalid approach format: " + approach);
          return false;
        }
      }
      else
      {
        response["messages"].push_back("Invalid or missing 'approach' key.");
        return false;
      }

      // Extract num_pulses
      if (jargs.contains("num_pulses") && jargs["num_pulses"].is_number_unsigned())
      {
        num_pulses = jargs["num_pulses"].get<uint32_t>();
      }
      else
      {
        response["messages"].push_back("Invalid or missing 'num_pulses' key.");
        return false;
      }
      //FIXME: Add the LBLS

      response["messages"].push_back("Move arguments processed successfully.");
      return true;
    }
    catch (const json::exception &e)
    {
      response["messages"].push_back(std::string("JSON exception in process_move_arguments: ") + e.what());
      return false;
    }
    catch (const std::exception &e)
    {
      response["messages"].push_back(std::string("Exception in process_move_arguments: ") + e.what());
      return false;
    }
    catch (...)
    {
      response["messages"].push_back("Unknown exception in process_move_arguments");
      return false;
    }
  }
  // reimplement below
  void DIoLaserSystem::init_fire_point_task(const std::vector<int32_t> &target, const std::string &approach,
                                            const uint32_t &num_pulses)
  {
    // this task runs on a separate thread
    // since there is no return to the user space
    // messages are queued in a separate variable that can then be queried
    // also keep in mind that at this stage all verifications have been performed, so
    // the task does not need base checks
    std::thread([this, target, approach, num_pulses]()
                {
        std::ostringstream msg;
        if (m_state != sError)
        {
          update_state(sBusy);
        }
        else
        {
          // if we are in error state don't do anything
          json resp;
          reset(msg);
          msg << log_e("fire_point_task", "System is in error state. Aborting.");
          resp["status"] = "ERROR";
          resp["messages"] = msg.str();
          resp["statuscode"] = OpcUa_BadInvalidState;
          update_task_message_queue(resp);
          return;
        }
        //
        if (!m_task_message_queue.contains("messages"))
        {
          m_task_message_queue["messages"] = json::array();
        }
        fire_point_task(target,approach,num_pulses);
        // once the task is done check if there is an error
        if (m_state == sError)
        {
          LOG(Log::ERR) << log_e("fire_point_task","Bugger. Task failed.");
        }
        else
        {
          // we should update state back to sPause
          std::ostringstream msg("");
          reset(msg);
          if (!m_task_message_queue.contains("status"))
          {
            m_task_message_queue["status"] = "OK";
          }
          msg << log_e("fire_point_task", "Operation was successful.");
          m_task_message_queue["messages"].push_back(msg.str());
          if (!m_task_message_queue.contains("statuscode"))
          {
            m_task_message_queue["statuscode"] = OpcUa_Good;
          }
        }
        if (m_state != sError)
        {
          update_state(sReady);
        }
        }).detach();
  }
  void DIoLaserSystem::fire_point_task(const std::vector<int32_t> &target, const std::string &approach,
                                       const uint32_t &num_pulses)
  {
    const std::string lbl("fire_point_task");
    UaStatus st;
    std::ostringstream msg("");
    json resp;
    //
    // ready to operate
    // -- be sure to set the shutter closed until destination is reached
    // the logic is the following
    // 0. Make sure that the laser is in Pause state
    // 1. Call each of the the motors to move to the starting position
    // 2. Set the target position for each motor
    // 3. Initiate movement
    // 4. call resume (switch to sLasing)
    // 5. Wait for motors to report end of travel
    // 6. switch back to pause
    // 7. Assess success
    //
    // step 0: before we even start doing anything
    // force the laser into a pause state
    st = pause(resp);
    // st = iollaserunit()->pause(resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      msg << log_e(lbl.c_str(), "Failed to set laser into Pause state");
      resp["messages"].push_back(msg.str());
      resp["status"] = "ERROR";
      LOG(Log::ERR) << msg.str();
      resp["statuscode"] = static_cast<uint32_t>(st);
      // nothing is being done, so just terminate this task
      // update the state to error
      // -- if we cannot go into pause, force a shutdown
      standby(resp);
      update_task_message_queue(resp);
      update_state(sError);
      return;
    }
    // step 1
    // we can initiate the movement
    move_task(target, approach);
    // if error was not set, we can continue
    if (m_state == sError)
    {
      LOG(Log::ERR) << log_e("fire_point_task", "Failed to move to position.");
      // something went wrong
      // we should have a message in the queue
      return;
    }
    // step 1.2: wait until motors are in place
    // since this is a separate task, we *must* wait for things to be ready
    wait_for_motors(target);
    // we have reached the destination
    // step 2.0 : start power meter readings
    st = iolpowermeter()->start_readings(resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      msg << log_e(lbl.c_str(), "Failed to start power meter");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = static_cast<uint32_t>(st);
      LOG(Log::ERR) << msg.str();
      update_task_message_queue(resp);
      update_state(sError);
      return;
    }
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    // step 2: resume operation of the laser unit
    st = iollaserunit()->fire_discrete_shots(num_pulses, resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      resp["status"] = "ERROR";
      msg << log_e(lbl.c_str(), "Failed to fire laser. Check previous messages.");
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = static_cast<uint32_t>(st);
      // force a pause (again)
      pause(resp);
      update_task_message_queue(resp);
      update_state(sError);
      return;
    }
    // at this stage we are done
    st = pause(resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      msg << log_e(lbl.c_str(), "Failed to set later into pause mode.");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = static_cast<uint32_t>(st);
      standby(resp);
      update_task_message_queue(resp);
      update_state(sError);
      return;
    }
    // reached the end. Push any existing messages to the queue
    update_task_message_queue(resp);
    // reset the state
  }
  UaStatus DIoLaserSystem::clear_error(json &resp)
  {
    
    resp = m_task_message_queue;
    m_task_message_queue.clear();
    if (m_state == sError)
    { 
      update_state(sReady);
    }
    return OpcUa_Good;
  }
  void DIoLaserSystem::wait_for_motor(DIoLMotor *motor, int32_t target)
  {
    bool is_moving = true;
    json resp;
    int32_t c_pos;
    while (is_moving)
    {
      motor->get_position_motor(c_pos, resp);
      is_moving = (std::abs(c_pos - target) > 20);
      is_moving |= motor->is_moving();
      std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }
  }
  void DIoLaserSystem::wait_for_motors(const std::vector<int32_t> &target)
  {
    for (Device::DIoLMotor *lmotor : iolmotors())
    {
      wait_for_motor(lmotor, target.at(lmotor->get_coordinate_index()));
    }
  }
  void DIoLaserSystem::update_task_message_queue(json &resp)
  {
    if (!m_task_message_queue.contains("messages"))
    {
      m_task_message_queue["messages"] = json::array();
    }
    if (!m_task_message_queue.contains("status"))
    {
      if (resp.contains("status"))
      {
        m_task_message_queue["status"] = resp.at("status");
      }
      else
      {
        m_task_message_queue["status"] = "OK";
      }
    }
    if (!m_task_message_queue.contains("statuscode"))
    {
      if (resp.contains("statuscode"))
      {
        m_task_message_queue["statuscode"] = resp.at("statuscode");
      }
      else
      {
        m_task_message_queue["statuscode"] = OpcUa_Good;
      }
    }
    m_task_message_queue["messages"].insert(m_task_message_queue["messages"].end(), resp.at("messages").begin(), resp.at("messages").end());
  }
  UaStatus DIoLaserSystem::validate_grid_parameters(const json &plan, json &resp)
  {
    const std::vector<std::string> keys = {"center", "range", "step", "approach","scan_axis"};
    if (!resp.contains("messages"))
    {
      resp["messages"] = json::array();
    }
    // Check if all required keys are present
    for (const auto &key : keys)
    {
      if (!plan.contains(key))
      {
        resp["messages"].push_back("Missing key: " + key);
        return OpcUa_BadInvalidArgument;
      }
    }

    // Validate "center"
    if (!plan["center"].is_array() || plan["center"].size() != 3)
    {
      resp["messages"].push_back("Invalid 'center' format. Expected an array of 3 integers.");
      return OpcUa_BadInvalidArgument;
    }
    for (const auto &val : plan["center"])
    {
      if (!val.is_number_integer())
      {
        resp["messages"].push_back("Invalid 'center' value. Expected an integer.");
        return OpcUa_BadInvalidArgument;
      }
    }

    // Validate "range"
    if (!plan["range"].is_array() || plan["range"].size() != 3)
    {
      resp["messages"].push_back("Invalid 'range' format. Expected an array of 3 unsigned integers.");
      return OpcUa_BadInvalidArgument;
    }
    for (const auto &val : plan["range"])
    {
      if (!val.is_number_unsigned())
      {
        resp["messages"].push_back("Invalid 'range' value. Expected an unsigned integer.");
        return OpcUa_BadInvalidArgument;
      }
    }

    // Validate "step"
    if (!plan["step"].is_array() || plan["step"].size() != 3)
    {
      resp["messages"].push_back("Invalid 'step' format. Expected an array of 3 unsigned integers.");
      return OpcUa_BadInvalidArgument;
    }
    for (const auto &val : plan["step"])
    {
      if (!val.is_number_unsigned())
      {
        resp["messages"].push_back("Invalid 'step' value. Expected an unsigned integer.");
        return OpcUa_BadInvalidArgument;
      }
    }

    // Validate "approach"
    if (!plan["approach"].is_string() || plan["approach"].get<std::string>().size() != 3)
    {
      resp["messages"].push_back("Invalid 'approach' format. Expected a string of 3 characters. Got " + plan["approach"].dump());
      return OpcUa_BadInvalidArgument;
    }
    std::string approach = plan["approach"];
    if (!std::all_of(approach.begin(), approach.end(), [](char c)
                     { return c == 'u' || c == 'd' || c == '-'; }))
    {
      resp["messages"].push_back("Invalid 'approach' value. Expected characters 'u', 'd', or '-'.");
      return OpcUa_BadInvalidArgument;
    }

    // validate the scan axis
    if (!plan["scan_axis"].is_number_unsigned())
    {
      resp["messages"].push_back("Invalid 'scan_axis' format. Expected an unsigned integer.");
      return OpcUa_BadInvalidArgument;
    }
    else if (plan["scan_axis"].get<uint32_t>() >= iolmotors().size())
    {
      resp["messages"].push_back("Invalid 'scan_axis' value. Expected a value less than " + std::to_string(iolmotors().size()));
      return OpcUa_BadInvalidArgument;
    }

    resp["messages"].push_back("Grid parameters validated successfully.");
    LOG(Log::INF) << "Grid parameters validated successfully.";
    return OpcUa_Good;
  }

  UaStatus DIoLaserSystem::execute_grid_scan(json &plan, json &resp)
  {
    // Validate the plan
    if (validate_grid_parameters(plan, resp) != OpcUa_Good)
    {
      return OpcUa_BadInvalidArgument;
    }

    const uint32_t overstep = 200;
    // Extract the parameters
    std::vector<int32_t> center = plan["center"];
    std::vector<uint32_t> range = plan["range"];
    std::vector<uint32_t> step = plan["step"];
    std::string approach = plan["approach"];
    uint32_t scan_axis = plan["scan_axis"].get<uint32_t>();

    // Generate the scan plan
    json scan_plan;
    uint32_t scan_start, scan_end;

    scan_plan["scan_plan"] = json::array();
    if (approach[scan_axis] == 'u')
    {
      scan_start = center[scan_axis] - range[scan_axis] - overstep;
      scan_end = center[scan_axis] + range[scan_axis];
    }
    else if (approach[scan_axis] == 'd')
    {
      scan_start = center[scan_axis] + range[scan_axis] + overstep;
      scan_end = center[scan_axis] - range[scan_axis];
    }
    else
    {
      // Default to 'u' if approach is '-'
      scan_start = center[scan_axis] - range[scan_axis] - overstep;
      scan_end = center[scan_axis] + range[scan_axis];
    }
  //
    // -- build arrays of entries to combine
    std::deque<int32_t> x_entries;
    std::deque<int32_t> y_entries;
    std::deque<int32_t> z_entries;
    //
    // generate the entries
    // this is done by looping over all axes and skipping the scan_axis
    for (int32_t x = center[0] - static_cast<int32_t>(range[0]); x <= (center[0] + static_cast<int32_t>(range[0])); x += step[0])
    {
      // if this is the scan axis, we do not need to create entries for it
      if (scan_axis == 0)
      {
        x_entries.push_back(x);
        break;
      }
      if (approach[0] == 'u' || approach[0] == '-')
      {
        // we are going up, then newer values go to the back
        x_entries.push_back(x);
      }
      else if (approach[0] == 'd')
      {
        // we're going down. Newer values go to the front
        x_entries.push_front(x);
      }
      if (step[0] == 0)
      {
        break;
      }
    }
    for (int32_t y = center[1] - static_cast<int32_t>(range[1]); y <= (center[1] + static_cast<int32_t>(range[1])); y += step[1])
    {
      // if this is the scan axis, we do not need to create entries for it
      if (scan_axis == 1)
      {
        y_entries.push_back(y);
        break;
      }

      if (approach[1] == 'u' || approach[1] == '-')
      {
        // we are going up, then newer values go to the back
        y_entries.push_back(y);
      }
      else if (approach[1] == 'd')
      {
        // we're going down. Newer values go to the front
        y_entries.push_front(y);
      }
      if (step[1] == 0)
      {
        break;
      }
    }
    for (int32_t z = center[2] - static_cast<int32_t>(range[2]); z <= (center[2] + static_cast<int32_t>(range[2])); z += step[2])
    {
      // if this is the scan axis, we do not need to create entries for it
      if (scan_axis == 2)
      {
        z_entries.push_back(z);
        break;
      }
      if (approach[1] == 'u' || approach[1] == '-')
      {
        // we are going up, then newer values go to the back
        z_entries.push_back(z);
      }
      else if (approach[1] == 'd')
      {
        // we're going down. Newer values go to the front
        z_entries.push_front(z);
      }
      if (step[2] == 0)
      {
        break;
      }
    }
    //
    // -- combine the entries
    for (int32_t x : x_entries)
    {
      for (int32_t y : y_entries)
      {
        for (int32_t z : z_entries)
        {
          if (scan_axis == 0)
          {
            scan_plan["scan_plan"].push_back({{"start", {scan_start, y, z}},
                                              {"end", {scan_end, y, z}}});
          }
          else if (scan_axis == 1)
          {
            scan_plan["scan_plan"].push_back({{"start", {x, scan_start, z}},
                                              {"end", {x, scan_end, z}}});
          }
          else if (scan_axis == 2)
          {
            scan_plan["scan_plan"].push_back({{"start", {x, y, scan_start}},
                                              {"end", {x, y, scan_end}}});
          }
        }
      }
    }

    // Log the generated scan plan
    resp["scan_plan"] = scan_plan;
    // #ifdef DEBUG
    LOG(Log::INF) << "Generated scan plan: " << scan_plan.dump(-1);
    // #endif
    //resp["messages"].push_back(scan_plan.dump(-1));

    resp["messages"].push_back("Grid scan plan generated successfully.");


    // don't execute it right now
    //FIXME: Get rid of this
    // return OpcUa_Good;
    // Execute the scan plan
    //FIXME: Uncomment this when we're done
    UaStatus st = execute_scan(scan_plan, resp);
    if (st != OpcUa_Good)
    {
      resp["messages"].push_back("Failed to execute grid scan plan.");
      LOG(Log::ERR) << "Failed to initiate a scan.";
      return st;
    }
    return OpcUa_Good;
  }
} // namespace Device
