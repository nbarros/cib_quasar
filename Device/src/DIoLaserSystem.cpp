
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.

    The stub of this file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.


 */


#include <Configuration.hxx> // TODO; should go away, is already in Base class for ages

#include <DIoLaserSystem.h>
#include <ASIoLaserSystem.h>

#include <DIoLLaserUnit.h>
#include <DIoLMotor.h>
#include <DIoLPiezoController.h>
#include <DIoLAttenuator.h>
#include <DIoLPowerMeter.h>
#include <thread>
#include <string>
#include <chrono>

#define log_msg(s,met,msg) "[" << s << "]::" << met << " : " << msg

#define log_e(m,s) log_msg("ERROR",m,s)
#define log_w(m,s) log_msg("WARN",m,s)
#define log_i(m,s) log_msg("INFO",m,s)

using std::ostringstream;

namespace Device
{
  // 1111111111111111111111111111111111111111111111111111111111111111111111111
  // 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
  // 1     Users don't modify this code!!!!                                  1
  // 1     If you modify this code you may start a fire or a flood somewhere,1
  // 1     and some human being may possible cease to exist. You don't want  1
  // 1     to be charged with that!                                          1
  // 1111111111111111111111111111111111111111111111111111111111111111111111111






  // 2222222222222222222222222222222222222222222222222222222222222222222222222
  // 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
  // 2     (code for which only stubs were generated automatically)          2
  // 2     You should add the implementation but dont alter the headers      2
  // 2     (apart from constructor, in which you should complete initializati2
  // 2     on list)                                                          2
  // 2222222222222222222222222222222222222222222222222222222222222222222222222

  /* sample ctr */
  DIoLaserSystem::DIoLaserSystem (
      const Configuration::IoLaserSystem& config,
      Parent_DIoLaserSystem* parent
  ):
                                        Base_DIoLaserSystem( config, parent)

                                        /* fill up constructor initialization list here */
                                        ,m_state(sOffline)
                                        {
    /* fill up constructor body here */
                                        }

  /* sample dtr */
  DIoLaserSystem::~DIoLaserSystem ()
  {
    m_state_map.insert({sOffline,"offline"});
    m_state_map.insert({sReady,"ready"});
    m_state_map.insert({sWarmup,"warmup"});
    m_state_map.insert({sOperating,"operating"});
    m_state_map.insert({sPause,"pause"});
    m_state_map.insert({sStandby,"standby"});
    update_state(sOffline);
  }

  /* delegates for cachevariables */



  /* delegators for methods */
  UaStatus DIoLaserSystem::callLoad_config (
      const UaString&  config,
      UaString& response
  )
  {
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      json conf = json::parse(config.toUtf8());
      st = config(conf,resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        msg << log_e("config","Configuration failed. See previous messages");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        if (!resp.contains("status_code"))
        {
          resp["status_code"] = OpcUa_BadInvalidArgument;
        }
      }
      else
      {
        msg << log_i("config","System configured.");
        resp["messages"].push_back(msg.str());
        resp["status"] = "OK";
        resp["status_code"] = OpcUa_Good;
      }
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::callCheck_ready (
      OpcUa_Boolean& ready
  )
  {
    // check the states of all systems
    // check all associated subsystems if they're ready
    bool rdy = true;
    for (Device::DIoLLaserUnit* lunit : iollaserunits())
    {
      rdy |= lunit->is_ready();
    }
    for (Device::DIoLMotor* lmotor : iolmotors ())
    {
      rdy |= lmotor->is_ready();
    }
    for (Device::DIoLPiezoController* lctl : iolpiezocontrollers () )
    {
      rdy |= lctl->is_ready();
    }
    for (Device::DIoLAttenuator* latt : iolattenuators ())
    {
      rdy |= latt->is_ready();
    }
    ready = rdy;
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::callStop (

  )
  {
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = stop(resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
    }
    //response = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::callFire_at_position (
      const std::vector<OpcUa_Int32>&  target_pos,
      OpcUa_UInt16 num_pulses,
      UaString& answer
  )
  {
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = fire_at_position(target_pos,num_pulses,resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("fire_at_position","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("fire_at_position","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("fire_at_position","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
    }
    answer = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::callFire_segment (
      const std::vector<OpcUa_Int32>&  start_pos,
      const std::vector<OpcUa_Int32>&  last_pos,
      UaString& answer
  )
  {
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = fire_segment(start_pos,last_pos,resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("fire_segment","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("fire_segment","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("fire_segment","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
    }
    answer = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::callExecute_scan (
      const UaString&  plan,
      UaString& answer
  )
  {
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;

    UaStatus st;
    try
    {
      json scan = json::parse(plan.toUtf8());
      st = execute_scan(scan,resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("execute_scan","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("execute_scan","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("execute_scan","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
    }
    answer = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::callPause (
      UaString& answer
  )
  {
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;

    UaStatus st;
    try
    {
      st = pause(resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("pause","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("pause","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("pause","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
    }
    answer = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::callStandby (
      UaString& answer
  )
  {
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = standby(resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("standby","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("standby","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("standby","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
    }
    answer = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::callResume (
      UaString& response
  )
  {
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = resume(resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("resume","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("resume","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("resume","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::callWarmup_laser (
      UaString& response
  )
  {
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = warmup(resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("warmup","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("warmup","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("warmup","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::callShutdown (
      UaString& response
  )
  {
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = shutdown(resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("shutdown","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("shutdown","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("shutdown","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::callMove_to_pos (
      const std::vector<OpcUa_Int32>&  position,
      const std::vector<OpcUa_Byte>&  approach
  )
  {
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = move_to_pos(position,approach,resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("move_to_pos","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("move_to_pos","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("move_to_pos","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
    }
    //response = UaString(resp.dump().c_str());
    return OpcUa_Good;
  }

  // 3333333333333333333333333333333333333333333333333333333333333333333333333
  // 3     FULLY CUSTOM CODE STARTS HERE                                     3
  // 3     Below you put bodies for custom methods defined for this class.   3
  // 3     You can do whatever you want, but please be decent.               3
  // 3333333333333333333333333333333333333333333333333333333333333333333333333
  UaStatus DIoLaserSystem::config(json &conf, json &resp)
  {
    UaStatus st;
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // first thing is to check that we are either in sInit or sReady states
      if ((m_state != sOffline) and (m_state != sReady))
      {
        reset(msg);
        msg << log_e("config","System is operating. Can only configure when stopped.");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["status_code"] = OpcUa_BadInvalidState;
        return OpcUa_BadInvalidState;
      }
      // validate the config fragment
      if (!validate_config_fragment(conf,resp))
      {
        reset(msg);
        msg << log_e("stop","Failed to stop laser unit. See previous messages");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        if (!resp.contains("status_code"))
        {
          resp["status_code"] = OpcUa_BadInvalidArgument;
        }
        return OpcUa_BadInvalidArgument;
      }
      // validation passed. Loop over the parts and pass the corresponding configuration
      // fragment
      // NOTE: Is the order relevant?
      for (json::iterator it = conf.begin(); it != conf.end(); ++it)
      {
        LOG(Log::INF) << "Processing " << it.key() << " : " << it.value() << "\n";
        //
        if (it.key() == "motors")
        {
          // there are up to three motors.
          // start by checking that
          json mconf = it.value();
          if (mconf.size() != iolmotors().size())
          {
            reset(msg);
            msg << log_e("config","Malformed configuration. Have ") << iolmotors().size()
                                        << " motors, but configuration shows " << it.value().size();
            resp["status"] = "ERROR";
            resp["messages"].push_back(msg.str());
            resp["status_code"] = OpcUa_BadInvalidArgument;
            return OpcUa_BadInvalidArgument;
          }
          // we have matching sizes, configure them in order
          for (size_t i = 0; i < mconf.size(); ++i)
          {
            json mfrag = mconf.at(i);
            for (size_t j = 0; j < iolmotors().size(); ++j)
            {
              if (iolmotors().at(j)->id() == mfrag.at("id").get<std::string>())
              {
                st = iolmotors().at(j)->config(mfrag,resp);
                if (st != OpcUa_Good)
                {
                  reset(msg);
                  resp["status"] = "ERROR";
                  resp["messages"].push_back(msg.str());
                  if (!resp.contains("status_code"))
                  {
                    resp["status_code"] = OpcUa_BadInvalidArgument;
                  }
                  return OpcUa_BadInvalidArgument;
                }
              }
              // if not, continue the loop
            }
          }
          // if we reached this point, all motors are configured
        }
        if (it.key() == "laser")
        {
          // there is only 1 laser
          json lconf = it.value();
          st = iollaserunit()->config(lconf,resp);
          if (st != OpcUa_Good)
          {
            reset(msg);
            msg << log_e("config","Failed to configure laser.");
            resp["status"] = "ERROR";
            resp["messages"].push_back(msg.str());
            if (!resp.contains("status_code"))
            {
              resp["status_code"] = OpcUa_BadInvalidArgument;
            }
            return OpcUa_BadInvalidArgument;
          }
        }
        if (it.key() == "attenuator")
        {
          // there is only 1 laser
          json aconf = it.value();
          st = iolattenuator()->config(aconf,resp);
          if (st != OpcUa_Good)
          {
            reset(msg);
            msg << log_e("config","Failed to configure attenuator.");
            resp["status"] = "ERROR";
            resp["messages"].push_back(msg.str());
            if (!resp.contains("status_code"))
            {
              resp["status_code"] = OpcUa_BadInvalidArgument;
            }
            return OpcUa_BadInvalidArgument;
          }
        }
        // For now there is no configuration necessary for the CIB
        //        if (it.key() == "cib")
        //        {
        //          // there is only 1 laser
        //          json aconf = it.value();
        //          st = iolattenuator()->config(aconf,resp);
        //          if (st != OpcUa_Good)
        //          {
        //            reset(msg);
        //            msg << log_e("config","Failed to configure attenuator.");
        //            resp["status"] = "ERROR";
        //            resp["messages"].push_back(msg.str());
        //            if (!resp.contains("status_code"))
        //            {
        //              resp["status_code"] = OpcUa_BadInvalidArgument;
        //            }
        //            return OpcUa_BadInvalidArgument;
        //          }
        //        }
        // ------------------
        // There's nothing on the piezocontrollers
        //        if (it.key() == "piezo")
        //        {
        //          // there could be up to three piezos
        //          // but I have absolutely no information about them
        //          json aconf = it.value();
        //          st = iolattenuator()->config(aconf,resp);
        //          if (st != OpcUa_Good)
        //          {
        //            reset(msg);
        //            msg << log_e("config","Failed to configure attenuator.");
        //            resp["status"] = "ERROR";
        //            resp["messages"].push_back(msg.str());
        //            if (!resp.contains("status_code"))
        //            {
        //              resp["status_code"] = OpcUa_BadInvalidArgument;
        //            }
        //            return OpcUa_BadInvalidArgument;
        //          }
        //        }
        //----------------------------------
        // power meter : one unit
        //----------------------------------
        if (it.key() == "power_meter")
        {
          // there is only 1
          json pconf = it.value();
          st = iolpowermeter()->config(pconf,resp);
          if (st != OpcUa_Good)
          {
            reset(msg);
            msg << log_e("config","Failed to configure power meter.");
            resp["status"] = "ERROR";
            resp["messages"].push_back(msg.str());
            if (!resp.contains("status_code"))
            {
              resp["status_code"] = OpcUa_BadInvalidArgument;
            }
            return OpcUa_BadInvalidArgument;
          }
        }
      } // loop json
      // if we reached this point, the configurations are all good
      update_state(sReady);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught runtime error : ") << e.what();
      got_exception = true;

    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      reset(msg);
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    else
    {
      reset(msg);
      msg << log_i("config","IoLS configured.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::check_ready(bool &ready)
  {
    ready = is_ready();
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::stop(json &resp)
  {
    UaStatus st;
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // first thing to be stopped is the laser
      // this should only fail if something is not configured
      //st = iollaserunit()->stop(resp);
      //FIXME: Should we set another method that does *really* stop the laser?
      st = iollaserunit()->pause(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        msg << log_e("stop","Failed to stop laser unit. See previous messages");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        if (!resp.contains("status_code"))
        {
          resp["status_code"] = OpcUa_Bad;
        }
        return st;
      }
      // next stop the motors
      for (Device::DIoLMotor* lmotor : iolmotors ())
      {
        st = lmotor->stop(resp);
        if (st != OpcUa_Good)
        {
          reset(msg);
          msg << log_e("stop","Failed to stop motor ") << lmotor->get_id() << ". See previous messages.";
          resp["status"] = "ERROR";
          resp["messages"].push_back(msg.str());
          if (!resp.contains("status_code"))
          {
            resp["status_code"] = OpcUa_Bad;
          }
          return st;
        }
      }
      // none of the other systems are actually critical
      // however, if we stop the laser, there is little point in
      // keeping the power meter reading
      st = iolpowermeter()->stop_readings(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        msg << log_e("stop","Failed to stop power meter ") << iolpowermeter()->getFullName() << ". See previous messages.";
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        if (!resp.contains("status_code"))
        {
          resp["status_code"] = OpcUa_Bad;
        }
        return st;
      }
      // if it reached this point we are currently stopped
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught runtime error : ") << e.what();
      got_exception = true;

    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    else
    {
      reset(msg);
      msg << log_i("stop","IoLS system stopped.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }

  UaStatus DIoLaserSystem::fire_at_position(const std::vector<int32_t>&  target_pos, uint16_t num_pulses, json &resp)
  {
    UaStatus st;
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // first check that the whole system is in a state that could be considered as valid
      // the tricky part here is that this definition depends on many things
      /**
       * For example, the laser can be considered ready if it is in sLasing, sReady or sStandby states
       * The motor is ready if it is not moving and has a speed defined
       * The power meter is always ready, as far as it is configured
       * The attenuator is always ready
       */
      if (!is_ready())
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("fire_at_position","System is not ready to operate. Check the status of the various subsystems.");
        resp["messages"].push_back(msg.str());
        resp["status_code"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }
      // step 0: Check if the laser is in a valid operating state
      // these are sLasing, sPause and sStandby
      // any other state requires extra stuff to operate
      if (!iollaserunit()->good_for_operation())
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("fire_at_position","Laser is not in the right state.");
        resp["messages"].push_back(msg.str());
        resp["status_code"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }
      // if it is ready, pass on the information to the respective subsystems
      //
      // in this case the laser is not going to just start firing, but simply fire a discrete number of pulses
      // there is a specific callfor that under the IOLaser device
      // -- the motors are identified, so each entry refers to a motor
      // do a check on the order of position and number of motors
      if (target_pos.size()!= iolmotors().size())
      {
        // different number of position coordinates and motors
        resp["status"] = "ERROR";
        reset(msg);
        msg << log_e("fire_at_position","Different number of coordinates (")
                                              << target_pos.size() << ") and available motors ("
                                              << iolmotors().size() << "). Refusing to operate.";
        resp["messages"].push_back(msg.str());
        resp["status_code"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      //
      if (num_pulses < 1)
      {
        resp["status"] = "ERROR";
        std::ostringstream msg("");
        msg << log_e("fire_at_position","Invalid number of pulses (")
                                              << num_pulses << "). Value must be at least 1.";
        resp["messages"].push_back(msg.str());
        resp["status_code"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      //
      // ready to operate
      // -- be sure to set the shutter closed until destination is reached
      // the logic is the following
      // 1. Call each of the the motors to move to the desired position
      // 2. open the shutter
      // 3. fire a discrete number of shots
      // 4. close the shutter
      // step 1
      for (std::vector<OpcUa_Int32>::size_type idx = 0; idx < target_pos.size(); idx++)
      {
        for (Device::DIoLMotor* lmotor : iolmotors ())
        {
          if (lmotor->get_coordinate_index() == idx)
          {
            st = lmotor->set_position_setpoint(target_pos[idx]);
            if (st != OpcUa_Good)
            {
              resp["status"] = "ERROR";
              std::ostringstream msg("");
              msg << log_e("fire_at_position","Failed to set target position for motor (id : ")
                                                    << lmotor->get_id() << ").";
              resp["messages"].push_back(msg.str());
              resp["status_code"] = static_cast<uint32_t>(st);
              return st;
            }
            // now move the motor
            st = lmotor->move_motor(resp);
            if (st != OpcUa_Good)
            {
              resp["status"] = "ERROR";
              std::ostringstream msg("");
              msg << log_e("fire_at_position","Failed to initiate motor movement on motor (id : ")
                                                    << lmotor->get_id() << ").";
              resp["messages"].push_back(msg.str());
              resp["status_code"] = static_cast<uint32_t>(st);
              return st;
            }
          }
        }
      }
      // step 1.2: wait until motors are in place
      // does this really make sense? This is a synchronous method
      // one could be for a long wait until it
      // executes
      // FIXME: ideally, this should spawn a separate process that would complete the execution when
      // the motors reach the destination
      // for now, as a stopgap measure, we do wait
      bool is_moving = true;
      while (is_moving)
      {
        is_moving = false;
        for (Device::DIoLMotor* lmotor : iolmotors ())
        {
          is_moving |= lmotor->is_moving();
          std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
      }
      //
      //
      // we have reached the destination
      // step 2: resume operation of the laser unit
      st = iollaserunit()->fire_discrete_shots(num_pulses,resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("fire_at_position","Failed to fire laser. Check previous messages.");
        resp["messages"].push_back(msg.str());
        resp["status_code"] = static_cast<uint32_t>(st);
        // force a pause (again)
        iollaserunit()->pause(resp);
        return resp["status_code"];
      }
      // at this stage we are done
      // make sure that the laser is in pause state
      iollaserunit()->pause(resp);
    }
    catch(json::exception &e)
    {
      reset(msg);
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      reset(msg);
      msg << log_e("stop","Caught runtime error : ") << e.what();
      got_exception = true;

    }
    catch(std::exception &e)
    {
      reset(msg);
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      reset(msg);
      msg << log_e("stop","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    else
    {
      reset(msg);
      msg << log_i("stop","Command successful.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::fire_segment(
      const std::vector<OpcUa_Int32>&  spos,
      const std::vector<OpcUa_Int32>&  lpos,
      json& resp
  )
  {
    UaStatus st;
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // first check that the whole system is in a state that could be considered as valid
      // the tricky part here is that this definition depends on many things
      /**
       * For example, the laser can be considered ready if it is in sLasing, sReady or sStandby states
       * The motor is ready if it is not moving and has a speed defined
       * The power meter is always ready, as far as it is configured
       * The attenuator is always ready
       */
      if (!is_ready())
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("fire_segment","System is not ready to operate. Check the status of the various subsystems.");
        resp["messages"].push_back(msg.str());
        resp["status_code"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }
      // step 0: Check if the laser is in a valid operating state
      // these are sLasing, sPause and sStandby
      // any other state requires extra stuff to operate
      if (!iollaserunit()->good_for_operation())
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("fire_segment","Laser is not in the right state.");
        resp["messages"].push_back(msg.str());
        resp["status_code"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }

      //
      // Operation sequence
      //
      // 1. set target destination for all motors
      // 2. move motors into start point
      // 3. set inital fire position
      // 5. initiate movement
      // 6. open iris
      // 7. When reaching destination, close iris

      // if it is ready, pass on the information to the respective subsystems
      //
      // in this case the laser is not going to just start firing, but simply fire a discrete number of pulses
      // there is a specific callfor that under the IOLaser device
      // -- the motors are identified, so each entry refers to a motor
      // do a check on the order of position and number of motors
      if (spos.size()!= iolmotors().size())
      {
        // different number of position coordinates and motors
        resp["status"] = "ERROR";
        reset(msg);
        msg << log_e("fire_segment","Different number of start coordinates (")
                                              << spos.size() << ") and available motors ("
                                              << iolmotors().size() << "). Refusing to operate.";
        resp["messages"].push_back(msg.str());
        resp["status_code"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      // do the same for the target
      if (lpos.size()!= iolmotors().size())
      {
        // different number of position coordinates and motors
        resp["status"] = "ERROR";
        reset(msg);
        msg << log_e("fire_segment","Different number of end coordinates (")
                                              << spos.size() << ") and available motors ("
                                              << iolmotors().size() << "). Refusing to operate.";
        resp["messages"].push_back(msg.str());
        resp["status_code"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      // second check. Only one of the motors should be moving,
      // or we're in for a world of pain
      int n_moving_motors = 0;
      for (size_t i = 0; i < spos.size(); ++i)
      {
        if (spos.at(i) != lpos.at(i))
        {
          n_moving_motors++;
        }
      }
      if (n_moving_motors != 1)
      {
        resp["status"] = "ERROR";
        reset(msg);
        msg << log_e("fire_segment","More than one motor moving. (")
                                              << n_moving_motors << "). Expected 1. Refusing to operate.";
        resp["messages"].push_back(msg.str());
        resp["status_code"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      // all conditions are checked. Now start the operation
      // the status is set to sOperating and a separate thread is ran to process it
      // however, during this time, nothing else can be done with the system
      update_state(sOperating);
      init_segment_task(spos,lpos);
      // this is the poor mans equivalent of an async method
      // for now consider the task done
    }
    catch(json::exception &e)
    {
      reset(msg);
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      reset(msg);
      msg << log_e("stop","Caught runtime error : ") << e.what();
      got_exception = true;

    }
    catch(std::exception &e)
    {
      reset(msg);
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      reset(msg);
      msg << log_e("stop","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    else
    {
      reset(msg);
      msg << log_i("stop","Command successful.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }
  void DIoLaserSystem::init_segment_task(const std::vector<OpcUa_Int32>&  spos,
                                         const std::vector<OpcUa_Int32>&  lpos
  )
  {
    // this task runs on a separate thread
    // since there is no return to the user space
    // messages are queued in a separate variable that can then be queried
    // also keep in mind that at this stage all verifications have been performed, so
    // the task does not need base checks
    std::thread([this]()
                {
      UaStatus st;
      std::ostringstream msg("");
      json resp;
      //
      // ready to operate
      // -- be sure to set the shutter closed until destination is reached
      // the logic is the following
      // 0. Make sure that the laser is in Pause state
      // 1. Call each of the the motors to move to the starting position
      // 2. Set the target position for each motor
      // 3. Initiate movement
      // 4. call resume (switch to sLasing)
      // 5. Wait for motors to report end of travel
      // 6. switch back to pause
      // 7. Assess success
      //
      // step 0: before we even start doing anything
      // force the laser into a pause state
      st = iollaserunit()->pause(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        msg << log_e("fire_segment","Failed to set laser into Pause state");;
        resp["messages"].push_back(msg.str());
        resp["status"] = "ERROR";
        resp["status_code"] = static_cast<uint32_t>(st);
        m_task_message_queue = resp;
        // nothing is being done, so just terminate this task
        // update the state to error
        update_state(sError);
        return;
      }
      // step 1
      // we can initiate the movement
      st = move_motor(spos,resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        msg << log_e("fire_segment","Failed to move to start position");;
        resp["messages"].push_back(msg.str());
        resp["status"] = "ERROR";
        resp["status_code"] = static_cast<uint32_t>(st);
        m_task_message_queue = resp;
        // nothing is being done, so just terminate this task
        // update the state to error
        update_state(sError);
        return;
      }
      // step 1.2: wait until motors are in place
      // since this is a separate task, we *must* wait for things to be ready
      bool is_moving = true;
      while (is_moving)
      {
        is_moving = false;
        for (Device::DIoLMotor* lmotor : iolmotors ())
        {
          is_moving |= lmotor->is_moving();
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
      }
      //
      //
      // we have reached the destination
      // step 2: set target position
      st = move_motor(lpos,resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        msg << log_e("fire_segment","Failed to iniiate movement to destination");;
        resp["messages"].push_back(msg.str());
        resp["status"] = "ERROR";
        resp["status_code"] = static_cast<uint32_t>(st);
        m_task_message_queue = resp;
        // nothing is being done, so just terminate this task
        // update the state to error
        update_state(sError);
        return;
      }
      //
      // step 3: initiate movement (already done)
      //
      //
      // step 4: tell laser to get into business
      //
      st = iollaserunit()->resume(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("fire_segment","Failed to activate laser. Check previous messages.");
        resp["messages"].push_back(msg.str());
        resp["status_code"] = static_cast<uint32_t>(st);
        // force a pause (again)
        iollaserunit()->pause(resp);
        m_task_message_queue = resp;
        update_state(sError);
        return;
      }
      // step 5: wait for motors to report stopped
      is_moving = true;
      while (is_moving)
      {
        is_moving = false;
        for (Device::DIoLMotor* lmotor : iolmotors ())
        {
          is_moving |= lmotor->is_moving();
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
      }
      // step 6: switch back to pause
      st = iollaserunit()->pause(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("fire_segment","Failed to pase laser at the end. Check previous messages.");
        resp["messages"].push_back(msg.str());
        resp["status_code"] = static_cast<uint32_t>(st);
        // force a pause (again)
        iollaserunit()->pause(resp);
        m_task_message_queue = resp;
        update_state(sError);
        return;
      }
      // if it reached this stage, all is well and we should update the state back to
      // sPause
      reset(msg);
      resp["status"] = "OK";
      msg << log_e("fire_segment","Operation was successful.");
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_Good;
      update_state(sPause);
                }
    ).detach();
  }
  UaStatus DIoLaserSystem::move_motor(
      const std::vector<OpcUa_Int32>&  position,
      json &resp)
  {
    std::ostringstream msg("");
    UaStatus st;

    for (std::vector<OpcUa_Int32>::size_type idx = 0; idx < position.size(); idx++)
    {
      for (Device::DIoLMotor* lmotor : iolmotors ())
      {
        if (lmotor->get_coordinate_index() == idx)
        {
          st = lmotor->set_position_setpoint(position.at(idx));
          if (st != OpcUa_Good)
          {
            resp["status"] = "ERROR";
            reset(msg);
            msg << log_e("move_motor","Failed to set target position for motor (id : ")
                                            << lmotor->get_id() << ").";
            resp["messages"].push_back(msg.str());
            resp["status_code"] = static_cast<uint32_t>(st);
            // nothing is being done, so just terminate this task
            return st;
          }
          // now move the motor
          st = lmotor->move_motor(resp);
          if (st != OpcUa_Good)
          {
            resp["status"] = "ERROR";
            msg << log_e("move_motor","Failed to initiate motor movement on motor (id : ")
                                            << lmotor->get_id() << ").";
            resp["messages"].push_back(msg.str());
            resp["status_code"] = static_cast<uint32_t>(st);
            return st;
          }
        }
      }
    }
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::execute_scan(json &plan, json &resp)
  {
    // this one is a hell of a tricky one
    // it is in many ways similar to fire segment, with a few caveats
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::pause(json &resp);
  UaStatus DIoLaserSystem::standby(json &resp);
  UaStatus DIoLaserSystem::resume(json &resp);
  UaStatus DIoLaserSystem::warmup(json &resp);
  UaStatus DIoLaserSystem::shutdown(json &resp)
  UaStatus DIoLaserSystem::move_to_pos(
      const std::vector<OpcUa_Int32>&  position,
      const std::vector<OpcUa_Byte>&  approach,
      json &resp)
  {
    std::ostringstream msg("");

  }
  bool DIoLaserSystem::validate_config_fragment(json &frag, json &resp)
  {
    // check that a series of parameters are set
    // also check that this fragment has the ID that is corresponding to this specific laser system
    // this is just a validation check for the available keys.
    // it will only check the mandatory keys.
    std::ostringstream msg("");
    std::vector<std::string> keys = {"id","motor","attenuator","laser",
        "power_meter", "cib", "piezo"
    };
    if (!frag.contains("id"))
    {
      reset(msg);
      msg << log_e("validate_config","Configuration fragment missing system ID");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidArgument;
      return false;
    }
    if (frag.at("id").get<std::string>() != id())
    {
      reset(msg);
      msg << log_e("validate_config","Configuration fragment has a mismatched ID. Expected ") << id();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidArgument;
      return false;
    }
    // actually, check for all entries and report all missing ones
    std::vector<std::string> missing;
    for (auto entry: keys)
    {
      if (!frag.contains(entry))
      {
        missing.push_back(entry);
      }
    }
    if (missing.size() > 0)
    {
      msg.clear(); msg.str("");
      msg << log_e("validate_config","Missing entries in IoLS config fragment [");
      for (auto e : missing)
      {
        msg << "(" <<  e << "),";
      }
      msg << "]";
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["status_code"] = OpcUa_BadInvalidArgument;
      return false;
    }
    // all good, return true
    return true;
  }
  void DIoLaserSystem::update()
  {
    // call update over all daughters
    for (Device::DIoLLaserUnit* lunit : iollaserunits())
    {
      lunit->update();
    }
    for (Device::DIoLMotor* lmotor : iolmotors ())
    {
      lmotor->update();
    }
    for (Device::DIoLPiezoController* lctl : iolpiezocontrollers () )
    {
      lctl->update();
    }
    for (Device::DIoLAttenuator* latt : iolattenuators ())
    {
      latt->update();
    }
    for (Device::DIoLPowerMeter* lmeter : iolpowermeters())
    {
      lmeter->update();
    }
  }
  bool DIoLaserSystem::is_ready()
  {
    for (Device::DIoLLaserUnit* lunit : iollaserunits())
    {
      if (!lunit->is_ready())
      {
        return false;
      }
    }
    for (Device::DIoLMotor* lmotor : iolmotors ())
    {
      if (!lmotor->is_ready())
      {
        return false;
      }
    }
    for (Device::DIoLPiezoController* lctl : iolpiezocontrollers () )
    {
      if (!lctl->is_ready())
      {
        return false;
      }
    }
    for (Device::DIoLAttenuator* latt : iolattenuators ())
    {
      if (!latt->is_ready())
      {
        return false;
      }
    }
    for (Device::DIoLPowerMeter* lmeter : iolpowermeters())
    {
      if (!lmeter->is_ready())
      {
        return false;
      }
    }
    return true;
  }
  void DIoLaserSystem::reset(std::ostringstream &s)
  {
    s.clear();
    s.str("");
  }
  void DIoLaserSystem::update_state(State s)
  {
    m_state = s;
    UaString ss(m_state_map.at(m_state).c_str());
    getAddressSpaceLink()->setState(ss,OpcUa_Good);
  }
  void DIoLaserSystem::get_message_queue(json &resp, bool clear)
  {
    resp = m_task_message_queue;
    if (clear)
    {
      m_task_message_queue.clear();
    }
  }


}
