
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.

    The stub of this file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.


 */


#include <Configuration.hxx> // TODO; should go away, is already in Base class for ages

#include <DIoLaserSystem.h>
#include <ASIoLaserSystem.h>

#include <DIoLLaserUnit.h>
#include <DIoLMotor.h>
#include <DIoLAttenuator.h>
#include <DIoLPowerMeter.h>
#include <DIoLCIB.h>
#include <thread>
#include <string>
#include <chrono>

#define log_msg(s,met,dev,msg) "[" << s << "]::" << dev << ":" << met << " : " << msg

#define log_e(m,s) log_msg("ERROR","iols",m,s)
#define log_w(m,s) log_msg("WARN","iols",m,s)
#define log_i(m,s) log_msg("INFO","iols",m,s)

using std::ostringstream;

namespace Device
{
// 1111111111111111111111111111111111111111111111111111111111111111111111111
// 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
// 1     Users don't modify this code!!!!                                  1
// 1     If you modify this code you may start a fire or a flood somewhere,1
// 1     and some human being may possible cease to exist. You don't want  1
// 1     to be charged with that!                                          1
// 1111111111111111111111111111111111111111111111111111111111111111111111111






// 2222222222222222222222222222222222222222222222222222222222222222222222222
// 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
// 2     (code for which only stubs were generated automatically)          2
// 2     You should add the implementation but dont alter the headers      2
// 2     (apart from constructor, in which you should complete initializati2
// 2     on list)                                                          2
// 2222222222222222222222222222222222222222222222222222222222222222222222222

/* sample ctr */
DIoLaserSystem::DIoLaserSystem (
    const Configuration::IoLaserSystem& config,
    Parent_DIoLaserSystem* parent
):
    Base_DIoLaserSystem( config, parent)

    /* fill up constructor initialization list here */
                                                    ,m_state(sOffline)
{
    /* fill up constructor body here */
  // this had to be in the constructor

  m_state_map.insert({sOffline,"offline"});
  m_state_map.insert({sReady,"ready"});
  m_state_map.insert({sWarmup,"warmup"});
  m_state_map.insert({sOperating,"operating"});
  m_state_map.insert({sPause,"pause"});
  m_state_map.insert({sStandby,"standby"});


}

/* sample dtr */
DIoLaserSystem::~DIoLaserSystem ()
{
}

/* delegates for cachevariables */



/* delegators for methods */
UaStatus DIoLaserSystem::callLoad_config (
    const UaString&  conf,
    UaString& response
)
{
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      json cfrag = json::parse(conf.toUtf8());
      st = config(cfrag,resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        msg << log_e("config","Configuration failed. See previous messages");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        if (!resp.contains("statuscode"))
        {
          resp["statuscode"] = OpcUa_BadInvalidArgument;
        }
      }
      else
      {
        msg << log_i("config","System configured.");
        resp["messages"].push_back(msg.str());
        resp["status"] = "OK";
        resp["statuscode"] = OpcUa_Good;
      }
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callCheck_ready (
    OpcUa_Boolean& ready
)
{
    // check the states of all systems
    // check all associated subsystems if they're ready
    bool rdy = true;
    for (Device::DIoLLaserUnit* lunit : iollaserunits())
    {
      rdy |= lunit->is_ready();
    }
//    for (Device::DIoLMotor* lmotor : iolmotors ())
//    {
//      rdy |= lmotor->is_ready();
//    }
    for (Device::DIoLAttenuator* latt : iolattenuators ())
    {
      rdy |= latt->is_ready();
    }
    ready = rdy;
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callStop (
    UaString& response
)
{
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = stop(resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("config","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    //response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callFire_at_position (
    const std::vector<OpcUa_Int32>&  target_pos,
    OpcUa_UInt16 num_pulses,
    OpcUa_Boolean enable_lbls_trigger,
    UaString& answer
)
{
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = fire_at_position(target_pos,num_pulses,resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    answer = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callFire_segment (
    const std::vector<OpcUa_Int32>&  start_pos,
    const std::vector<OpcUa_Int32>&  last_pos,
    OpcUa_Boolean enable_lbls_trigger,
    UaString& answer
)
{
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = fire_segment(start_pos,last_pos,resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("fire_segment","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("fire_segment","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("fire_segment","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    answer = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callExecute_scan (
    const UaString&  plan,
    OpcUa_Boolean enable_lbls_trigger,
    UaString& answer
)
{
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;

    UaStatus st;
    try
    {
      json scan = json::parse(plan.toUtf8());
      st = execute_scan(scan,resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("execute_scan","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("execute_scan","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("execute_scan","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    answer = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callPause (
    UaString& answer
)
{
    return OpcUa_BadNotImplemented;
}
UaStatus DIoLaserSystem::callStandby (
    UaString& answer
)
{
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = standby(resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("standby","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("standby","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("standby","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    answer = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callResume (
    UaString& response
)
{
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = resume(resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("resume","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("resume","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("resume","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callWarmup_laser (
    UaString& response
)
{
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = warmup(resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("warmup","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("warmup","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("warmup","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callShutdown (
    UaString& response
)
{
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      st = shutdown(resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("shutdown","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("shutdown","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("shutdown","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}
UaStatus DIoLaserSystem::callMove_to_pos (
    const std::vector<OpcUa_Int32>&  position,
    const UaString&  approach,
    UaString& response
)
{
    std::ostringstream msg("");
    bool got_exception = false;
    json resp;
    UaStatus st;
    try
    {
      // convert to an array that
      std::string appr(approach.toUtf8());
      st = move_to_pos(position,appr,resp);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("move_to_pos","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("move_to_pos","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("move_to_pos","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
    }
    response = UaString(resp.dump().c_str());
    return OpcUa_Good;
}

// 3333333333333333333333333333333333333333333333333333333333333333333333333
// 3     FULLY CUSTOM CODE STARTS HERE                                     3
// 3     Below you put bodies for custom methods defined for this class.   3
// 3     You can do whatever you want, but please be decent.               3
// 3333333333333333333333333333333333333333333333333333333333333333333333333
  UaStatus DIoLaserSystem::config(json &conf, json &resp)
  {
    UaStatus st;
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // first thing is to check that we are either in sInit or sReady states
      if ((m_state != sOffline) and (m_state != sReady))
      {
        reset(msg);
        msg << log_e("config","System is operating. Can only configure when stopped.");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidState;
        return OpcUa_BadInvalidState;
      }
      // validate the config fragment
      if (!validate_config_fragment(conf,resp))
      {
        reset(msg);
        msg << log_e("stop","Failed to validate configuration fragment. See previous messages");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        if (!resp.contains("statuscode"))
        {
          resp["statuscode"] = OpcUa_BadInvalidArgument;
        }
        return OpcUa_BadInvalidArgument;
      }
      // validation passed. Loop over the parts and pass the corresponding configuration
      // fragment
      // NOTE: Is the order relevant?
      for (json::iterator it = conf.begin(); it != conf.end(); ++it)
      {
        LOG(Log::INF) << "Processing " << it.key() << " : " << it.value() << "\n";
        //
        if (it.key() == "motors")
        {
          // there are up to three motors.
          // start by checking that
          json mconf = it.value();
          if (mconf.size() != iolmotors().size())
          {
            reset(msg);
            msg << log_e("config","Malformed configuration. Have ") << iolmotors().size()
                                                    << " motors, but configuration shows " << it.value().size();
            resp["status"] = "ERROR";
            resp["messages"].push_back(msg.str());
            resp["statuscode"] = OpcUa_BadInvalidArgument;
            return OpcUa_BadInvalidArgument;
          }
          // we have matching sizes, configure them in order
          for (size_t i = 0; i < mconf.size(); ++i)
          {
            json mfrag = mconf.at(i);
            for (size_t j = 0; j < iolmotors().size(); ++j)
            {
              if (iolmotors().at(j)->id() == mfrag.at("id").get<std::string>())
              {
                st = iolmotors().at(j)->config(mfrag,resp);
                if (st != OpcUa_Good)
                {
                  reset(msg);
                  resp["status"] = "ERROR";
                  resp["messages"].push_back(msg.str());
                  if (!resp.contains("statuscode"))
                  {
                    resp["statuscode"] = OpcUa_BadInvalidArgument;
                  }
                  return OpcUa_BadInvalidArgument;
                }
                // if it configured well, add the entry to the coordinate map
                m_map_motor_coordinates.insert(std::pair<size_t,size_t>(iolmotors().at(j)->get_coordinate_index(),j));
              }
              // if not, continue the loop
            }
          }
          // if we reached this point, all motors are configured
        }
        if (it.key() == "laser")
        {
          // there is only 1 laser
          json lconf = it.value();
          st = iollaserunit()->config(lconf,resp);
          if (st != OpcUa_Good)
          {
            reset(msg);
            msg << log_e("config","Failed to configure laser.");
            resp["status"] = "ERROR";
            resp["messages"].push_back(msg.str());
            if (!resp.contains("statuscode"))
            {
              resp["statuscode"] = OpcUa_BadInvalidArgument;
            }
            return OpcUa_BadInvalidArgument;
          }
        }
        if (it.key() == "attenuator")
        {
          // there is only 1 laser
          json aconf = it.value();
          st = iolattenuator()->config(aconf,resp);
          if (st != OpcUa_Good)
          {
            reset(msg);
            msg << log_e("config","Failed to configure attenuator.");
            resp["status"] = "ERROR";
            resp["messages"].push_back(msg.str());
            if (!resp.contains("statuscode"))
            {
              resp["statuscode"] = OpcUa_BadInvalidArgument;
            }
            return OpcUa_BadInvalidArgument;
          }
        }
        // For now there is no configuration necessary for the CIB
        if (it.key() == "cib")
        {
          json aconf = it.value();
          st = iolcib()->config(aconf,resp);
          if (st != OpcUa_Good)
          {
            reset(msg);
            msg << log_e("config","Failed to configure CIB.");
            resp["status"] = "ERROR";
            resp["messages"].push_back(msg.str());
            if (!resp.contains("statuscode"))
            {
              resp["statuscode"] = OpcUa_BadInvalidArgument;
            }
            return OpcUa_BadInvalidArgument;
          }
        }
        // ------------------
        // power meter : one unit
        //----------------------------------
        if (it.key() == "power_meter")
        {
          // there is only 1
          json pconf = it.value();
          st = iolpowermeter()->config(aconf,resp);
            if (st != OpcUa_Good)
            {
              reset(msg);
              msg << log_e("config","Failed to configure power meter.");
              resp["status"] = "ERROR";
              resp["messages"].push_back(msg.str());
              if (!resp.contains("statuscode"))
              {
                resp["statuscode"] = OpcUa_BadInvalidArgument;
              }
              return OpcUa_BadInvalidArgument;
            }

          // for (auto meter : iolpowermeters())
          // {
          //   st = meter->config(pconf,resp);
          //   if (st != OpcUa_Good)
          //   {
          //     reset(msg);
          //     msg << log_e("config","Failed to configure power meter.");
          //     resp["status"] = "ERROR";
          //     resp["messages"].push_back(msg.str());
          //     if (!resp.contains("statuscode"))
          //     {
          //       resp["statuscode"] = OpcUa_BadInvalidArgument;
          //     }
          //     return OpcUa_BadInvalidArgument;
          //   }
          // }
        }
      } // loop json
      // if we reached this point, the configurations are all good
      update_state(sReady);
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught runtime error : ") << e.what();
      got_exception = true;

    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      reset(msg);
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    else
    {
      reset(msg);
      msg << log_i("config","IoLS configured.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::check_ready(bool &ready)
  {
    ready = is_ready();
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::stop(json &resp)
  {
    UaStatus st;
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // first thing to be stopped is the laser
      // this should only fail if something is not configured
      //st = iollaserunit()->stop(resp);
      //FIXME: Should we set another method that does *really* stop the laser?
      st = iollaserunit()->pause(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        msg << log_e("stop","Failed to stop laser unit. See previous messages");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        if (!resp.contains("statuscode"))
        {
          resp["statuscode"] = OpcUa_Bad;
        }
        return st;
      }
      // next stop the motors
      for (Device::DIoLMotor* lmotor : iolmotors ())
      {
        st = lmotor->motor_stop(resp);
        if (st != OpcUa_Good)
        {
          reset(msg);
          msg << log_e("stop","Failed to stop motor ") << lmotor->id() << ". See previous messages.";
          resp["status"] = "ERROR";
          resp["messages"].push_back(msg.str());
          if (!resp.contains("statuscode"))
          {
            resp["statuscode"] = OpcUa_Bad;
          }
          return st;
        }
      }
      // none of the other systems are actually critical
      // however, if we stop the laser, there is little point in
      // keeping the power meter reading
      st = iolpowermeter()->stop_readings(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        msg << log_e("stop","Failed to stop power meter ") << iolpowermeter()->getFullName() << ". See previous messages.";
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        if (!resp.contains("statuscode"))
        {
          resp["statuscode"] = OpcUa_Bad;
        }
        return st;
      }
      // for (auto meter : iolpowermeters())
      // {
      //   st = meter->stop_readings(resp);
      //   if (st != OpcUa_Good)
      //   {
      //     reset(msg);
      //     msg << log_e("stop","Failed to stop power meter ") << meter->getFullName() << ". See previous messages.";
      //     resp["status"] = "ERROR";
      //     resp["messages"].push_back(msg.str());
      //     if (!resp.contains("statuscode"))
      //     {
      //       resp["statuscode"] = OpcUa_Bad;
      //     }
      //     return st;
      //   }
      // }
      // if it reached this point we are currently stopped
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught runtime error : ") << e.what();
      got_exception = true;

    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e("stop","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    else
    {
      reset(msg);
      msg << log_i("stop","IoLS system stopped.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }

  UaStatus DIoLaserSystem::fire_at_position(const std::vector<int32_t>&  target_pos, uint16_t num_pulses, json &resp)
  {
    const std::string lbl = "fire_at_position";
    UaStatus st;
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // first check that the whole system is in a state that could be considered as valid
      // the tricky part here is that this definition depends on many things
      /**
       * For example, the laser can be considered ready if it is in sLasing, sReady or sStandby states
       * The motor is ready if it is not moving and has a speed defined
       * The power meter is always ready, as far as it is configured
       * The attenuator is always ready
       */
      if (!is_ready())
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e(lbl.c_str(),"System is not ready to operate. Check the status of the various subsystems.");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }
      // step 0: Check if the laser is in a valid operating state
      // these are sLasing, sPause and sStandby
      // any other state requires extra stuff to operate
      if (!iollaserunit()->good_for_operation())
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e(lbl.c_str(),"Laser is not in the right state.");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }
      // if it is ready, pass on the information to the respective subsystems
      //
      // in this case the laser is not going to just start firing, but simply fire a discrete number of pulses
      // there is a specific callfor that under the IOLaser device
      // -- the motors are identified, so each entry refers to a motor
      // do a check on the order of position and number of motors
      if (target_pos.size()!= iolmotors().size())
      {
        // different number of position coordinates and motors
        resp["status"] = "ERROR";
        reset(msg);
        msg << log_e(lbl.c_str(),"Different number of coordinates (")
                                                          << target_pos.size() << ") and available motors ("
                                                          << iolmotors().size() << "). Refusing to operate.";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      //
      if (num_pulses < 1)
      {
        resp["status"] = "ERROR";
        std::ostringstream msg("");
        msg << log_e(lbl.c_str(),"Invalid number of pulses (")
                                                          << num_pulses << "). Value must be at least 1.";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      //
      // ready to operate
      // -- be sure to set the shutter closed until destination is reached
      // the logic is the following
      // 1. Call each of the the motors to move to the desired position
      // 2. open the shutter
      // 3. fire a discrete number of shots
      // 4. close the shutter
      // step 1
      for (std::vector<OpcUa_Int32>::size_type idx = 0; idx < target_pos.size(); idx++)
      {
        for (Device::DIoLMotor* lmotor : iolmotors ())
        {
          if (lmotor->get_coordinate_index() == idx)
          {
            st = lmotor->set_position_setpoint(target_pos[idx]);
            if (st != OpcUa_Good)
            {
              resp["status"] = "ERROR";
              std::ostringstream msg("");
              msg << log_e(lbl.c_str(),"Failed to set target position for motor (id : ")
                                                                << lmotor->get_id() << ").";
              resp["messages"].push_back(msg.str());
              resp["statuscode"] = static_cast<uint32_t>(st);
              return st;
            }
            // now move the motor
            st = lmotor->motor_move(resp);
            if (st != OpcUa_Good)
            {
              resp["status"] = "ERROR";
              std::ostringstream msg("");
              msg << log_e(lbl.c_str(),"Failed to initiate motor movement on motor (id : ")
                                                                << lmotor->get_id() << ").";
              resp["messages"].push_back(msg.str());
              resp["statuscode"] = static_cast<uint32_t>(st);
              return st;
            }
          }
        }
      }
      // step 1.2: wait until motors are in place
      // does this really make sense? This is a synchronous method
      // one could be for a long wait until it
      // executes
      // FIXME: ideally, this should spawn a separate process that would complete the execution when
      // the motors reach the destination
      // for now, as a stopgap measure, we do wait
      bool is_moving = true;
      while (is_moving)
      {
        is_moving = false;
        for (Device::DIoLMotor* lmotor : iolmotors ())
        {
          is_moving |= lmotor->is_moving();
          std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
      }
      //
      //
      // we have reached the destination
      // step 2.0 : start power meter readings
      st = iolpowermeter()->start_readings(resp);
      if (st != OpcUa_Good)
      {
        msg.clear(); msg.str("");
        msg << log_e(lbl.c_str(),"Failed to start power meter");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = static_cast<uint32_t>(st);
        LOG(Log::ERR) << msg.str();
        return st;
      }
      // for (Device::DIoLPowerMeter* lmeter : iolpowermeters())
      // {
      //   st = lmeter->start_readings(resp);
      // }
      // step 2: resume operation of the laser unit
      st = iollaserunit()->fire_discrete_shots(num_pulses,resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e(lbl.c_str(),"Failed to fire laser. Check previous messages.");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = static_cast<uint32_t>(st);
        // force a pause (again)
        iollaserunit()->pause(resp);
        return static_cast<UaStatus>(resp["statuscode"].get<uint32_t>());
      }
      // at this stage we are done
      // make sure that the laser is in pause state
      st = iollaserunit()->pause(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        msg << log_e(lbl.c_str(),"Failed to set later in pause mode.");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = static_cast<uint32_t>(st);
        return st;
      }
      st = iolpowermeter()->stop_readings();
      // for (Device::DIoLPowerMeter* lmeter : iolpowermeters())
      // {
      //   st = lmeter->stop_readings(resp);
      // }

    }
    catch(json::exception &e)
    {
      reset(msg);
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      reset(msg);
      msg << log_e("stop","Caught runtime error : ") << e.what();
      got_exception = true;

    }
    catch(std::exception &e)
    {
      reset(msg);
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      reset(msg);
      msg << log_e("stop","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    else
    {
      reset(msg);
      msg << log_i("stop","Command successful.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::fire_segment(
      const std::vector<OpcUa_Int32>&  spos,
      const std::vector<OpcUa_Int32>&  lpos,
      json& resp
  )
  {
    UaStatus st;
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // first check that the whole system is in a state that could be considered as valid
      // the tricky part here is that this definition depends on many things
      /**
       * For example, the laser can be considered ready if it is in sLasing, sReady or sStandby states
       * The motor is ready if it is not moving and has a speed defined
       * The power meter is always ready, as far as it is configured
       * The attenuator is always ready
       */
      if (!is_ready())
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("fire_segment","System is not ready to operate. Check the status of the various subsystems.");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }
      // step 0: Check if the laser is in a valid operating state
      // these are sLasing, sPause and sStandby
      // any other state requires extra stuff to operate
      if (!iollaserunit()->good_for_operation())
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("fire_segment","Laser is not in the right state.");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }

      //
      // Operation sequence
      //
      // 1. set target destination for all motors
      // 2. move motors into start point
      // 3. set inital fire position
      // 5. initiate movement
      // 6. open iris
      // 7. When reaching destination, close iris

      // if it is ready, pass on the information to the respective subsystems
      //
      // in this case the laser is not going to just start firing, but simply fire a discrete number of pulses
      // there is a specific callfor that under the IOLaser device
      // -- the motors are identified, so each entry refers to a motor
      // do a check on the order of position and number of motors
      if (spos.size()!= iolmotors().size())
      {
        // different number of position coordinates and motors
        resp["status"] = "ERROR";
        reset(msg);
        msg << log_e("fire_segment","Different number of start coordinates (")
                                                          << spos.size() << ") and available motors ("
                                                          << iolmotors().size() << "). Refusing to operate.";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      // do the same for the target
      if (lpos.size()!= iolmotors().size())
      {
        // different number of position coordinates and motors
        resp["status"] = "ERROR";
        reset(msg);
        msg << log_e("fire_segment","Different number of end coordinates (")
                                                          << spos.size() << ") and available motors ("
                                                          << iolmotors().size() << "). Refusing to operate.";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      // second check. Only one of the motors should be moving,
      // or we're in for a world of pain
      int n_moving_motors = 0;
      for (size_t i = 0; i < spos.size(); ++i)
      {
        if (spos.at(i) != lpos.at(i))
        {
          n_moving_motors++;
        }
      }
      if (n_moving_motors != 1)
      {
        resp["status"] = "ERROR";
        reset(msg);
        msg << log_e("fire_segment","More than one motor moving. (")
                                                          << n_moving_motors << "). Expected 1. Refusing to operate.";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        return OpcUa_BadInvalidArgument;
      }
      // all conditions are checked. Now start the operation
      // the status is set to sOperating and a separate thread is ran to process it
      // however, during this time, nothing else can be done with the system
      update_state(sOperating);
      init_segment_task(spos,lpos);
      // this is the poor mans equivalent of an async method
      // for now consider the task done
    }
    catch(json::exception &e)
    {
      reset(msg);
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      reset(msg);
      msg << log_e("stop","Caught runtime error : ") << e.what();
      got_exception = true;

    }
    catch(std::exception &e)
    {
      reset(msg);
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      reset(msg);
      msg << log_e("stop","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    else
    {
      reset(msg);
      msg << log_i("stop","Command successful.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }
  void DIoLaserSystem::init_segment_task(const std::vector<OpcUa_Int32>&  spos,
                                         const std::vector<OpcUa_Int32>&  lpos
  )
  {
    // this task runs on a separate thread
    // since there is no return to the user space
    // messages are queued in a separate variable that can then be queried
    // also keep in mind that at this stage all verifications have been performed, so
    // the task does not need base checks
    std::thread([this,spos,lpos]()
                {
      segment_task(spos,lpos);
      // once the task is done check if there is an error
      if (m_state == sError)
      {
        LOG(Log::ERR) << log_e("segment_task","Bugger. Segment failed.");
      }
      else
      {
        // we should update state back to sPause
        std::ostringstream msg("");
        reset(msg);
        if (!m_task_message_queue.contains("status"))
        {
          m_task_message_queue["status"] = "OK";
        }
        msg << log_e("fire_segment","Operation was successful.");
        m_task_message_queue["messages"].push_back(msg.str());
        if (!m_task_message_queue.contains("statuscode"))
        {
          m_task_message_queue["statuscode"] = OpcUa_Good;
        }
        update_state(sPause);
      }
                }
    ).detach();
  }
  void DIoLaserSystem::segment_task(const std::vector<OpcUa_Int32>&  spos,
                                    const std::vector<OpcUa_Int32>&  lpos
  )
  {
    UaStatus st;
    std::ostringstream msg("");
    json resp;
    //
    // ready to operate
    // -- be sure to set the shutter closed until destination is reached
    // the logic is the following
    // 0. Make sure that the laser is in Pause state
    // 1. Call each of the the motors to move to the starting position
    // 2. Set the target position for each motor
    // 3. Initiate movement
    // 4. call resume (switch to sLasing)
    // 5. Wait for motors to report end of travel
    // 6. switch back to pause
    // 7. Assess success
    //
    // step 0: before we even start doing anything
    // force the laser into a pause state
    st = iollaserunit()->pause(resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      msg << log_e("fire_segment","Failed to set laser into Pause state");;
      resp["messages"].push_back(msg.str());
      resp["status"] = "ERROR";
      resp["statuscode"] = static_cast<uint32_t>(st);
      m_task_message_queue = resp;
      // nothing is being done, so just terminate this task
      // update the state to error
      update_state(sError);
      return;
    }
    // step 1
    // we can initiate the movement
    st = move_motor(spos,resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      msg << log_e("fire_segment","Failed to move to start position");;
      resp["messages"].push_back(msg.str());
      resp["status"] = "ERROR";
      resp["statuscode"] = static_cast<uint32_t>(st);
      m_task_message_queue = resp;
      // nothing is being done, so just terminate this task
      // update the state to error
      update_state(sError);
      return;
    }
    // step 1.2: wait until motors are in place
    // since this is a separate task, we *must* wait for things to be ready
    bool is_moving = true;
    while (is_moving)
    {
      is_moving = false;
      for (Device::DIoLMotor* lmotor : iolmotors ())
      {
        is_moving |= lmotor->is_moving();
      }
      std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
    //
    //
    // we have reached the destination
    // step 2: set target position
    st = move_motor(lpos,resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      msg << log_e("fire_segment","Failed to iniiate movement to destination");;
      resp["messages"].push_back(msg.str());
      resp["status"] = "ERROR";
      resp["statuscode"] = static_cast<uint32_t>(st);
      m_task_message_queue = resp;
      // nothing is being done, so just terminate this task
      // update the state to error
      update_state(sError);
      return;
    }
    //
    // step 3: initiate movement (already done)
    //
    //
    // step 2.0 : start power meter readings
    for (Device::DIoLPowerMeter* lmeter : iolpowermeters())
    {
      st = lmeter->start_readings(resp);
    }

    // step 4: tell laser to get into business
    //
    st = iollaserunit()->resume(resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      resp["status"] = "ERROR";
      msg << log_e("fire_segment","Failed to activate laser. Check previous messages.");
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = static_cast<uint32_t>(st);
      // force a pause (again)
      iollaserunit()->pause(resp);
      m_task_message_queue = resp;
      update_state(sError);
      return;
    }
    // step 5: wait for motors to report stopped
    is_moving = true;
    while (is_moving)
    {
      is_moving = false;
      for (Device::DIoLMotor* lmotor : iolmotors ())
      {
        is_moving |= lmotor->is_moving();
      }
      std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
    // step 6: switch back to pause
    st = iollaserunit()->pause(resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      resp["status"] = "ERROR";
      msg << log_e("fire_segment","Failed to pase laser at the end. Check previous messages.");
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = static_cast<uint32_t>(st);
      // force a pause (again)
      iollaserunit()->pause(resp);
      m_task_message_queue = resp;
      update_state(sError);
      return;
    }
    // if it reached this stage, all is well and work is done
    for (Device::DIoLPowerMeter* lmeter : iolpowermeters())
    {
      st = lmeter->stop_readings(resp);
    }

  }


  UaStatus DIoLaserSystem::move_motor(
      const std::vector<OpcUa_Int32>&  position,
      json &resp)
  {
    std::ostringstream msg("");
    UaStatus st;

    for (std::vector<OpcUa_Int32>::size_type idx = 0; idx < position.size(); idx++)
    {
      Device::DIoLMotor* lmotor = iolmotors().at(m_map_motor_coordinates.at(idx));
      st = lmotor->move_wrapper(position.at(idx),resp);
      if (st != OpcUa_Good)
      {
        resp["status"] = "ERROR";
        reset(msg);
        msg << log_e("move_motor","Failed to set target position for motor (id : ")
                                                    << lmotor->get_id() << ").";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = static_cast<uint32_t>(st);
        // nothing is being done, so just terminate this task
        return st;
      }

    }
    //    for (std::vector<OpcUa_Int32>::size_type idx = 0; idx < position.size(); idx++)
    //    {
    //      // if we are configured, we already have a coordinate map
    //      for (Device::DIoLMotor* lmotor : iolmotors ())
    //      {
    //        if (lmotor->get_coordinate_index() == idx)
    //        {
    //          st = lmotor->set_position_setpoint(position.at(idx));
    //          if (st != OpcUa_Good)
    //          {
    //            resp["status"] = "ERROR";
    //            reset(msg);
    //            msg << log_e("move_motor","Failed to set target position for motor (id : ")
    //                                                << lmotor->get_id() << ").";
    //            resp["messages"].push_back(msg.str());
    //            resp["statuscode"] = static_cast<uint32_t>(st);
    //            // nothing is being done, so just terminate this task
    //            return st;
    //          }
    //          // now move the motor
    //          st = lmotor->move_motor(resp);
    //          if (st != OpcUa_Good)
    //          {
    //            resp["status"] = "ERROR";
    //            msg << log_e("move_motor","Failed to initiate motor movement on motor (id : ")
    //                                                << lmotor->get_id() << ").";
    //            resp["messages"].push_back(msg.str());
    //            resp["statuscode"] = static_cast<uint32_t>(st);
    //            return st;
    //          }
    //        }
    //      }
    //    }
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::execute_scan(json &plan, json &resp)
  {
    // this one is a hell of a tricky one
    // it is in many ways similar to fire segment, with a few caveats
    UaStatus st;
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // first check that the whole system is in a state that could be considered as valid
      // the tricky part here is that this definition depends on many things
      /**
       * For example, the laser can be considered ready if it is in sLasing, sReady or sStandby states
       * The motor is ready if it is not moving and has a speed defined
       * The power meter is always ready, as far as it is configured
       * The attenuator is always ready
       */
      if (!is_ready())
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("execute_scan","System is not ready to operate. Check the status of the various subsystems.");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }
      // step 0: Check if the laser is in a valid operating state
      // these are sLasing, sPause and sStandby
      // any other state requires extra stuff to operate
      if (!iollaserunit()->good_for_operation())
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("execute_scan","Laser is not in the right state.");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }
      if (!plan.contains("scan_plan"))
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("execute_scan","Malformed configuration fragment. Missing entry \"scan_plan\"");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidArgument;
      }
      if (!validate_scan_plan(plan,resp))
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("execute_scan","Invalid scan plan. Check previous messages.");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidArgument;
      }
      // all is good. Let's sell ketchup
      // the operation itself will run on a detached thread
      update_state(sOperating);
      init_scan_task(plan);
    }
    catch(json::exception &e)
    {
      reset(msg);
      msg << log_e("execute_scan","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      reset(msg);
      msg << log_e("execute_scan","Caught runtime error : ") << e.what();
      got_exception = true;

    }
    catch(std::exception &e)
    {
      reset(msg);
      msg << log_e("execute_scan","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      reset(msg);
      msg << log_e("execute_scan","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    else
    {
      reset(msg);
      msg << log_i("execute_scan","Command successful.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }

    return OpcUa_Good;
  }
  void DIoLaserSystem::init_scan_task(json &fragments)
  {
    // this task runs on a separate thread
    // since there is no return to the user space
    // messages are queued in a separate variable that can then be queried
    // also keep in mind that at this stage all verifications have been performed, so
    // the task does not need base checks
    std::thread([this,fragments]()
                {
      UaStatus st;
      std::ostringstream msg("");
      json resp;
      //
      // ready to operate
      // -- be sure to set the shutter is closed in all interim moments
      // the logic is the following
      // Operation sequence
      //
      // 0. Make sure that the laser is in Pause state
      // 1. grab the first segment [start : end]
      // 2. call fire_segment
      // 3. move to beginning of next segment
      // 5. repeat

      // 1. Call each of the the motors to move to the starting position
      // 2. Set the target position for each motor
      // 3. Initiate movement
      // 4. call resume (switch to sLasing)
      // 5. Wait for motors to report end of travel
      // 6. switch back to pause
      // 7. Assess success
      //
      // step 0: before we even start doing anything
      // force the laser into a pause state
      st = iollaserunit()->pause(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        msg << log_e("scan_task","Failed to set laser into Pause state");;
        if (!m_task_message_queue.contains("status"))
        {
          m_task_message_queue["status"] = "ERROR";
        }
        m_task_message_queue["messages"].push_back(msg.str());
        if (!m_task_message_queue.contains("statuscode"))
        {
          m_task_message_queue["statuscode"] = static_cast<uint32_t>(st);
        }
        // nothing is being done, so just terminate this task
        // update the state to error
        update_state(sError);
        return;
      }
      int i = 0;
      // 1. grab segment
      for (auto item: fragments.at("scan_plan"))
      {
        std::vector<int32_t> spos = item.at("start");
        std::vector<int32_t> epos = item.at("end");
        // we have the positions. So all we need is to move the segment
        segment_task(spos,epos);
        if (m_state == sError)
        {
          // the task failed
          // switch to pause and return
          reset(msg);
          msg << log_e("scan_task","Segment failed to process. Entry ") << i;
          if (!m_task_message_queue.contains("status"))
          {
            m_task_message_queue["status"] = "ERROR";
          }
          m_task_message_queue["messages"].push_back(msg.str());
          if (!m_task_message_queue.contains("statuscode"))
          {
            m_task_message_queue["statuscode"] = OpcUa_Bad;
          }
          return;
        }
        // increment entry
        i++;
      }
      // If we reached this stage, the scan seems to have completed
      // tell the laser to pause
      st = iollaserunit()->pause(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        msg << log_e("scan_task","Failed to pause laser at the end. Check previous messages.");
        if (!m_task_message_queue.contains("status"))
        {
          m_task_message_queue["status"] = "ERROR";
        }
        m_task_message_queue["messages"].push_back(msg.str());
        if (!m_task_message_queue.contains("statuscode"))
        {
          m_task_message_queue["statuscode"] = OpcUa_Bad;
        }
        update_state(sError);
        return;
      }
      // if it reached this stage, all is well and we should update the state back to
      // sPause
      pause(m_task_message_queue);
      reset(msg);
      msg << log_i("scan_task","Operation was successful.");
      if (!m_task_message_queue.contains("status"))
      {
        m_task_message_queue["status"] = "OK";
      }
      m_task_message_queue["messages"].push_back(msg.str());
      if (!m_task_message_queue.contains("statuscode"))
      {
        m_task_message_queue["statuscode"] = OpcUa_Good;
      }
      update_state(sPause);
                }
    ).detach();
  }
  UaStatus DIoLaserSystem::pause(json &resp)
  {
    // this is largely aimed at the laser
    UaStatus st;
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // first check that the whole system is in a state that could be considered as valid
      // the tricky part here is that this definition depends on many things
      /**
       * For example, the laser can be considered ready if it is in sLasing, sReady or sStandby states
       * The motor is ready if it is not moving and has a speed defined
       * The power meter is always ready, as far as it is configured
       * The attenuator is always ready
       */
      if (m_state == sOffline)
      {
        // system is not even configured. Nothing to be done
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("pause","System is not ready to operate. Check the status of the various subsystems.");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }
      st= iollaserunit()->pause(resp);
      //FIXME: Should we also tell the motors to stop?
      if (st != OpcUa_Good)
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("pause","Laser failed to pause. Check previous messages.");
        resp["messages"].push_back(msg.str());
        if (!m_task_message_queue.contains("statuscode"))
        {
          m_task_message_queue["statuscode"] = OpcUa_Good;
        }
        return OpcUa_BadInvalidState;
      }
      update_state(sPause);
    }
    catch(json::exception &e)
    {
      reset(msg);
      msg << log_e("pause","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      reset(msg);
      msg << log_e("pause","Caught runtime error : ") << e.what();
      got_exception = true;

    }
    catch(std::exception &e)
    {
      reset(msg);
      msg << log_e("pause","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      reset(msg);
      msg << log_e("pause","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    else
    {
      reset(msg);
      msg << log_i("pause","Command successful.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::standby(json &resp)
  {
    // this is largely aimed at the laser
    UaStatus st;
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // first check that the whole system is in a state that could be considered as valid
      // the tricky part here is that this definition depends on many things
      /**
       * For example, the laser can be considered ready if it is in sLasing, sReady or sStandby states
       * The motor is ready if it is not moving and has a speed defined
       * The power meter is always ready, as far as it is configured
       * The attenuator is always ready
       */
      if (m_state == sOffline)
      {
        // system is not even configured. Nothing to be done
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("standby","System is not ready to operate. Check the status of the various subsystems.");
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidState;
        LOG(Log::ERR) << msg.str();
        return OpcUa_BadInvalidState;
      }
      st= iollaserunit()->standby(resp);
      //FIXME: Should we also tell the motors to stop?
      if (st != OpcUa_Good)
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("standby","Laser failed to pause. Check previous messages.");
        resp["messages"].push_back(msg.str());
        if (!m_task_message_queue.contains("statuscode"))
        {
          m_task_message_queue["statuscode"] = OpcUa_Good;
        }
        return OpcUa_BadInvalidState;
      }
      update_state(sStandby);
    }
    catch(json::exception &e)
    {
      reset(msg);
      msg << log_e("standby","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      reset(msg);
      msg << log_e("standby","Caught runtime error : ") << e.what();
      got_exception = true;

    }
    catch(std::exception &e)
    {
      reset(msg);
      msg << log_e("standby","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      reset(msg);
      msg << log_e("standby","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    else
    {
      reset(msg);
      msg << log_i("standby","Command successful.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::resume(json &resp)
  {
    // this is largely aimed at the laser
    UaStatus st;
    std::ostringstream msg("");

    // once again, this is primarily aimed at the laser
    // also, make sure to activate the
    if ((m_state != sPause) and (m_state != sStandby))
    {
      // system is not even configured. Nothing to be done
      reset(msg);
      resp["status"] = "ERROR";
      msg << log_e("resume","System is neither in sPause or sStandby. Current state :") << m_state_map.at(m_state);
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      LOG(Log::ERR) << msg.str();
      return OpcUa_BadInvalidState;

    }
    st= iollaserunit()->resume(resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      resp["status"] = "ERROR";
      msg << log_e("resume","Laser failed to resume. Check previous messages.");
      resp["messages"].push_back(msg.str());
      if (!m_task_message_queue.contains("statuscode"))
      {
        m_task_message_queue["statuscode"] = OpcUa_Bad;
      }
      return OpcUa_Bad;
    }
    update_state(sOperating);
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::warmup(json &resp)
  {
    // warmup is a special command. This is the command that initiates the laser itself
    // the best way is to check whether the laser itself is firing already
    std::ostringstream msg("");
    UaStatus st;
    if (iollaserunit()->get_state() != DIoLLaserUnit::sReady)
    {
      // system is not even configured. Nothing to be done
      reset(msg);
      resp["status"] = "ERROR";
      msg << log_e("warmup","Laser system is not in ready state, as it should.");
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
    }
    st = iollaserunit()->start_cib(resp);
    if (st != OpcUa_Good)
    {
      reset(msg);
      resp["status"] = "ERROR";
      msg << log_e("warmup","Laser system failed to start. Check previous messages.");
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    // confirm that the laser is in warmup state
    if (iollaserunit()->get_state() != DIoLLaserUnit::sWarmup)
    {
      reset(msg);
      resp["status"] = "ERROR";
      msg << log_e("warmup","Laser system not in expected sWarmup state. Got ") << iollaserunit()->get_state()
                  << " (expected " << DIoLLaserUnit::sWarmup << ")";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return OpcUa_Bad;
    }
    // if it reached this point, we are now in warmup state.
    // update the local state
    // during this time, no laser related commands are accepted
    update_state(sWarmup);
    return OpcUa_Good;
  }
  UaStatus DIoLaserSystem::shutdown(json &resp)
  {
    // shutdown is meant to close all connectivity, leaving the system in a completely clean state
    UaStatus st;
    std::ostringstream msg("");
    st = iollaserunit()->terminate(resp);
    bool trouble = false;
    if (st != OpcUa_Good)
    {
      reset(msg);
      resp["status"] = "ERROR";
      msg << log_e("shutdown","Something weird happened with the laser unit.");
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = static_cast<uint32_t>(st);
      trouble = true;
      // do not return
      // the terminate should propagate everywhere
    }
    // call update over all daughters
    for (Device::DIoLMotor* lmotor : iolmotors ())
    {
      st = lmotor->terminate(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("shutdown","Motor ") << lmotor->get_id() << " didn't terminate cleanly. Please check.";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = static_cast<uint32_t>(st);
        trouble = true;
      }
    }
    for (Device::DIoLAttenuator* latt : iolattenuators ())
    {
      st = latt->terminate(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("shutdown","Attenuator ") << latt->get_id() << " didn't terminate cleanly. Please check.";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = static_cast<uint32_t>(st);
        trouble = true;
      }
    }
    for (Device::DIoLPowerMeter* lmeter : iolpowermeters())
    {
      st = lmeter->terminate(resp);
      if (st != OpcUa_Good)
      {
        reset(msg);
        resp["status"] = "ERROR";
        msg << log_e("shutdown","Attenuator ") << lmeter->get_id() << " didn't terminate cleanly. Please check.";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = static_cast<uint32_t>(st);
        trouble = true;
      }
    }
    // CIB never terminates. It lives forever...
    //    for (Device::DIoLCIB* lcib : iolcibs())
    //    {
    //      st = lcib->terminate(resp);
    //      if (st != OpcUa_Good)
    //      {
    //        reset(msg);
    //        resp["status"] = "ERROR";
    //        msg << log_e("shutdown","CIB ") << lcib->get_id() << " didn't terminate cleanly. Please check.";
    //        resp["messages"].push_back(msg.str());
    //        resp["statuscode"] = static_cast<uint32_t>(st);
    //        trouble = true;
    //      }
    //    }
    if (trouble)
    {
      return OpcUa_Uncertain;
    }
    else
    {
      return OpcUa_Good;
    }
  }

  UaStatus DIoLaserSystem::move_to_pos(
      const std::vector<OpcUa_Int32>&  position,const std::string approach, json &resp)
  {
    const std::string lbl = "move_to_pos";
    const uint32_t overstep = 200;
    std::ostringstream msg("");
    UaStatus st = OpcUa_Good;
    // bool error_moving = false;
    // before we do anything check the valid approaches
    bool failed_validation = false;
    if ((position.size() != 3) || (approach.size()!= 3))
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Arguments do not have the right size. Both should have dimension 3. ")
          << "Got pos " << position.size() << " approach " << approach.size() << " : " << approach;
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      return OpcUa_BadInvalidArgument;
    }
    for (size_t idx = 0; idx < approach.size(); idx++)
    {
      switch (approach.at(idx))
      {
        case 'u':
        case 'd':
        case '-':
          break;
        default:
          msg.clear(); msg.str("");
          msg << log_e("move_to_pos","Failed to validate the approach options ")
              << " for entry " << idx << ". Should be one of ('u', 'd','-')";
          resp["messages"].push_back(msg.str());
          failed_validation = true;
          break;
      }
    }
    if (failed_validation)
    {
      resp["status"] = "ERROR";
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return OpcUa_BadInvalidArgument;
    }
    // -- Validations passed. Starting the work
    for (std::vector<OpcUa_Int32>::size_type idx = 0; idx < position.size(); idx++)
    {
      // get the motor that is responsible for this coordinate
      Device::DIoLMotor* lmotor = iolmotors().at(m_map_motor_coordinates.at(idx));
      // get its current position
      int32_t c_pos;
      st = lmotor->get_position_motor(c_pos,resp);
      if (st != OpcUa_Good)
      {
        // failed to query the motor. Fail here as well
        return st;
      }
      // we have the current position, decide whether the approach is good or requires some overstepping
      if (c_pos < position.at(idx))
      {
        // current position is "below" the target, only 'u' requires overstepping
        if (approach.at(idx) == 'u')
        {
          int32_t interim_target = position.at(idx) + overstep;
          st = lmotor->move_wrapper(interim_target,resp);
          if (st != OpcUa_Good)
          {
            resp["status"] = "ERROR";
            reset(msg);
            msg << log_e("move_motor","Failed to set target position for motor (id : ")
                                                        << lmotor->get_id() << ").";
            resp["messages"].push_back(msg.str());
            resp["statuscode"] = static_cast<uint32_t>(st);
            // nothing is being done, so just terminate this task
            return st;
          }
        }
        // now we can move to the *real* target position
      }
      else if (c_pos > position.at(idx))
      {
        // we are above. If approach is 'd', we have to overstep
        // current position is "below" the target, only 'u' requires overstepping
        if (approach.at(idx) == 'd')
        {
          int32_t interim_target = position.at(idx) - overstep;
          st = lmotor->move_wrapper(interim_target,resp);
          if (st != OpcUa_Good)
          {
            resp["status"] = "ERROR";
            reset(msg);
            msg << log_e("move_motor","Failed to set target position for motor (id : ")
                                                        << lmotor->get_id() << ").";
            resp["messages"].push_back(msg.str());
            resp["statuscode"] = static_cast<uint32_t>(st);
            // nothing is being done, so just terminate this task
            return st;
          }
        }
      }
      // if we reached this point, we are ready to go to the *real* target position
      st = lmotor->move_wrapper(position.at(idx),resp);
      if (st != OpcUa_Good)
      {
        resp["status"] = "ERROR";
        reset(msg);
        msg << log_e("move_motor","Failed to set target position for motor (id : ")
                                                    << lmotor->get_id() << ").";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = static_cast<uint32_t>(st);
        // nothing is being done, so just terminate this task
        return st;
      }
    }
    // nothin failed so far...we should be where we want.

    // don't implement this yet
    return OpcUa_Good;
  }
  bool DIoLaserSystem::validate_config_fragment(json &frag, json &resp)
  {
    // check that a series of parameters are set
    // also check that this fragment has the ID that is corresponding to this specific laser system
    // this is just a validation check for the available keys.
    // it will only check the mandatory keys.
    std::ostringstream msg("");
    std::vector<std::string> keys = {"id","motors","attenuator","laser",
        "power_meter", "cib"
    };
    if (!frag.contains("id"))
    {
      reset(msg);
      msg << log_e("validate_config","Configuration fragment missing system ID");
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return false;
    }
    if (frag.at("id").get<std::string>() != id())
    {
      reset(msg);
      msg << log_e("validate_config","Configuration fragment has a mismatched ID. Expected ") << id();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return false;
    }
    // actually, check for all entries and report all missing ones
    std::vector<std::string> missing;
    for (auto entry: keys)
    {
      if (!frag.contains(entry))
      {
        missing.push_back(entry);
      }
    }
    if (missing.size() > 0)
    {
      msg.clear(); msg.str("");
      msg << log_e("validate_config","Missing entries in IoLS config fragment [");
      for (auto e : missing)
      {
        msg << "(" <<  e << "),";
      }
      msg << "]";
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return false;
    }
    // all good, return true
    return true;
  }
  void DIoLaserSystem::update()
  {
    // first update the local variables
    update_state(m_state);



    // call update over all daughters
    for (Device::DIoLLaserUnit* lunit : iollaserunits())
    {
      lunit->update();
    }
    for (Device::DIoLMotor* lmotor : iolmotors ())
    {
      lmotor->update();
    }
    for (Device::DIoLAttenuator* latt : iolattenuators ())
    {
      latt->update();
    }
    for (Device::DIoLPowerMeter* lmeter : iolpowermeters())
    {
      lmeter->update();
    }
    for (Device::DIoLCIB* lcib : iolcibs())
    {
      lcib->update();
    }
  }
  bool DIoLaserSystem::is_ready()
  {
    for (Device::DIoLLaserUnit* lunit : iollaserunits())
    {
      if (!lunit->is_ready())
      {
        return false;
      }
    }
    for (Device::DIoLMotor* lmotor : iolmotors ())
    {
      if (!lmotor->is_ready())
      {
        return false;
      }
    }
    for (Device::DIoLAttenuator* latt : iolattenuators ())
    {
      if (!latt->is_ready())
      {
        return false;
      }
    }
    for (Device::DIoLPowerMeter* lmeter : iolpowermeters())
    {
      if (!lmeter->is_ready())
      {
        return false;
      }
    }
    for (Device::DIoLCIB* lcib : iolcibs())
    {
      if (!lcib->is_ready())
      {
        return false;
      }
    }
    return true;
  }
  void DIoLaserSystem::reset(std::ostringstream &s)
  {
    s.clear();
    s.str("");
  }
  void DIoLaserSystem::update_state(State s)
  {
    m_state = s;
    UaString ss(m_state_map.at(m_state).c_str());
    getAddressSpaceLink()->setState(ss,OpcUa_Good);
  }
  void DIoLaserSystem::get_message_queue(json &resp, bool clear)
  {
    resp = m_task_message_queue;
    if (clear)
    {
      m_task_message_queue.clear();
    }
  }
  bool DIoLaserSystem::validate_scan_plan(json &plan, json &resp)
  {
    std::ostringstream msg("");
    bool got_exception = false;
    try
    {
      // the structure for a scan plan is rather simple
      // it is basically just an array of tuples, but we also need to check that the tuples themselves make sense
      // since we do not want things to go belly up halfway through the scan
      // Things to check for:
      // 1. the structure is correct
      // 2. The positions have the appropriate number of entries
      // 3. Each position remains within the range of the corresponding motor
      // step one. Check that the "scan_plan" key exists and that the corresponding entry can be cast into a vector
      // containing a "start" and "end" structure
      if (!plan.contains("scan_plan"))
      {
        reset(msg);
        msg << log_e("validate_scan_plan","Missing \"scan_plan\" key.");
        resp["status"] = "ERROR";
        resp["messages"].push_back(msg.str());
        resp["statuscode"] = OpcUa_BadInvalidArgument;
        return false;
      }
      std::vector<std::string> entries = {"start","end"};
      for (auto item: plan.at("scan_plan"))
      {
        for (auto entry : entries)
        {
          if (!item.contains(entry))
          {
            reset(msg);
            msg << log_e("validate_scan_plan","Missing key ") << entry << " in segment " << item.dump();
            resp["status"] = "ERROR";
            resp["messages"].push_back(msg.str());
            resp["statuscode"] = OpcUa_BadInvalidArgument;
            return false;
          }
          // 2. check entries for positions
          std::vector<int32_t> v = item.at(entry);
          if (v.size() != iolmotors().size())
          {
            reset(msg);
            msg << log_e("validate_scan_plan","Wrong number of coordinates in key ")
                            << entry << " of segment " << item.dump() << ". Expected " << iolmotors().size();
            resp["status"] = "ERROR";
            resp["messages"].push_back(msg.str());
            resp["statuscode"] = OpcUa_BadInvalidArgument;
            return false;
          }
          // 3. check each coordinate to be in range
          for (size_t i = 0; i < v.size(); i++)
          {
            if (!iolmotors().at(m_map_motor_coordinates.at(i))->is_in_range(v.at(i)))
            {
              reset(msg);
              msg << log_e("validate_scan_plan","Coordinate out of range.")
                             << " Entry " << i << " position " << entry << " of segment " << item.dump()
                             << ". Range: [" << iolmotors().at(m_map_motor_coordinates.at(i))->get_range_min()
                             << ", " << iolmotors().at(m_map_motor_coordinates.at(i))->get_range_max() << "]";
              resp["status"] = "ERROR";
              resp["messages"].push_back(msg.str());
              resp["statuscode"] = OpcUa_BadInvalidArgument;
              return false;
            }
          }
        }
      }
      // if we reached this stage, all it good
    }
    catch(json::exception &e)
    {
      reset(msg);
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::runtime_error &e)
    {
      reset(msg);
      msg << log_e("stop","Caught runtime error : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      reset(msg);
      msg << log_e("stop","Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      reset(msg);
      msg << log_e("stop","Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Bad;
      return false;
    }
    else
    {
      reset(msg);
      msg << log_i("validate_scan_plan","Configuration validated.");
      resp["status"] = "OK";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_Good;
    }
    return true;
  }


}
