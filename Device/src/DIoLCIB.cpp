
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.

    The stub of this file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.


 */


#include <Configuration.hxx> // TODO; should go away, is already in Base class for ages

#include <DIoLCIB.h>
#include <ASIoLCIB.h>
extern "C"
{
#include <sys/types.h>
#include <sys/sysinfo.h>
};
#include <cstdint>
#include <cinttypes>
#include <cstdio>
#include <cib_mem.h>
#include <mem_utils.h>
#include <json.hpp>
using json = nlohmann::json;

#define log_msg(s,met,msg) "[" << s << "]::" << met << " : " << msg

#define log_e(m,s) log_msg("ERROR",m,s)
#define log_w(m,s) log_msg("WARN",m,s)
#define log_i(m,s) log_msg("INFO",m,s)

#define DEBUG 1
using std::ostringstream;

namespace Device
{
  // 1111111111111111111111111111111111111111111111111111111111111111111111111
  // 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
  // 1     Users don't modify this code!!!!                                  1
  // 1     If you modify this code you may start a fire or a flood somewhere,1
  // 1     and some human being may possible cease to exist. You don't want  1
  // 1     to be charged with that!                                          1
  // 1111111111111111111111111111111111111111111111111111111111111111111111111






  // 2222222222222222222222222222222222222222222222222222222222222222222222222
  // 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
  // 2     (code for which only stubs were generated automatically)          2
  // 2     You should add the implementation but dont alter the headers      2
  // 2     (apart from constructor, in which you should complete initializati2
  // 2     on list)                                                          2
  // 2222222222222222222222222222222222222222222222222222222222222222222222222

  /* sample ctr */
  DIoLCIB::DIoLCIB (
      const Configuration::IoLCIB& config,
      Parent_DIoLCIB* parent
  ):
        Base_DIoLCIB( config, parent)

        /* fill up constructor initialization list here */
        , m_is_ready(false)
        , m_cpu_load(0.0)
        , m_used_mem(0.0)
        , m_prev_tot_usr(0)
        , m_prev_tot_usr_low(0)
        , m_prev_tot_sys(0)
        , m_prev_tot_idle(0)
        , m_total(0)
        ,m_mmap_fd(0)
        {
    /* fill up constructor body here */
    m_id = id();
    // start by initializing the initial counters
    FILE* file = fopen("/proc/stat", "r");
    int ret = fscanf(file, "cpu %llu %llu %llu %llu", &m_prev_tot_usr, &m_prev_tot_usr_low,&m_prev_tot_sys, &m_prev_tot_idle);
    ret = fclose(file);
    (void)ret; // this is just to suppress the compilation warning
    // initialize the CIB memory maps
    UaStatus st = init_cib_mem();
    if (st != OpcUa_Good)
    {
      LOG(Log::ERR) << log_e("constructor","Failed to map CIB memory. This is definitely not good.");
    }
        }

  /* sample dtr */
  DIoLCIB::~DIoLCIB ()
  {
  }

  /* delegates for cachevariables */

  /* Note: never directly call this function. */

  UaStatus DIoLCIB::writeDac_threshold ( const OpcUa_UInt16& v)
  {
    json resp;
    uint16_t val = v;
    UaStatus st = set_dac_threshold(val,resp);
    return st;
  }


  /* delegators for methods */
  UaStatus DIoLCIB::callSet_dac_threshold (
      OpcUa_UInt16 dac_level,
      UaString& response
  )
  {
    json resp;
    UaStatus st = set_dac_threshold(dac_level,resp);
    response = UaString(resp.dump().c_str());
    return st;
  }
  UaStatus DIoLCIB::callReset_pdts (
      UaString& response
  )
  {
    return OpcUa_BadNotImplemented;
  }
  UaStatus DIoLCIB::callSet_trigger_pulser (
      OpcUa_Boolean enabled,
      UaString& response
  )
  {
    return OpcUa_BadNotImplemented;
  }
  UaStatus DIoLCIB::callSet_trigger_external (
      OpcUa_Boolean enabled,
      UaString& response
  )
  {
    return OpcUa_BadNotImplemented;
  }
  UaStatus DIoLCIB::callSet_lbls_width (
      OpcUa_UInt32 width,
      UaString& response
  )
  {
    return OpcUa_BadNotImplemented;
  }
  UaStatus DIoLCIB::callSet_lbls_state (
      OpcUa_Boolean enabled,
      UaString& response
  )
  {
    return OpcUa_BadNotImplemented;
  }
  UaStatus DIoLCIB::callSet_align_state (
      OpcUa_Boolean enabled,
      UaString& response
  )
  {
    return OpcUa_BadNotImplemented;
  }
  UaStatus DIoLCIB::callSet_align_params (
      OpcUa_UInt32 width_clocks,
      OpcUa_UInt32 period_clocks,
      UaString& response
  )
  {
    return OpcUa_BadNotImplemented;
  }

  // 3333333333333333333333333333333333333333333333333333333333333333333333333
  // 3     FULLY CUSTOM CODE STARTS HERE                                     3
  // 3     Below you put bodies for custom methods defined for this class.   3
  // 3     You can do whatever you want, but please be decent.               3
  // 3333333333333333333333333333333333333333333333333333333333333333333333333

  UaStatus DIoLCIB::init_cib_mem()
  {
    // -- there may be several registers to be mapped
    cib_gpio_t tmpreg;
    tmpreg.id = PDTS_REG;
    tmpreg.paddr = GPIO_PDTS_MEM_LOW;
    tmpreg.size = 0xFFF;
    tmpreg.vaddr = cib::util::map_phys_mem(m_mmap_fd,GPIO_PDTS_MEM_LOW,GPIO_PDTS_MEM_HIGH);
    if (tmpreg.vaddr == 0x0)
    {
      LOG(Log::ERR) << "\n\nDIoLLaserUnit::DIoLLaserUnit : Failed to map PDTS CIB memory region. This is going to fail spectacularly!!!\n\n";
    }
    m_reg_map.insert(std::pair<int,cib_gpio_t>(tmpreg.id,tmpreg));
#ifdef DEBUG
    LOG(Log::INF) << "\n\nDIoLLaserUnit::DIoLLaserUnit : PDTS_REG mapped to "
        << std::hex << m_reg_map.at(PDTS_REG).vaddr << std::dec;
#endif
    tmpreg.id= MISC_REG;
    tmpreg.paddr = GPIO_MISC_MEM_LOW;
    tmpreg.size = 0xFFF;
    tmpreg.vaddr = cib::util::map_phys_mem(m_mmap_fd,GPIO_MISC_MEM_LOW,GPIO_MISC_MEM_HIGH);
    if (tmpreg.vaddr == 0x0)
    {
      LOG(Log::ERR) << "\n\nDIoLLaserUnit::DIoLLaserUnit : Failed to map MISC CIB memory region. This is going to fail spectacularly!!!\n\n";
    }
    m_reg_map.insert(std::pair<int,cib_gpio_t>(tmpreg.id,tmpreg));
#ifdef DEBUG
    LOG(Log::INF) << "\n\nDIoLLaserUnit::DIoLLaserUnit : MISC_REG mapped to " << std::hex << m_reg_map.at(MISC_REG).vaddr << std::dec;
#endif
    tmpreg.id= ALIGN_REG;
    tmpreg.paddr = GPIO_ALIGN_MEM_LOW;
    tmpreg.size = 0xFFF;
    tmpreg.vaddr = cib::util::map_phys_mem(m_mmap_fd,GPIO_ALIGN_MEM_LOW,GPIO_ALIGN_MEM_HIGH);
    if (tmpreg.vaddr == 0x0)
    {
      LOG(Log::ERR) << "\n\nDIoLLaserUnit::DIoLLaserUnit : Failed to map ALIGN CIB memory region. This is going to fail spectacularly!!!\n\n";
    }
    m_reg_map.insert(std::pair<int,cib_gpio_t>(tmpreg.id,tmpreg));
#ifdef DEBUG
    LOG(Log::INF) << "\n\nDIoLLaserUnit::DIoLLaserUnit : ALIGN_REG mapped to " << std::hex << m_reg_map.at(ALIGN_REG).vaddr << std::dec;
#endif

    //#endif

    if (m_reg_map.size() != 3)
    {
      // sError is a special case of status, since this
      LOG(Log::ERR) << "\n\nDIoLLaserUnit::DIoLLaserUnit : Failed to map one or more CIB memory regions. This is going to fail spectacularly!!!\n\n";
    }
    return OpcUa_Good;
  }
  //
  void DIoLCIB::poll_mem()
  {
    struct sysinfo memInfo;
    sysinfo (&memInfo);
    // unit size in bytes
    uint64_t total = memInfo.totalram*memInfo.mem_unit/(1024*1024);
    uint64_t free  = memInfo.freeram*memInfo.mem_unit/(1024*1024);
    m_used_mem = static_cast<float>(total-free)/static_cast<float>(total);
    getAddressSpaceLink()->setMem_load(m_used_mem,OpcUa_Good);
  }
  //
  void DIoLCIB::poll_cpu()
  {
    unsigned long long tot_usr, tot_usr_low, tot_sys, tot_idle;
    FILE* file = fopen("/proc/stat", "r");
    int ret = fscanf(file, "cpu %llu %llu %llu %llu", &tot_usr, &tot_usr_low,&tot_sys, &tot_idle);
    ret = fclose(file);
    (void)ret; // this is just to suppress the compilation warning

    if ((tot_usr < m_prev_tot_usr) ||
        (tot_usr_low < m_prev_tot_usr_low) ||
        (tot_sys < m_prev_tot_sys) ||
        (tot_idle < m_prev_tot_idle))
    {
      //Overflow detection. Just skip this value.
      m_cpu_load = -1.0;
      getAddressSpaceLink()->setCpu_load(m_cpu_load,OpcUa_Uncertain);
    }
    else
    {
      m_total = (tot_usr - m_prev_tot_usr) +
          (tot_usr_low - m_prev_tot_usr_low) +
          (tot_sys - m_prev_tot_sys);
      m_cpu_load = static_cast<float>(static_cast<double>(m_total)/static_cast<double>((m_total + (tot_idle-m_prev_tot_idle))));
      getAddressSpaceLink()->setCpu_load(m_cpu_load,OpcUa_Good);
    }
    // update the previous to repoll
    m_prev_tot_usr = tot_usr;
    m_prev_tot_usr_low = tot_usr_low;
    m_prev_tot_sys = tot_sys;
    m_prev_tot_idle = tot_idle;
  }

  void DIoLCIB::update()
  {
    // refresh the other two
    poll_mem();
    poll_cpu();
    // update the reading of the DAC
    refresh_dac();
    refresh_pdts();
    refresh_registers();
  }
  UaStatus DIoLCIB::set_dac_threshold(uint16_t &val,json &resp)
  {
    std::ostringstream msg("");
    bool got_exception = false;
    json jresp;
    UaStatus st;
    const std::string lbl = "set_dac_threshold";
    int ret;
    try
    {
      // first do some quality checks
      // the DAC only goes to 4095 (0xFFF)
      if (val > 0xFFF)
      {
        msg.clear(); msg.str("");
        msg << log_e(lbl.c_str(),"Value beyond allowed limits [0,4095]");
        jresp["status"] = "ERROR";
        jresp["messages"].push_back(msg.str());
        jresp["statuscode"] = OpcUa_BadInvalidArgument;
      }
      else if (!m_dac.is_open())
      {
        msg.clear(); msg.str("");
        msg << log_e(lbl.c_str(),"Failed to communicate with the DAC");
        jresp["status"] = "ERROR";
        jresp["messages"].push_back(msg.str());
        jresp["statuscode"] = OpcUa_BadInvalidState;
      }
      else // all is good
      {
        ret = m_dac.set_level(1,val);
        if (ret)
        {
          msg.clear(); msg.str("");
          msg << log_e(lbl.c_str(),"Failed to set DAC threshold");
          jresp["status"] = "ERROR";
          jresp["messages"].push_back(msg.str());
          jresp["statuscode"] = OpcUa_BadCommunicationError;
        }
        else
        {
          // read it back again to confirm we have the result
          uint16_t readback;
          ret = m_dac.get_level(1,readback);
          if (ret)
          {
            msg.clear(); msg.str("");
            msg << log_e(lbl.c_str(),"Failed to get DAC threshold readback");
            jresp["status"] = "ERROR";
            jresp["messages"].push_back(msg.str());
            jresp["statuscode"] = OpcUa_BadCommunicationError;
          }
          else
          {
            if (readback != val)
            {
              msg.clear(); msg.str("");
              msg << log_e(lbl.c_str(),"Failed to get correct DAC threshold readback. Set ") << val << " readback  " << readback;
              jresp["status"] = "ERROR";
              jresp["messages"].push_back(msg.str());
              jresp["statuscode"] = OpcUa_Bad;
            }
            else
            {
              jresp["messages"].push_back("DAC set successfully");
            }
          }
        }
      }
    }
    catch(json::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(std::exception &e)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught JSON exception : ") << e.what();
      got_exception = true;
    }
    catch(...)
    {
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Caught an unknown exception");
      got_exception = true;
    }
    if (got_exception)
    {
      jresp["status"] = "ERROR";
      jresp["messages"].push_back(msg.str());
      jresp["statuscode"] = OpcUa_Bad;
    }
    // why was this commented?
    if (!jresp.contains("status"))
    {
      jresp["status"] = "SUCCESS";
      jresp["statuscode"] = OpcUa_Good;
    }
    //resp = UaString(jresp.dump().c_str());
    resp = jresp;
    return OpcUa_Good;
  }
  void DIoLCIB::refresh_dac()
  {
    static bool first = true;
    int ret = 0;
    uint16_t v;
    AddressSpace::ASIoLCIB* as = getAddressSpaceLink();
    if (!m_dac.is_open())
    {
      if(first)
      {
        LOG(Log::INF) << "NFB: Opening the connection to the DAC";
        first = false;
      }
      ret = init_dac();
    }
    // the DAC failed to initialize. No point in getting the level
    if (!ret)
    {
      ret = m_dac.get_level(1,v);
    }
    if (ret)
    {
      as->setDac_threshold(v,OpcUa_BadDataUnavailable);
    }
    else
    {
      as->setDac_threshold(v,OpcUa_Good);
    }
  }
  int DIoLCIB::init_dac()
  {
    int res;
    static bool first = true;

    res = m_dac.set_bus(7);
    if (res != CIB_I2C_OK)
    {
      if (first)
      {
        LOG(Log::ERR) << "NFB: Failed to set DAC bus number. Returned " << res << " : " << cib::i2c::strerror(res);
        first = false;
      }
      return res;
    }
    res = m_dac.set_dev_number(0xd);
    if (res != CIB_I2C_OK)
    {
      if (first)
      {
        LOG(Log::ERR) << "NFB: Failed to set dev number. Returned " << res << " : " << cib::i2c::strerror(res);
        first = false;
      }
      return res;
    }
    res = m_dac.open_device();
    if (res != CIB_I2C_OK)
    {
      if (first)
      {
        LOG(Log::ERR) << "NFB: Failed to open device. Returned  " << res << " : " << cib::i2c::strerror(res);
        first = false;
      }
      return res;
    }
    // actually, should take the opportunity and set a high level
    // this is to avoid spurious triggers at initialization

    res = m_dac.set_level(1,4095);
    return res;
  }
  UaStatus DIoLCIB::check_cib_mem(json &resp)
  {
    const std::string lbl = "check_cib";
    if (m_reg_map.size() == 0x0)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"CIB memory not mapped. System on lockdown.");
      LOG(Log::ERR) << msg.str();
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidState;
      return OpcUa_BadInvalidState;
    }
    else
    {
      return OpcUa_Good;
    }
  }
  UaStatus DIoLCIB::validate_registers(json &conf,json &resp)
  {
    const std::string lbl = "validate_registers";
    std::vector<std::string> mandatory_keys = {
        "pdts_status","pdts_reset","trigger_pulser","trigger_external",
        "daq_queue_state","lbls_queue_state","lbls_width","align_width",
        "align_period","align_state"
    };
    //
    // actually, check for all entries and report all missing ones
    std::vector<std::string> missing;
    //
    for (auto entry: mandatory_keys)
    {
      if (!conf.contains(entry))
      {
        missing.push_back(entry);
      }
    }
    if (missing.size() > 0)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Missing mandatory entries in CIB mmap config fragment [");
      for (auto e : missing)
      {
        msg << "(" <<  e << "),";
      }
      msg << "]";
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return OpcUa_BadInvalidArgument;
    }
    //
    missing.clear();
    // all good, return true
    return OpcUa_Good;
  }

  UaStatus DIoLCIB::map_registers(json &conf,json &resp)
  {
    UaStatus st = validate_registers(conf,resp);
    if (st != OpcUa_Good)
    {
      return OpcUa_BadInvalidArgument;
    }
    // this method is specific for each device
    // -- first obtain a map to all the memory
    std::ostringstream msg("");
    const std::string lbl = "map_registers";
    json reginfo = conf;
#ifdef DEBUG
    LOG(Log::INF) << log_i(lbl.c_str(),"Mapping registers");
#endif
    st = check_cib_mem(resp);
    if(st != OpcUa_Good)
    {
#ifdef DEBUG
      LOG(Log::ERR) << log_e(lbl.c_str(),"CIB memory not mapped");
#endif
      return st;
    }
    else
    {
      // if there are any registers there, clean them out
      if (m_regs.size())
      {
        m_regs.clear();
      }
      // now grab the entries
      try
      {
        for (auto jt = reginfo.begin(); jt != reginfo.end(); ++jt)
        {
          if (jt.value().at(0) == -1)
          {
            // disabled register
            // skip
            continue;
          }
          conf_param_t tmp;
          // for these, nothing is optional
          // offset corresponds to the
          tmp.reg = m_reg_map.at(jt.value().at(0));
          tmp.offset = jt.value().at(1);
          tmp.bit_high = jt.value().at(2);
          tmp.bit_low = jt.value().at(3);
          tmp.maddr = (tmp.reg.vaddr+(tmp.offset*GPIO_CH_OFFSET));
          tmp.mask = cib::util::bitmask(tmp.bit_high,tmp.bit_low);
#ifdef DEBUG
          LOG(Log::INF) << "Mapping register " << jt.key() << " with reg_id " << tmp.reg.id
              << " offset " << tmp.offset << " bh " << tmp.bit_high << " bl " << tmp.bit_low
              << " addr " << std::hex << tmp.maddr << std::dec << " mask " << std::hex << tmp.mask
              << std::dec << " ";
#endif
          m_regs.insert(std::pair<std::string,conf_param_t>(jt.key(),tmp));
        }
      }
      catch(json::exception &e)
      {
        msg.clear();msg.str("");
        msg << log_e(lbl.c_str()," ") << "Incomplete config fragment [mmap] : " << e.what();
        resp["messages"].push_back(msg.str());
        return OpcUa_Bad;
      }
      catch(std::exception &e)
      {
        msg.clear();msg.str("");
        msg << log_e(lbl.c_str()," ") << "Problem parsing config fragment [mmap] : " << e.what();
        resp["messages"].push_back(msg.str());
        return OpcUa_Bad;
      }
      return OpcUa_Good;
    }
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::validate_config_fragment(json &conf, json &resp)
  {
    // this is just a validation check for the available keys.
    // it will only check the mandatory keys.
    const std::string lbl = "validate_config";
    std::vector<std::string> mandatory_keys = {
        "dac_threshold","alignment_laser","mmap"
    };
    std::vector<std::string> optional_keys = {
        "lbls_width_clocks"
    };
    //
    // actually, check for all entries and report all missing ones
    std::vector<std::string> missing;
    //
    for (auto entry: mandatory_keys)
    {
      if (!conf.contains(entry))
      {
        missing.push_back(entry);
      }
    }
    if (missing.size() > 0)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_e(lbl.c_str(),"Missing mandatory entries in CIB config fragment [");
      for (auto e : missing)
      {
        msg << "(" <<  e << "),";
      }
      msg << "]";
      resp["status"] = "ERROR";
      resp["messages"].push_back(msg.str());
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return OpcUa_BadInvalidArgument;
    }
    //
    missing.clear();
    // check the optional keys
    for (auto entry: optional_keys)
    {
      if (!conf.contains(entry))
      {
        missing.push_back(entry);
      }
    }
    if (missing.size() > 0)
    {
      std::ostringstream msg("");
      msg.clear(); msg.str("");
      msg << log_w(lbl.c_str(),"Missing optional entries in CIB config fragment [");
      for (auto e : missing)
      {
        msg << "(" <<  e << "),";
      }
      msg << "]";
      resp["messages"].push_back(msg.str());
    }
    // all good, return true
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::config(json &conf, json &resp)
  {
    const std::string lbl  = "config";
    UaStatus st = OpcUa_Good;
    std::ostringstream msg("");
    st = validate_config_fragment(conf,resp);
    if (st != OpcUa_Good)
    {
      return st;
    }
    // first of all we need to grab the mmap, as the registers need to be mapped
    // prior to attemting writing anything
    if (!conf.contains("mmap"))
    {
      msg.clear(); msg.str("");
      resp["status"] = "ERROR";
      msg << log_e(lbl.c_str(),"Can't find mandatory [mmap] configuration field");
      resp["messages"].push_back(msg.str());
#ifdef DEBUG
      LOG(Log::ERR) << msg.str();
#endif
      resp["statuscode"] = OpcUa_BadInvalidArgument;
      return OpcUa_BadInvalidArgument;
    }
    else
    {
      st = map_registers(conf.at("mmap"),resp);
      if (st != OpcUa_Good)
      {
        return st;
      }
    }
    // -- now that registers are mapped, we can process the configuration
    for (json::iterator it = conf.begin(); it != conf.end(); ++it)
    {
      LOG(Log::INF) << "Processing " << it.key() << " : " << it.value() << "\n";
      if (it.key() == "dac_threshold")
      {
        //
        uint16_t v = it.value();
        st = set_dac_threshold(v,resp);
        if (st != OpcUa_Good)
        {
          resp["status"] = "ERROR";
          resp["messages"].push_back("Failed to set DAC threshold");
          resp["statuscode"] = OpcUa_Bad;
          return st;
        }
      }
      if (it.key() == "alignment_laser")
      {
        // this requires the other two to be loaded as well
        json sobj= it.value();
        // first grab the width and period
        uint32_t width, period;
        width = sobj.at("width").get<uint32_t>();
        // set the width
        if (m_regs.find("align_width") != m_regs.end())
        {
#ifdef DEBUG
          LOG(Log::INF) << log_i(lbl.c_str(), "Setting align width to ") << width;
#endif
          set_cib_align_width(m_regs.at("align_width"),width);
        }
        else
        {
          msg.clear(); msg.str("");
          msg << log_e(lbl.c_str(),"Failed to find register in configuration fragment : align_width");
          resp["status"]= "ERROR";
          resp["messages"].push_back(msg.str());
          resp["statuscode"]= OpcUa_BadInvalidArgument;
          return OpcUa_BadInvalidArgument;
        }
        period = sobj.at("period").get<uint32_t>();
        if (m_regs.find("align_period") != m_regs.end())
        {
#ifdef DEBUG
          LOG(Log::INF) << log_i(lbl.c_str(), "Setting align period to ") << period;
#endif
          set_cib_align_period(m_regs.at("align_period"),period);
        }
        else
        {
          msg.clear(); msg.str("");
          msg << log_e(lbl.c_str(),"Failed to find register in configuration fragment : align_period");
          resp["status"]= "ERROR";
          resp["messages"].push_back(msg.str());
          resp["statuscode"]= OpcUa_BadInvalidArgument;
          return OpcUa_BadInvalidArgument;
        }
        bool align_enabled = sobj.at("enabled").get<bool>();
        if (m_regs.find("align_state") != m_regs.end())
        {
#ifdef DEBUG
          LOG(Log::INF) << log_i(lbl.c_str(), "Setting align state to ") << align_enabled;
#endif
          set_cib_align_state(m_regs.at("align_state"),align_enabled);
        }
        else
        {
          msg.clear(); msg.str("");
          msg << log_e(lbl.c_str(),"Failed to find register in configuration fragment : align_state");
          resp["status"]= "ERROR";
          resp["messages"].push_back(msg.str());
          resp["statuscode"]= OpcUa_BadInvalidArgument;
          return OpcUa_BadInvalidArgument;
        }
      }
      if (it.key() == "lbls_width_clks")
      {
        //
        uint32_t v = it.value();
        st = get_cib_lbls_width(m_regs.at("lbls_width"),v);
        if (st != OpcUa_Good)
        {
          resp["status"] = "ERROR";
          resp["messages"].push_back("Failed to set LBLS pulse width");
          resp["statuscode"] = OpcUa_Bad;
          return st;
        }
      }
    }
    return OpcUa_Good;
  }
  void DIoLCIB::refresh_pdts()
  {
    UaStatus st = OpcUa_Good;
    if (m_regs.find("pdts_status") != m_regs.end())
    {
      uint8_t pdts_stat,pdts_addr;
      st = cib_pdts_status(m_regs.at("pdts_status").maddr,pdts_stat,pdts_addr);
    }
    else
    {
      getAddressSpaceLink()->setPdts_state(0xF,OpcUa_Uncertain);
      getAddressSpaceLink()->setPdts_address(0xF,OpcUa_Uncertain);
    }
  }
  void DIoLCIB::refresh_registers()
  {
    UaStatus st = OpcUa_Good;
    uint32_t value;
    bool enabled;
    if (m_regs.find("trigger_pulser")!= m_regs.end())
    {
      st = get_cib_trigger_pulser_state(m_regs.at("trigger_pulser"),value);
    }
    else
    {
      getAddressSpaceLink()->setTrigger_pulser_enabled(m_trigger_pulser_enabled,OpcUa_BadWaitingForInitialData);
    }
    if (m_regs.find("trigger_external")!= m_regs.end())
    {
      st = get_cib_trigger_external_state(m_regs.at("trigger_external"),value);
    }
    else
    {
      getAddressSpaceLink()->setTrigger_external_enabled(m_trigger_external_enabled,OpcUa_BadWaitingForInitialData);
    }
    if (m_regs.find("daq_queue_state")!= m_regs.end())
    {
      st = get_cib_daq_queue_state(m_regs.at("daq_queue_state"),enabled);
    }
    else
    {
      getAddressSpaceLink()->setDaq_queue_enabled(m_daq_queue_enabled,OpcUa_BadWaitingForInitialData);
    }
    if (m_regs.find("lbls_queue_state")!= m_regs.end())
    {
      st = get_cib_lbls_queue_state(m_regs.at("lbls_queue_state"),enabled);
    }
    else
    {
      getAddressSpaceLink()->setLbls_queue_enabled(m_lbls_enabled,OpcUa_BadWaitingForInitialData);
    }
    if (m_regs.find("lbls_width")!= m_regs.end())
    {
      st = get_cib_lbls_queue_state(m_regs.at("lbls_width"),enabled);
    }
    else
    {
      getAddressSpaceLink()->setLbls_pulse_width_clocks(m_lbls_width,OpcUa_BadWaitingForInitialData);
    }
    if (m_regs.find("align_width")!= m_regs.end())
    {
      st = get_cib_align_width(m_regs.at("align_width"),value);
    }
    else
    {
      getAddressSpaceLink()->setAlign_laser_width(m_align_width,OpcUa_BadWaitingForInitialData);
    }
    if (m_regs.find("align_period")!= m_regs.end())
    {
      st = get_cib_align_period(m_regs.at("align_period"),value);
    }
    else
    {
      getAddressSpaceLink()->setAlign_laser_period(m_align_period,OpcUa_BadWaitingForInitialData);
    }
    if (m_regs.find("align_state")!= m_regs.end())
    {
      bool enabled;
      st = get_cib_align_state(m_regs.at("align_state"),enabled);
    }
    else
    {
      getAddressSpaceLink()->setAlign_laser_enabled(m_align_enabled,OpcUa_BadWaitingForInitialData);
    }
  }


  UaStatus DIoLCIB::cib_pdts_status(uintptr_t &addr, uint8_t &pdts_stat, uint8_t &pdts_addr)
  {
    // information in the pdts status register:
    // [0:3]  : status
    // [4:11] : ctrl
    // [12:12]  : dna_addr_done
    // [13:15]  : padding
    // [16:31] : address

    // first channel of the GPIO is the read one
    uint32_t reg_val = cib::util::reg_read(addr);
    uint32_t mask = cib::util::bitmask(3,0);
    pdts_stat = (reg_val & mask);
    getAddressSpaceLink()->setPdts_state((pdts_stat & 0xFF),OpcUa_Good);
    // now remake the mask to get the current address
    mask = cib::util::bitmask(31,16);
    pdts_addr = ((reg_val & mask)>>16);
    getAddressSpaceLink()->setPdts_address((pdts_addr & 0xFF),OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::reset_pdts(json &resp)
  {
    if (m_regs.find("pdts_reset") != m_regs.end())
    {
      return cib_pdts_reset(m_regs.at("pdts_reset"),resp);
    }
    else
    {
      return OpcUa_BadInvalidArgument;
    }
  }
  UaStatus DIoLCIB::cib_pdts_reset(conf_param_t &reg, json&resp)
  {
    set_cib_value(reg,0x1);
    std::this_thread::sleep_for(std::chrono::microseconds(10));
    set_cib_value(reg,0x0);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::get_cib_trigger_pulser_state(conf_param_t &reg, uint32_t &state)
  {
    uint32_t val;
    get_cib_value(reg,val);
    state = (val & 0xFF);
    m_trigger_pulser_enabled = (state == 0x1);
    getAddressSpaceLink()->setTrigger_pulser_enabled(m_trigger_pulser_enabled,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::set_cib_trigger_pulser_state(conf_param_t &reg, uint32_t &state)
  {
    set_cib_value(reg,state);
    m_trigger_pulser_enabled = (state == 0x1);
    getAddressSpaceLink()->setTrigger_pulser_enabled(m_trigger_pulser_enabled,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::get_cib_trigger_external_state(conf_param_t &reg, uint32_t &state)
  {
    uint32_t reg_val;
    get_cib_value(reg,reg_val);
    state = reg_val & 0xFF;
    m_trigger_external_enabled = (state == 0x1);
    getAddressSpaceLink()->setTrigger_external_enabled(m_trigger_external_enabled,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::set_cib_trigger_external_state(conf_param_t &reg, uint32_t &state)
  {
    set_cib_value(reg,state);
    m_trigger_external_enabled = (state == 0x1);
    getAddressSpaceLink()->setTrigger_external_enabled(m_trigger_external_enabled,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::get_cib_daq_queue_state(conf_param_t &reg, bool &enabled)
  {
    uint32_t reg_val;
    get_cib_value(reg,reg_val);
    enabled = (reg_val == 0x1);
    m_daq_queue_enabled = enabled;
    getAddressSpaceLink()->setDaq_queue_enabled(enabled,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::get_cib_lbls_queue_state(conf_param_t &reg, bool &enabled)
  {
    uint32_t reg_val;
    get_cib_value(reg,reg_val);
    enabled = (reg_val == 0x1);
    m_lbls_enabled = enabled;
    getAddressSpaceLink()->setLbls_queue_enabled(enabled,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::get_cib_lbls_width(conf_param_t &reg, uint32_t &value)
  {
    get_cib_value(reg,value);
    m_lbls_width = value;
    getAddressSpaceLink()->setLbls_pulse_width_clocks(value,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::set_cib_lbls_width(conf_param_t &reg, const uint32_t value)
  {
    set_cib_value(reg,value);
    m_lbls_width = value;
    getAddressSpaceLink()->setLbls_pulse_width_clocks(value,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::get_cib_align_state(conf_param_t &reg, bool &enabled)
  {
    uint32_t value;
    get_cib_value(reg,value);
    enabled = (value == 0x1);
    m_align_enabled = enabled;
    getAddressSpaceLink()->setAlign_laser_enabled(enabled,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::set_cib_align_state(conf_param_t &reg, bool &enabled)
  {
    uint32_t value = (enabled)?0x1:0x0;
    set_cib_value(reg,value);
    m_align_enabled = enabled;
    getAddressSpaceLink()->setAlign_laser_enabled(enabled,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::set_cib_align_width(conf_param_t &reg, uint32_t &width)
  {
    set_cib_value(reg,width);
    m_align_width = width;
    getAddressSpaceLink()->setAlign_laser_width(width,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::get_cib_align_width(conf_param_t &reg, uint32_t &width)
  {
    get_cib_value(reg,width);
    m_align_width = width;
    getAddressSpaceLink()->setAlign_laser_width(width,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::set_cib_align_period(conf_param_t &reg, uint32_t &value)
  {
    set_cib_value(reg,value);
    m_align_period= value;
    getAddressSpaceLink()->setAlign_laser_period(value,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::get_cib_align_period(conf_param_t &reg, uint32_t &value)
  {
    get_cib_value(reg,value);
    m_align_period = value;
    getAddressSpaceLink()->setAlign_laser_period(value,OpcUa_Good);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::get_cib_state(conf_param_t &reg, bool &enabled)
  {
    uint32_t reg_val = cib::util::reg_read(reg.maddr);
    uint32_t state = ((reg_val & reg.mask) >> reg.bit_low);
    enabled = (state == 0x1);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::get_cib_value(conf_param_t &reg, uint32_t &value)
  {
    uint32_t reg_val = cib::util::reg_read(reg.maddr);
    value = ((reg_val & reg.mask) >> reg.bit_low);
    return OpcUa_Good;
  }
  UaStatus DIoLCIB::set_cib_value(conf_param_t &reg, const uint32_t value)
  {
#ifdef DEBUG
    LOG(Log::INF) << log_i("cib_set","Writting into ")
        << " addr 0x" << std::hex << reg.maddr << std::dec
        << " val " << value
        << " mask 0x" << std::hex << reg.mask << std::dec
        << " offset " << reg.bit_low;
#endif
    cib::util::reg_write_mask_offset(reg.maddr, value, reg.mask, reg.bit_low);
    return OpcUa_Good;
  }
}
